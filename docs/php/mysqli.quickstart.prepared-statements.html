<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Prepared Statements</title>

 </head>
 <body><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="mysqli.quickstart.statements.html">Executing statements</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="mysqli.quickstart.stored-procedures.html">Stored Procedures</a></div>
 <div class="up"><a href="mysqli.quickstart.html">Quickstart</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="mysqli.quickstart.prepared-statements" class="section">
  <h2 class="title">Prepared Statements</h2>
  <p class="para">
   The MySQL database supports prepared statements. A prepared statement
   or a parameterized statement is used to execute the same statement
   repeatedly with high efficiency.
  </p>
  <p class="para">
   <em class="emphasis">Basic workflow</em>
  </p>
  <p class="para">
   The prepared statement execution consists of two stages:
   prepare and execute. At the prepare stage a statement template is send
   to the database server. The server performs a syntax check and initializes
   server internal resources for later use.
  </p>
  <p class="para">
   The MySQL server supports using anonymous, positional placeholder
   with <i>?</i>.
  </p>
  <p class="para">
   <div class="example" id="example-1560">
    <p><b>Example #1 First stage: prepare</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
$mysqli&nbsp;=&nbsp;new&nbsp;mysqli("example.com",&nbsp;"user",&nbsp;"password",&nbsp;"database");<br />if&nbsp;($mysqli-&gt;connect_errno))<br />&nbsp;echo&nbsp;"Failed&nbsp;to&nbsp;connect&nbsp;to&nbsp;MySQL:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;connect_errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;connect_error;<br /><br />/*&nbsp;Non-prepared&nbsp;statement&nbsp;*/<br />if&nbsp;(!$mysqli-&gt;query("DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;test")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("CREATE&nbsp;TABLE&nbsp;test(id&nbsp;INT)"))<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Table&nbsp;creation&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />/*&nbsp;Prepared&nbsp;statement,&nbsp;stage&nbsp;1:&nbsp;prepare&nbsp;*/<br />if&nbsp;(!($stmt&nbsp;=&nbsp;$mysqli-&gt;prepare("INSERT&nbsp;INTO&nbsp;test(id)&nbsp;VALUES&nbsp;(?)")))<br />&nbsp;echo&nbsp;"Prepare&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;</span>
</code></div>
    </div>

   </div>
  </p>
  <p class="para">
   Prepare is followed by execute. During execute the client binds
   parameter values and sends them to the server. The server creates a
   statement from the statement template and the bound values to
   execute it using the previously created internal resources.
  </p>
  <p class="para">
   <div class="example" id="example-1561">
    <p><b>Example #2 Second stage: bind and execute</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
/*&nbsp;Prepared&nbsp;statement,&nbsp;stage&nbsp;2:&nbsp;bind&nbsp;and&nbsp;execute&nbsp;*/<br />$id&nbsp;=&nbsp;1;<br />if&nbsp;(!$stmt-&gt;bind_param("i",&nbsp;$id))<br />&nbsp;echo&nbsp;"Binding&nbsp;parameters&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />if&nbsp;(!$stmt-&gt;execute())<br />&nbsp;echo&nbsp;"Execute&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;</span>
</code></div>
    </div>

   </div>
  </p>
  <p class="para">
   <em class="emphasis">Repeated execution</em>
  </p>
  <p class="para">
   A prepared statement can be executed repeatedly. Upon every execution
   the current value of the bound variable is evaluated and send to the server.
   The statement is not parsed again. The statement template is not
   transferred to the server again.
  </p>
  <p class="para">
   <div class="example" id="example-1562">
    <p><b>Example #3 INSERT prepared once, executed multiple times</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
$mysqli&nbsp;=&nbsp;new&nbsp;mysqli("example.com",&nbsp;"user",&nbsp;"password",&nbsp;"database");<br />if&nbsp;($mysqli-&gt;connect_errno))<br />&nbsp;echo&nbsp;"Failed&nbsp;to&nbsp;connect&nbsp;to&nbsp;MySQL:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;connect_errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;connect_error;<br /><br />/*&nbsp;Non-prepared&nbsp;statement&nbsp;*/<br />if&nbsp;(!$mysqli-&gt;query("DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;test")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("CREATE&nbsp;TABLE&nbsp;test(id&nbsp;INT)"))<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Table&nbsp;creation&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />/*&nbsp;Prepared&nbsp;statement,&nbsp;stage&nbsp;1:&nbsp;prepare&nbsp;*/<br />if&nbsp;(!($stmt&nbsp;=&nbsp;$mysqli-&gt;prepare("INSERT&nbsp;INTO&nbsp;test(id)&nbsp;VALUES&nbsp;(?)")))<br />&nbsp;echo&nbsp;"Prepare&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />/*&nbsp;Prepared&nbsp;statement,&nbsp;stage&nbsp;2:&nbsp;bind&nbsp;and&nbsp;execute&nbsp;*/<br />$id&nbsp;=&nbsp;1;<br />if&nbsp;(!$stmt-&gt;bind_param("i",&nbsp;$id))<br />&nbsp;echo&nbsp;"Binding&nbsp;parameters&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />if&nbsp;(!$stmt-&gt;execute())<br />&nbsp;echo&nbsp;"Execute&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />/*&nbsp;Prepared&nbsp;statement:&nbsp;repeated&nbsp;execution,&nbsp;only&nbsp;data&nbsp;transferred&nbsp;from&nbsp;client&nbsp;to&nbsp;server&nbsp;*/<br />for&nbsp;($id&nbsp;=&nbsp;2;&nbsp;$id&nbsp;&lt;&nbsp;5;&nbsp;$id++)<br />&nbsp;&nbsp;if&nbsp;(!$stmt-&gt;execute())<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Execute&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />/*&nbsp;explicit&nbsp;close&nbsp;recommended&nbsp;*/<br />$stmt-&gt;close();<br /><br />/*&nbsp;Non-prepared&nbsp;statement&nbsp;*/<br />$res&nbsp;=&nbsp;$mysqli-&gt;query("SELECT&nbsp;id&nbsp;FROM&nbsp;test");<br />var_dump($res-&gt;fetch_all());</span>
</code></div>
    </div>

    <div class="example-contents"><p>The above example will output:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
array(4) {
  [0]=&gt;
  array(1) {
    [0]=&gt;
    string(1) &quot;1&quot;
  }
  [1]=&gt;
  array(1) {
    [0]=&gt;
    string(1) &quot;2&quot;
  }
  [2]=&gt;
  array(1) {
    [0]=&gt;
    string(1) &quot;3&quot;
  }
  [3]=&gt;
  array(1) {
    [0]=&gt;
    string(1) &quot;4&quot;
  }
}
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   Every prepared statement occupies server resources.
   Statements should be closed explicitly immediately after use.
   If not done explicitly, the statement will be closed when the
   statement handle is freed by PHP.
  </p>
  <p class="para">
   Using a prepared statement is not always the most efficient
   way of executing a statement. A prepared statement executed only
   once causes more client-server round-trips than a non-prepared statement.
   This is why the <i>SELECT</i> is not run as a
   prepared statement above.
  </p>
  <p class="para">
   Also, consider the use of the MySQL multi-INSERT SQL syntax for INSERTs.
   For the example, belows multi-INSERT requires less round-trips between
   the server and client than the prepared statement shown above.
  </p>
  <p class="para">
   <div class="example" id="example-1563">
    <p><b>Example #4 Less round trips using multi-INSERT SQL</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
if&nbsp;(!$mysqli-&gt;query("INSERT&nbsp;INTO&nbsp;test(id)&nbsp;VALUES&nbsp;(1),&nbsp;(2),&nbsp;(3),&nbsp;(4)"))<br />&nbsp;echo&nbsp;"Multi-INSERT&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;</span>
</code></div>
    </div>

   </div>
  </p>
  <p class="para">
   <em class="emphasis">Result set values data types</em>
  </p>
  <p class="para">
   The MySQL Client Server Protocol defines a different data transfer protocol
   for prepared statements and non-prepared statements. Prepared statements
   are using the so called binary protocol. The MySQL server sends result
   set data &quot;as is&quot; in binary format. Results are not serialized into
   strings before sending. The client libraries do not receive strings only.
   Instead, they will receive binary data and try to convert the values into
   appropriate PHP data types. For example, results from an SQL
   <i>INT</i> column will  be provided as PHP integer variables.
  </p>
  <p class="para">
   <div class="example" id="example-1564">
    <p><b>Example #5 Native datatypes</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
$mysqli&nbsp;=&nbsp;new&nbsp;mysqli("example.com",&nbsp;"user",&nbsp;"password",&nbsp;"database");<br />if&nbsp;($mysqli-&gt;connect_errno))<br />&nbsp;echo&nbsp;"Failed&nbsp;to&nbsp;connect&nbsp;to&nbsp;MySQL:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;connect_errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;connect_error;<br /><br />if&nbsp;(!$mysqli-&gt;query("DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;test")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("CREATE&nbsp;TABLE&nbsp;test(id&nbsp;INT,&nbsp;label&nbsp;CHAR(1))")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("INSERT&nbsp;INTO&nbsp;test(id,&nbsp;label)&nbsp;VALUES&nbsp;(1,&nbsp;'a')"))<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Table&nbsp;creation&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />$stmt&nbsp;=&nbsp;$mysqli-&gt;prepare("SELECT&nbsp;id,&nbsp;label&nbsp;FROM&nbsp;test&nbsp;WHERE&nbsp;id&nbsp;=&nbsp;1");<br />$stmt-&gt;execute();<br />$res&nbsp;=&nbsp;$stmt-&gt;get_result();<br />$row&nbsp;=&nbsp;$res-&gt;fetch_assoc();<br /><br />printf("id&nbsp;=&nbsp;%s&nbsp;(%s)\n",&nbsp;$row['id'],&nbsp;gettype($row['id']));<br />printf("label&nbsp;=&nbsp;%s&nbsp;(%s)\n",&nbsp;$row['label'],&nbsp;gettype($row['label']));</span>
</code></div>
    </div>

    <div class="example-contents"><p>The above example will output:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
id = 1 (integer)
label = a (string)
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   This behaviour differes from non-prepared statements. By default,
   non-prepared statements return all results as strings.
   This default can be changed using a connection option.
   If the connection option is used, there are no differences.
  </p>
  <p class="para">
   <em class="emphasis">Fetching results using bound variables</em>
  </p>
  <p class="para">
   Results from prepared statements can either be retrieved by
   binding output variables or by requesting a mysqli_result object.
  </p>
  <p class="para">
   Output variables must be bound after statement execution.
   One variable must be bound for every column of the statements result set.
  </p>
  <p class="para">
   <div class="example" id="example-1565">
    <p><b>Example #6 Output variable binding</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
$mysqli&nbsp;=&nbsp;new&nbsp;mysqli("example.com",&nbsp;"user",&nbsp;"password",&nbsp;"database");<br />if&nbsp;($mysqli-&gt;connect_errno))<br />&nbsp;echo&nbsp;"Failed&nbsp;to&nbsp;connect&nbsp;to&nbsp;MySQL:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;connect_errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;connect_error;<br /><br />if&nbsp;(!$mysqli-&gt;query("DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;test")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("CREATE&nbsp;TABLE&nbsp;test(id&nbsp;INT,&nbsp;label&nbsp;CHAR(1))")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("INSERT&nbsp;INTO&nbsp;test(id,&nbsp;label)&nbsp;VALUES&nbsp;(1,&nbsp;'a')"))<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Table&nbsp;creation&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />if&nbsp;(!($stmt&nbsp;=&nbsp;$mysqli-&gt;prepare("SELECT&nbsp;id,&nbsp;label&nbsp;FROM&nbsp;test")))<br />&nbsp;echo&nbsp;"Prepare&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />if&nbsp;(!$stmt-&gt;execute())<br />&nbsp;&nbsp;echo&nbsp;"Execute&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />$out_id&nbsp;=&nbsp;NULL;<br />$out_label&nbsp;=&nbsp;NULL;<br />if&nbsp;(!$stmt-&gt;bind_result($out_id,&nbsp;$out_label))<br />&nbsp;echo&nbsp;"Binding&nbsp;output&nbsp;parameters&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />while&nbsp;($stmt-&gt;fetch())<br />&nbsp;printf("id&nbsp;=&nbsp;%s&nbsp;(%s),&nbsp;label&nbsp;=&nbsp;%s&nbsp;(%s)\n",<br />&nbsp;&nbsp;&nbsp;$out_id,&nbsp;gettype($out_id),<br />&nbsp;&nbsp;&nbsp;$out_label,&nbsp;gettype($out_label));</span>
</code></div>
    </div>

    <div class="example-contents"><p>The above example will output:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
id = 1 (integer), label = a (string)
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   Prepared statements return unbuffered result sets by default.
   The results of the statement are not implicitly fetched and transferred
   from the server to the client for client-side buffering. The result set
   takes server resources until all results have been fetched by the client.
   Thus it is recommended to consume results timely. If a client fails to fetch all
   results or the client closes the statement before having fetched all data,
   the data has to be fetched implicitly by <i>mysqli</i>.
  </p>
  <p class="para">
   It is also possible to buffer the results of a prepared statement
   using <span class="function"><a href="mysqli-stmt.store-result.html" class="function">mysqli_stmt_store_result()</a></span>.
  </p>
  <p class="para">
   <em class="emphasis">Fetching results using mysqli_result interface</em>
  </p>
  <p class="para">
   Instead of using bound results, results can also be retrieved through the
   mysqli_result interface. <span class="function"><a href="mysqli-stmt.get-result.html" class="function">mysqli_stmt_get_result()</a></span>
   returns a buffered result set.
  </p>
  <p class="para">
   <div class="example" id="example-1566">
    <p><b>Example #7 Using mysqli_result to fetch results</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
$mysqli&nbsp;=&nbsp;new&nbsp;mysqli("example.com",&nbsp;"user",&nbsp;"password",&nbsp;"database");<br />if&nbsp;($mysqli-&gt;connect_errno))<br />&nbsp;echo&nbsp;"Failed&nbsp;to&nbsp;connect&nbsp;to&nbsp;MySQL:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;connect_errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;connect_error;<br /><br />if&nbsp;(!$mysqli-&gt;query("DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;test")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("CREATE&nbsp;TABLE&nbsp;test(id&nbsp;INT,&nbsp;label&nbsp;CHAR(1))")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("INSERT&nbsp;INTO&nbsp;test(id,&nbsp;label)&nbsp;VALUES&nbsp;(1,&nbsp;'a')"))<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Table&nbsp;creation&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />if&nbsp;(!($stmt&nbsp;=&nbsp;$mysqli-&gt;prepare("SELECT&nbsp;id,&nbsp;label&nbsp;FROM&nbsp;test&nbsp;ORDER&nbsp;BY&nbsp;id&nbsp;ASC")))<br />&nbsp;echo&nbsp;"Prepare&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />if&nbsp;(!$stmt-&gt;execute())<br />&nbsp;&nbsp;echo&nbsp;"Execute&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />if&nbsp;(!($res&nbsp;=&nbsp;$stmt-&gt;get_result()))<br />&nbsp;echo&nbsp;"Getting&nbsp;result&nbsp;set&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />var_dump($res-&gt;fetch_all());</span>
</code></div>
    </div>

    <div class="example-contents"><p>The above example will output:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
array(1) {
  [0]=&gt;
  array(2) {
    [0]=&gt;
    int(1)
    [1]=&gt;
    string(1) &quot;a&quot;
  }
}
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   Using the mysqli_result interface this has the additional benefit of
   flexible client-side result set navigation.
  </p>
  <p class="para">
   <div class="example" id="example-1567">
    <p><b>Example #8 Buffered result set for flexible read out</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
$mysqli&nbsp;=&nbsp;new&nbsp;mysqli("example.com",&nbsp;"user",&nbsp;"password",&nbsp;"database");<br />if&nbsp;($mysqli-&gt;connect_errno))<br />&nbsp;echo&nbsp;"Failed&nbsp;to&nbsp;connect&nbsp;to&nbsp;MySQL:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;connect_errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;connect_error;<br /><br />if&nbsp;(!$mysqli-&gt;query("DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;test")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("CREATE&nbsp;TABLE&nbsp;test(id&nbsp;INT,&nbsp;label&nbsp;CHAR(1))")&nbsp;||<br />&nbsp;&nbsp;&nbsp;&nbsp;!$mysqli-&gt;query("INSERT&nbsp;INTO&nbsp;test(id,&nbsp;label)&nbsp;VALUES&nbsp;(1,&nbsp;'a'),&nbsp;(2,&nbsp;'b'),&nbsp;(3,&nbsp;'c')"))<br />&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"Table&nbsp;creation&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />if&nbsp;(!($stmt&nbsp;=&nbsp;$mysqli-&gt;prepare("SELECT&nbsp;id,&nbsp;label&nbsp;FROM&nbsp;test")))<br />&nbsp;echo&nbsp;"Prepare&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$mysqli-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$mysqli-&gt;error;<br /><br />if&nbsp;(!$stmt-&gt;execute())<br />&nbsp;&nbsp;echo&nbsp;"Execute&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />if&nbsp;(!($res&nbsp;=&nbsp;$stmt-&gt;get_result()))<br />&nbsp;echo&nbsp;"Getting&nbsp;result&nbsp;set&nbsp;failed:&nbsp;("&nbsp;.&nbsp;$stmt-&gt;errno&nbsp;.&nbsp;")&nbsp;"&nbsp;.&nbsp;$stmt-&gt;error;<br /><br />for&nbsp;($row_no&nbsp;=&nbsp;($res-&gt;num_rows&nbsp;-&nbsp;1);&nbsp;$row_no&nbsp;&gt;=&nbsp;0;&nbsp;$row_no--)&nbsp;{<br />&nbsp;&nbsp;$res-&gt;data_seek($row_no);<br />&nbsp;&nbsp;var_dump($res-&gt;fetch_assoc());<br />}<br />$res-&gt;close();</span>
</code></div>
    </div>

    <div class="example-contents"><p>The above example will output:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
array(2) {
  [&quot;id&quot;]=&gt;
  int(3)
  [&quot;label&quot;]=&gt;
  string(1) &quot;c&quot;
}
array(2) {
  [&quot;id&quot;]=&gt;
  int(2)
  [&quot;label&quot;]=&gt;
  string(1) &quot;b&quot;
}
array(2) {
  [&quot;id&quot;]=&gt;
  int(1)
  [&quot;label&quot;]=&gt;
  string(1) &quot;a&quot;
}
</pre></div>
    </div>
   </div>
  </p>
  <p class="para">
   <em class="emphasis">Escaping and SQL injection</em>
  </p>
  <p class="para">
   Bound variables will be escaped automatically by the server. The server
   inserts their escaped values at the appropriate places into the statement
   template before execution. Users must hint the server about the type of the
   bound variable for appropriate conversion,
   see <span class="function"><a href="mysqli-stmt.bind-param.html" class="function">mysqli_stmt_bind_param()</a></span>.
  </p>
  <p class="para">
   The automatic escaping of values within the server is sometimes considered
   as a security feature to prevent SQL injection. The same degree of security
   can be achieved with non-prepared statements, if input values are
   escaped correctly.
  </p>
  <p class="para">
   <em class="emphasis">Client-side prepared statement emulation</em>
  </p>
  <p class="para">
   The API does not include a client-side prepared statement emulation.
  </p>
  <p class="para">
   <em class="emphasis">Quick prepared - non-prepared statement comparison</em>
  </p>
  <p class="para">
   The below table gives a quick comparison on server-side prepared and non-prepared statements.
  </p>
  <table class="doctable informaltable">
   
    <thead valign="middle">
     <tr valign="middle">
      <th class="empty">&nbsp;</th>
      <th>Prepared Statement</th>
      <th>Non-prepared statement</th>
    </tr>

    </thead>

    <tbody valign="middle" class="tbody">
     <tr valign="middle">
      <td align="left">Client-server round trips, SELECT, single execution</td>
      <td align="left">2</td>
      <td align="left">1</td>
     </tr>

     <tr valign="middle">
      <td align="left">Statement string transferred from client to server</td>
      <td align="left">1</td>
      <td align="left">1</td>
     </tr>

     <tr valign="middle">
      <td align="left">Client-server round trips, SELECT, repeated (n) execution</td>
      <td align="left">1 + n</td>
      <td align="left">n</td>
     </tr>

     <tr valign="middle">
      <td align="left">Statement string transferred from client to server</td>
      <td align="left">1 template, n times bound parameter, if any</td>
      <td align="left">n times together with parameter, if any</td>
     </tr>

     <tr valign="middle">
      <td align="left">Input parameter binding API</td>
      <td align="left">yes, automatic input escaping</td>
      <td align="left">no, manual input escaping</td>
     </tr>

     <tr valign="middle">
      <td align="left">Output variable binding API</td>
      <td align="left">yes</td>
      <td align="left">no</td>
     </tr>

     <tr valign="middle">
      <td align="left">Supports use of mysqli_result API</td>
      <td align="left">yes, use <span class="function"><a href="mysqli-stmt.get-result.html" class="function">mysqli_stmt_get_result()</a></span></td>
      <td align="left">yes</td>
     </tr>

     <tr valign="middle">
      <td align="left">Buffered result sets</td>
      <td align="left">
       yes, use <span class="function"><b>mysqli_stmt_get_result()()</b></span> or
       binding with <span class="function"><a href="mysqli-stmt.store-result.html" class="function">mysqli_stmt_store_result()</a></span>
      </td>
      <td align="left">yes, default of <span class="function"><a href="mysqli.query.html" class="function">mysqli_query()</a></span></td>
     </tr>

     <tr valign="middle">
      <td align="left">Unbuffered result sets</td>
      <td align="left">yes, use output binding API</td>
      <td align="left">
       yes, use <span class="function"><a href="mysqli.real-query.html" class="function">mysqli_real_query()</a></span> with
       <span class="function"><a href="mysqli.use-result.html" class="function">mysqli_use_result()</a></span>
      </td>
     </tr>

     <tr valign="middle">
      <td align="left">MySQL Client Server protocol data transfer flavour</td>
      <td align="left">binary protocol</td>
      <td align="left">text protocol</td>
     </tr>

     <tr valign="middle">
      <td align="left">Result set values SQL data types</td>
      <td align="left">preserved when fetching</td>
      <td align="left">converted to string or preserved when fetching</td>
     </tr>

     <tr valign="middle">
      <td align="left">Supports all SQL statements</td>
      <td align="left">Recent MySQL versions support most but not all</td>
      <td align="left">yes</td>
     </tr>

    </tbody>
   
  </table>

  <p class="para">
   <em class="emphasis">See also</em>
  </p>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="methodname"><a href="mysqli.construct.html" class="methodname">mysqli::__construct()</a></span></li>
    <li class="member"><a href="mysqli.query.html" class="link"> <span class="methodname"><a href="mysqli.query.html" class="methodname">mysqli::query()</a></span></a></li>
    <li class="member"><a href="mysqli.prepare.html" class="link"> <span class="methodname"><a href="mysqli.prepare.html" class="methodname">mysqli::prepare()</a></span></a></li>
    <li class="member"><a href="mysqli-stmt.prepare.html" class="link"> <span class="methodname"><a href="mysqli-stmt.prepare.html" class="methodname">mysqli_stmt::prepare()</a></span></a></li>
    <li class="member"><a href="mysqli-stmt.execute.html" class="link"> <span class="methodname"><a href="mysqli-stmt.execute.html" class="methodname">mysqli_stmt::execute()</a></span></a></li>
    <li class="member"><a href="mysqli-stmt.bind-param.html" class="link"> <span class="methodname"><a href="mysqli-stmt.bind-param.html" class="methodname">mysqli_stmt::bind_param()</a></span></a></li>
    <li class="member"><a href="mysqli-stmt.bind-result.html" class="link"> <span class="methodname"><a href="mysqli-stmt.bind-result.html" class="methodname">mysqli_stmt::bind_result()</a></span></a></li>
   </ul>
  </p>
 </div><hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="mysqli.quickstart.statements.html">Executing statements</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="mysqli.quickstart.stored-procedures.html">Stored Procedures</a></div>
 <div class="up"><a href="mysqli.quickstart.html">Quickstart</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
