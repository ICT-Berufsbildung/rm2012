<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>SELFHTML: XML / Darstellung von XML-Daten / XPath-Funktionen</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Welche Funktionen XPath bereitstellt, die innerhalb von XSLT-Elementen anwendbar sind.">
<meta name="keywords"       content="SELFHTML, XML, XPath, XPath-Funktionen">
<meta name="author"         content="Redaktion SELFHTML, selfhtml81@selfhtml.org">
<meta name="robots"         content="noindex, nofollow">
<meta name="DC.Publisher"   content="SELFHTML e. V.">
<meta name="DC.Date"        content="2005-11-16T22:49:39+02:00">
<meta name="DC.Identifier"  content="http://de.selfhtml.org/xml/darstellung/css.htm">
<meta name="DC.Language"    content="de">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.created" content="2001-10-27T08:00+01:00">
<meta name="SELF.Pagetype"  content="page">
<link rel="alternate" type="application/atom+xml" title="SELFHTML-Weblog (Atom, gesamt)" href="http://aktuell.de.selfhtml.org/weblog/atom-feed">
<link rel="alternate" type="application/rss+xml" title="SELFHTML-Weblog (RSS, Auszüge)" href="http://aktuell.de.selfhtml.org/weblog/rss-feed">
<link rel="shortcut icon" type="image/x-icon" href="../../src/favicon.ico">
<link rel="author" title="Impressum" href="../../editorial/impressum.htm">
<link rel="contents" title="Inhaltsverzeichnis" href="../../navigation/inhalt.htm">
<link rel="index" title="Stichwortverzeichnis" href="../../navigation/stichwort.htm">
<link rel="search" title="Suche" href="../../navigation/suche/index.htm">
<link rel="help" title="Hilfe" href="../../editorial/index.htm">
<link rel="copyright" title="Urheberrecht" href="../../editorial/copyright.htm">
<link rel="top" title="SELFHTML" href="../../index.htm">
<link rel="up" title="Darstellung von XML-Daten" href="index.htm">
<link rel="next" title="Einführung in JavaScript und DOM" href="../../javascript/intro.htm">
<link rel="prev" title="XPath-Syntax" href="xpathsyntax.htm">
<link rel="first" title="XML-Darstellung mit Stylesheets" href="css.htm">
</head>
<body>

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td colspan="2" class="nav"><a class="an" name="top"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">XML/DTDs</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Darstellung von XML-Daten</a></td>
</tr>
<tr>
<td class="doc" width="110"><a href="../../index.htm"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></a></td>
<td class="docbot" width="100%"><h1 class="ph1">XPath-Funktionen</h1></td>
</tr>
<tr>
<td class="doctop">
<img src="../../src/dokx.gif" width="30" height="20" vspace="6" alt="Informationsseite">
</td>
<td valign="top" nowrap="nowrap">
<p>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#Hinweise">Hinweise zu den XPath-Funktionen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#boolean">boolean()</a> (Argument als wahr oder falsch bewerten)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#ceiling">ceiling()</a> (Zahl aufrunden)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#concat">concat()</a> (Zeichenketten zu einer zusammenfassen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#contains">contains()</a> (auf bestimmte Teilzeichenkette überprüfen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#count">count()</a> (Anzahl Knoten in einem Knoten-Set ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#current">current()</a> (aktuellen Knoten ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#document">document()</a> (anderes XML-Dokument aufrufen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#element_available">element-available()</a> (Verfügbarkeit eines XSLT-Elements überprüfen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#false">false()</a> (booleschen Wert für "falsch" erzeugen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#floor">floor()</a> (Zahl abrunden)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#format_number">format-number()</a> (Zahl in Zeichenkette umwandeln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#function_available">function-available()</a> (Verfügbarkeit einer XPath-Funktion überprüfen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#generate_id">generate-id()</a> (eindeutigen Bezeichner für ein Element generieren)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#id">id()</a> (Element mit bestimmtem Bezeichner auswählen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#key">key()</a> (Elemente mit Hilfe eines Schlüsselwerts auswählen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#lang">lang()</a> (Element auf bestimmten Sprachcode überprüfen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#last">last()</a> (Positionsnummer des letzten Knotens einer Reihe ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#local_name">local-name()</a> (lokalen Namen eines Knoten-Sets ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#name">name()</a> (Namen eines Knoten-Sets ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#namespace_uri">namespace-uri()</a> (Namensraum eines Elements ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#normalize_space">normalize-space()</a> (Leerzeichen am Anfang und Ende einer Zeichenkette entfernen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#not">not()</a> (Argument verneinen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#number">number()</a> (Argument in eine Zahl umwandeln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#position">position()</a> (Positionsnummer des aktuellen Knotens ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#round">round()</a> (kaufmännisch auf- oder abrunden)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#starts_with">starts-with()</a> (Überprüfen, ob Zeichenkette mit bestimmter Teilzeichenkette beginnt)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#string">string()</a> (Argument in Zeichenkette umwandeln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#string_length">string-length()</a> (Anzahl Zeichen einer Zeichenkette ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#substring">substring()</a> (Teilzeichenkette aus Zeichenkette extrahieren)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#substring_after">substring-after()</a> (Zeichenkette ab einer Position mit Teilzeichenkette ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#substring_before">substring-before()</a> (Zeichenkette vor einer Position mit Teilzeichenkette ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sum">sum()</a> (Summe von Zahlenwerten ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#system_property">system-property()</a> (Systemeigenschaften ermitteln)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#translate">translate()</a> (Suchen und Ersetzen von Zeichen in einer Zeichenkette)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#true">true()</a> (booleschen Wert für "wahr" erzeugen)<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#unparsed_entity_uri">unparsed-entity-uri()</a> (ungeparste Einträge der DTD ermitteln)<br>


</p>
</td>
</tr><tr><td colspan="2" class="doc">&nbsp;<a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>&nbsp;</td></tr>
</table>



<h2><a class="an" name="Hinweise">Hinweise zu den XPath-Funktionen</a></h2>

<p>Funktionen in XPath haben die Aufgabe, die Übersetzung der XML-Ausgangsdaten in den Ergebnisbaum (zum Beispiel nach HTML) genauer zu kontrollieren und dabei zusätzliche Features zur Verfügung zu stellen. Sie sind für den Einsatz innerhalb von XSLT-Stylesheets gedacht. Die einzelnen XPath-Funktionen erfüllen einen bestimmten Zweck (zum Beispiel das Extrahieren einer Teilzeichenkette aus einer Zeichenkette) und liefern im Normalfall einen Wert zurück (zum Beispiel die extrahierte Teilzeichenkette).</p>

<p>Die Funktionen bestehen aus einem Funktionsnamen, gefolgt von runden Klammern, in denen so genannte Argumente stehen können. Argumente werden benötigt, damit eine Funktion ihre Aufgabe erfüllen kann. So muss beispielsweise der Funktion, die aus einer Zeichenkette eine Teilzeichenkette extrahiert, mitgeteilt werden, aus welcher Zeichenkette sie welchen Teil extrahieren soll.<br>
Bei der Beschreibung der Funktionen in diesem Abschnitt wird für jede Funktion beschrieben, ob sie Argumente erwartet, und wenn ja, welche. Wenn mehrere Argumente erforderlich sind, werden die einzelnen Argumente durch Komma getrennt. Wird als Argument eine Zeichenkette notiert, muss diese in Anführungszeichen stehen. Da XPath-Funktionen jedoch meistens innerhalb von Wertzuweisungen an Attribute von XSLT-Elementen vorkommen, die selbst schon in Anführungszeichen stehen, müssen Sie andere Anführungszeichen benutzen. Wenn die Wertzuweisung an das XSLT-Element beispielsweise in doppelten Anführungszeichen steht, muss eine Zeichenkette, die innerhalb davon einer XPath-Funktion übergeben wird, in einfachen Anführungszeichen (Hochkommata) stehen, also z.B. so: <code>&lt;xsl:value-of select="document('datei2.xml')" /&gt;</code>. Zahlen und Namen von Elementen der XML-Daten können dagegen ohne Anführungszeichen übergeben werden.</p>

<p>Da die Funktionen einen Wert zurückgeben, werden sie innerhalb von XSLT normalerweise an den Stellen verwendet, wo Attribute Wertzuweisungen erhalten. So könnte beispielsweise das XSLT-Element <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">value-of</a> in der folgenden Form notiert werden:<br>
<code>&lt;xsl:value-of select="last()" /&gt;</code><br>
Dabei wird also dem <code>select</code>-Attribut ein Wert zugewiesen, allerdings kein fester Wert, sondern ein dynamisch ermittelter. In diesem Fall wird er von der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#last">last()</a> ermittelt.</p>

<p>Generell besteht keine Gewähr, dass jeder XSL-Prozessor, also die XSL interpretierende Software, alle die hier aufgelisteten und zum Standard gehörenden XPath-Funktionen kennt oder in vollem Umfang verarbeitet.</p>

<p>Bei den Beschreibungen der Funktionen ist häufig von Knoten und Knotentypen die Rede. Diese Begriffe werden im Abschnitt <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../regeln/baumstruktur.htm#knoten_knotensets">Knoten und Knoten-Sets in der Baumstruktur</a> einführend erläutert. Vertiefende Informationen dazu stehen im Abschnitt über <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="boolean">boolean() (Argument als wahr oder falsch bewerten)</a></h2>

<p>Ermittelt, ob ein Ausdruck wahr oder falsch ist.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Ausdruck]</code></td>
<td valign="top">irgendein mit XSL realisierbarer Ausdruck, der sich als wahr oder falsch bewerten lässt. Es kann sich z.B. um eine Vergleichsoperation handeln, aber auch um den Test auf Vorhandensein eines Knotens.</td>
</tr>
</table>

<p>Liefert <code>true</code> (wahr) oder <code>false</code> (falsch) zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="name"&gt;
 &lt;xsl:choose&gt;
  &lt;xsl:when test="boolean(vorname) != boolean(nachname)"&gt;
   &lt;xsl:message&gt;Es müssen entweder Vor- und Nachname,
    oder überhaupt kein Name angegeben werden!&lt;/xsl:message&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
   &lt;xsl:apply-templates select="vorname"&gt;
   &lt;xsl:apply-templates select="nachname"&gt;
  &lt;/xsl:otherwise&gt;
 &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird ein Template für ein XML-Element namens <code>name</code> definiert. Es wird angenommen, dass dieses Element zwei untergeordnete Elemente <code>vorname</code> und <code>nachname</code> enthalten muss. Im Beispiel-Stylesheet wird mit <code>&lt;xsl:when test="boolean(vorname) != boolean(nachname)"&gt;</code> abgefragt, ob tatsächlich beide untergeordneten Elemente vorhanden sind. Ist das nicht der Fall, wird eine entsprechende Meldung ausgegeben. Andernfalls wird der <code>xsl:otherwise</code>-Zweig ausgeführt, der die Templates zum Übersetzen der Unterelemente aufruft.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="ceiling">ceiling() (Zahl aufrunden)</a></h2>

<p>Rundet eine Bruchzahl zur nächsthöheren Ganzzahl auf. Die Zahl <code>5.7234</code> wird auf <code>6</code> aufgerundet, aber <code>0.00001</code> wird auch auf <code>1</code> aufgerundet. Wichtig ist, dass "Kommazahlen" den Punkt als Dezimalzeichen haben. Andernfalls werden sie als ungültige Zahlen (<code>NaN</code> - <i>not a number</i>) interpretiert.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zahl]</code></td>
<td valign="top">Die aufzurundende Zahl. Es kann sich auch um den Inhalt eines Knotens oder den einer Variablen handeln. Dabei wird der Wert intern zunächst als Zahl umgewandelt, und zwar so, als würde die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#number">number()</a> angewendet.</td>
</tr>
</table>

<p>Liefert die nächsthöhere Ganzzahl zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:value-of select="ceiling(betrag)" /&gt;&lt;xsl:text&gt;.-&lt;/xsl:text&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird von einem XML-Element namens <code>betrag</code> angenommen, dass es einen "krummen" Wert enthält, der auf den nächsthöheren Euro-Ganzzahlwert aufgerundet werden soll. Dazu wird beim Auswählen des Inhalts von <code>betrag</code> mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> im <code>select</code>-Attribut die Funktion <code>ceiling()</code> aufgerufen. Sie bewirkt, dass der Elementinhalt aufgerundet wird, bevor er in den Ergebnisbaum der Datenausgabe übernommen wird.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="concat">concat() (Zeichenketten zu einer zusammenfassen)</a></h2>

<p>Hängt mehrere Zeichenketten aneinander.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette], [Zeichenkette], ...</code></td>
<td valign="top">Hängt alle Zeichenkette in der angegebenen Reihenfolge aneinander. Es kann sich direkt um Text handeln, aber auch um den Inhalt eines Knotens oder den Wert einer Variablen. Die Zeichenketten werden durch Kommata getrennt.</td>
</tr>
</table>

<p>Liefert die zusammengesetzte Zeichenkette zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:value-of select="concat(vorname, ' heißt mit Zuname ', zuname)"/&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird angenommen, dass es zwei verfügbare XML-Elemente <code>vorname</code> und <code>zuname</code> gibt. Bei der Übersetzung in den Ergebnisbaum soll daraus ein Satz vom Typ <code>Heidi heißt mit Zuname Finkenzeller</code> erzeugt werden. Dazu wird beim Auswählen des Inhalts mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> im <code>select</code>-Attribut die Funktion <code>concat()</code> angewendet. Sie bekommt drei Zeichenketten übergeben: den Inhalt des Elements <code>vorname</code>, die feste Zeichenkette <code>heißt mit Zuname</code>, und den Inhalt des Elements <code>zuname</code>. Beachten Sie, dass Variablennamen, Elementnamen (oder Elementpfade nach <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>) direkt angegeben werden, feste Zeichenketten dagegen in Anführungszeichen eingeschlossen werden. Dabei muss es sich um andere Anführungszeichen handeln als bei dem XSLT-Attribut, innerhalb dessen die Funktion steht. Wenn die Funktion, wie beim Beispiel im <code>select</code>-Attribut, in dessen doppelten Anführungszeichen <code>"..."</code> vorkommt, müssen einfache Anführungszeichen verwendet werden, so wie im Beispiel <code>'&nbsp;heißt mit Zuname&nbsp;'</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="contains">contains() (auf bestimmte Teilzeichenkette überprüfen)</a></h2>

<p>Überprüft, ob in einer Zeichenkette eine bestimmte Teilzeichenkette vorhanden ist.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">Die Zeichenkette, in der überprüft werden soll.</td>
</tr>
<tr>
<td valign="top"><code>[Teilzeichenkette]</code></td>
<td valign="top">Die Teilzeichenkette, auf die hin die Zeichenkette überprüft werden soll.</td>
</tr>
</table>

<p>Liefert <code>true</code> zurück, wenn die Teilzeichenkette vorhanden ist, und <code>false</code>, wenn sie nicht vorhanden ist.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:if test="contains(zuname, 'A')"&gt;
  &lt;xsl:value-of select="zuname" /&gt;
&lt;/xsl:if&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#if">xsl:if</a> geprüft, ob der Wert eines XML-Elements <code>zuname</code> ein großes A enthält. Wenn ja, wird der Inhalt des Elements ausgegeben. Dazu wird im <code>test</code>-Attribut der <code>xsl:if</code>-Anweisung mit <code>contains(zuname,&nbsp;'A')</code> in der Zeichenkette, die das Element <code>zuname</code> speichert, nach der Teilzeichenkette <code>A</code> gesucht. Auf diese Weise könnten also beispielsweise nur Zunamen in den Ergebnisbaum einfließen, die mit A beginnen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="count">count() (Anzahl Knoten in einem Knoten-Set ermitteln)</a></h2>

<p>Ermittelt, wieviele Knoten auf der Ebene unterhalb eines Knoten-Sets enthalten sind.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top">Ein Knoten-Set bzw. einen Pfad nach <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>, für das die Anzahl der darin enthaltenen Knoten der nächstunteren Ebene bestimmt werden soll.</td>
</tr>
</table>

<p>Liefert die Anzahl der untergeordneten Knoten zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:variable name="anzahl" select="count(//listeneintrag)" /&gt;
...
&lt;xsl:template match="liste"&gt;
    &lt;xsl:for-each select="listeneintrag"&gt;
    &lt;p&gt;
        &lt;xsl:value-of select="position()" /&gt;
         &lt;xsl:text&gt;. von &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$anzahl" /&gt;
         &lt;xsl:text&gt;: &lt;/xsl:text&gt;
         &lt;xsl:value-of select="." /&gt;
    &lt;/p&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel nimmt an, dass es ein XML-Element namens <code>liste</code> gibt, das aus mehreren Unterelementen <code>listeneintrag</code> besteht. Zunächst wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#variable">xsl:variable</a> eine Variable namens <code>anzahl</code> definiert, in der die Anzahl der Listeneinträge gespeichert wird. Dazu wird im <code>select</code>-Attribut die Funktion <code>count()</code> angewendet. Als Argument wird ihr das Element <code>listeneintrag</code> übergeben. In der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#for_each">for-each</a>-Schleife, die alle Listeneinträge abarbeitet, wird vor dem Text des Listeneintrags jeweils die aktuelle Positionsnummer mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#position">position()</a> ausgegeben, und dahinter die Gesamtzahl, die in der Variablen <code>anzahl</code> gespeichert ist, also etwa so:<br>
<code>1. von 5: Text des ersten Listeneintrags<br>
2. von 5: Text des zweiten Listeneintrags</code></p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="current">current() (aktuellen Knoten ermitteln)</a></h2>

<p>Stellt den Bezug zum jeweils aktuellen Knoten her.</p>

<p>Erwartet keine Argumente.</p>

<p>Liefert das Knoten-Set zurück, das den aktuellen Knoten enthält.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:value-of select="current()" /&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Die Anweisung im Beispiel drückt das gleiche aus wie die üblichere Anweisung:<br>
<code>&lt;xsl:value-of select="." /&gt;</code></p>

<h3 class="inf">Beachten Sie:</h3>

<p><code>current()</code> und <code>.</code> liefern dann das gleiche Ergebnis, wenn <code>current()</code> in einem freistehenden XPath-Ausdruck steht, also z.B. direkt in einem <code>select</code>-Attribut. Wenn Sie <code>current()</code> dagegen in einem Prädikat (steht immer zwischen <code>[...]</code>) anwenden, kann das zurückgelieferte Ergebnis ein anderes sein als das Ergebnis von <code>select="."</code>. Der Grund ist, dass XPath intern zwischen "current node" und "context node" unterscheidet. Ein "current node", also ein aktueller Knoten, ist nur dann gegeben, wenn ein Knoten-Set der Reihe nach abgearbeitet wird. In diesem Fall ist der jeweils bearbeitete Knoten der "current node". Außerhalb einer solchen Serienbearbeitung gibt es jedoch keinen "current node". Einen "context node", wie man ihn durch die Punkt-Syntax (<code>.</code>) ermitteln kann, ist dagegen zu jedem Zeitpunkt gegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="document">document() (anderes XML-Dokument aufrufen)</a></h2>

<p>Erlaubt es, XML-Ausgangsdaten aus anderen XML-Dateien als der, in der das Stylesheet eingebunden ist, mit in den Ergebnisbaum zu übernehmen.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[URI]</code></td>
<td valign="top">Angabe einer XML-Datei, die mit eingebunden werden soll. Es kann sich um eine relative Adressierung handeln oder um eine absolute Angabe, z.B. <code>http://...</code>. Wird keine andere XML-Datei angegeben, sondern ein Element mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a> adressiert, so wird das Element und gegebenenfalls sein untergeordneter Elementenbaum an dieser Stelle eingebunden. </td>
</tr>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top">(<i>optional</i>) Angabe der Basis innerhalb der eingebundenen Daten, auf das sich relative XPath-Adressierungen beziehen können. Gemeint ist der erste Knoten des Knoten-Sets.</td>
</tr>
</table>

<p>Liefert die ermittelte Elementstruktur der anderen XML-Datei oder des angegebenen Elements ab dem Wurzelelement zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="beispiel"&gt;
 &lt;pre&gt;
  &lt;xsl:value-of select="document(./@quelle)" /&gt;
 &lt;/pre&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird angenommen, dass es ein XML-Element namens <code>beispiel</code> gibt, dass in einem Attribut eine Quellenangabe zu einer XML-Datei enthält, z.B.: <code>&lt;beispiel&nbsp;quelle="../quellen/beispiel03.xml"&nbsp;/&gt;</code>. Im Stylesheet wird für die HTML-Ausgabe dieses Elements mit <code>&lt;pre&gt;...&lt;/pre&gt;</code> ein Bereich mit präformatiertem Text definiert. Darin wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> der Inhalt der Datei ausgegeben, die im Attribut <code>quelle</code> angegeben ist. Um auf die Datei zuzugreifen, wird im <code>select</code>-Attribut die <code>document()</code>-Funktion angewendet. Als Argument wird ihr die Angabe zum Attribut <code>quelle</code> übergeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="element_available">element-available() (Verfügbarkeit eines XSLT-Elements überprüfen)</a></h2>

<p>Ermittelt, ob ein XSLT-Element im verwendeten XSLT-Parser verfügbar ist oder nicht. Dient daher als Maßnahme zur Vermeidung von Fehlern.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Elementname]</code></td>
<td valign="top">Name eines XSLT-Elements, dessen Verfügbarkeit überprüft werden soll.</td>
</tr>
</table>

<p>Liefert <code>true</code> zurück, wenn das Element verfügbar ist, und <code>false</code>, wenn es nicht verfügbar ist.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:if test="element-available('xsl:number')"&gt;
   &lt;xsl:number level="single" count="eintrag" format="1. " /&gt;
 &lt;/xsl:if&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel überprüft mit Hilfe der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#if">xsl:if</a>-Anweisung, ob das XSLT-Element <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#number">xsl:number</a> verfügbar ist. Wenn ja, wird es innerhalb der <code>xsl:if</code>-Anweisung angewendet. Wenn nicht, wird zumindest ein Fehler vermieden.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Dieser Funktion ist auch dann nützlich, wenn es darum geht herauszufinden, ob der XSLT-Prozessor Hersteller-spezifische Erweiterungen kennt, z.B.:<br>
<code>&lt;xsl:when test="element-available('saxon:entity-ref')"&gt;...&lt;/xsl:when&gt;</code>.<br>
In diesem Beispiel wird abgefragt, ob der Prozessor das Element <code>entity-ref</code> kennt, das der Saxon-Prozessor interpretiert.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="false">false() (booleschen Wert für "falsch" erzeugen)</a></h2>

<p>Verneint einen Ausdruck.</p>

<p>Erwartet keine Argumente</p>

<p>Liefert einfach den logischen Wert <code>false</code> zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:variable name="passwortanzeige" select="false()"/&gt;

&lt;xsl:template name="passwort"&gt;
 &lt;xsl:choose&gt;
  &lt;xsl:when test="$passwortanzeige"&gt;
    &lt;xsl:value-of select="." /&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
   &lt;xsl:text&gt;[Passwort]&lt;/xsl:text&gt;
  &lt;/xsl:otherwise&gt;
 &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#variable">xsl:variable</a> eine Variable namens <code>passwortanzeige</code> definiert, deren Wert auf den logischen Wert <code>false</code> gesetzt wird. Verantwortlich dafür ist der Einsatz der Funktion <code>false()</code>, die einfach dem <code>select</code>-Attribut zugewiesen wird und dadurch für das Setzen des Wertes sorgt. Weiterhin zeigt das Beispiel eine Template-Definition für ein Element namens <code>passwort</code>. Innerhalb dieser Template-Definition wird in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#choose">xsl:choose</a>-Konstruktion abgefragt, wie es mit der Passwortanzeige steht. Wenn die Variable <code>$passwortanzeige</code> wahr ist, wird mit <code>&lt;xsl:value-of select="."&nbsp;/&gt;</code> der Wert des <code>passwort</code>-Elements ausgegeben. Andernfalls wird nur die Zeichenkette <code>[Passwort]</code> ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="floor">floor() (Zahl abrunden)</a></h2>

<p>Rundet eine Bruchzahl zur basierenden Ganzzahl ab. Die Zahl <code>5.7234</code> wird auf <code>5</code> abgerundet, und <code>5.99997</code> wird auch zu <code>5</code> abgerundet. Wichtig ist, dass "Kommazahlen" den Punkt als Dezimalzeichen haben. Andernfalls werden sie als ungültige Zahlen (<code>NaN</code> - <i>not a number</i>) interpretiert.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zahl]</code></td>
<td valign="top">Die abzurundende Zahl. Es kann sich auch um den Inhalt eines Knotens oder den Wert einer Variablen handeln. Dabei wird der Wert intern zunächst als Zahl umgewandelt, und zwar so, als würde die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#number">number()</a> angewendet.</td>
</tr>
</table>

<p>Liefert die basierende Ganzzahl zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="zahl"&gt;
 &lt;div style="background-color:yellow"&gt;&lt;xsl:value-of select="floor(./@wert)" /&gt;&lt;/div&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel nimmt ein XML-Element namens <code>zahl</code> an, das z.B. folgende Ausprägung haben könnte: <code>&lt;zahl wert="63,47"&nbsp;/&gt;</code>. In der Template-Definition zur HTML-Ausgabe dieses Elements wird auf das Attribut mit <code>@wert</code> zugegriffen. Dabei wird dieser Attributzugriff jedoch in die Funktion <code>floor()</code> eingebettet, sodass im Falle einer Zahl mit dem Wert <code>63,47</code> nur <code>63</code> in der HTML-Ausgabe erscheint.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="format_number">format-number() (Zahl in Zeichenkette umwandeln)</a></h2>

<p>Wandelt eine Zahl in eine Zeichenkette um und erlaubt es, die Formatierung der umgewandelten Zahl zu beeinflussen.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zahl]</code></td>
<td valign="top">Der umzuwandelnde Wert. Es kann sich auch um den Inhalt eines Elements oder den Wert einer Variablen handeln. Dabei wird der Wert intern zunächst als Zahl umgewandelt, und zwar so, als würde die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#number">number()</a> angewendet.</td>
</tr>
<tr>
<td valign="top"><code>[Formatregel]</code></td>
<td valign="top">Eine Darstellungs-Syntax für die Formatierung der umgewandelten Zahl. Die Syntax der Formatregel orientiert sich dabei an dem Schema, das in Java 1.1 für die <code>decimal_format</code>-Klasse implementiert ist. Allerdings gibt es keine zwingende Korrelation zwischen der XPath-Syntax und der Java-Implementierung. Folgende Zeichen sind üblich:<br>
<code>0</code> = eine Ziffer<br>
<code>#</code> = eine Ziffer, <code>0</code> wird jedoch nicht angezeigt<br>
<code>.</code> = Platzhalter für Dezimalpunkt-Trennzeichen<br>
<code>,</code> = Platzhalter für ein Gruppierungs-Trennzeichen, z.B. für Tausender<br>
<code>;</code> = zum Trennen von mehreren Formaten<br>
<code>-</code> = negatives Vorzeichen als Voreinstellung<br>
<code>%</code> = Wert mit 100 multiplizieren und als Prozentwert anzeigen<br>
<code>?</code> = Wert mit 1000 multiplizieren und als Promillewert anzeigen<br>
<code>¤</code> = Währungssymbol, wird durch das voreingestellte Währungssymbol ersetzt (noch nicht in Java 1.1!).<br>
<code>'</code> = zum Maskieren von format-bedeutenden Zeichen wie <code>0</code>, <code>#</code>, <code>.</code> usw.
</td>
</tr>
<tr>
<td valign="top"><code>[Name]</code></td>
<td valign="top"><i>(optional)</i> Name eines Formats, das mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#decimal_format">xsl:decimal-format</a> definiert wird.</td>
</tr>
</table>

<p>Liefert eine Zeichenkette mit der formatierten Zahl zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="wert"&gt;
 &lt;xsl:value-of select="format-number(.,'##0.0%')" /&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel nimmt ein XML-Element namens <code>wert</code> an, für dessen Ausgabe in den HTML-Ergebnisbaum ein Template definiert wird. Dabei wird der Inhalt des Elements <code>wert</code>, angesprochen durch die Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#current">current()</a> als erstes Argument der Funktion <code>format-number()</code> übergeben. Für die Formatierung wird bestimmt, dass es eine bis zu dreistellige Zahl mit einer Nachkommastelle sein kann, die als Prozentwert ausgegeben wird. Durch die Zuweisung dieses Konstrukts an das <code>select</code>-Attribut von <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> wird bewirkt, dass der Inhalt von <code>wert</code> entsprechend der Formatregel ausgegeben wird.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="function_available">function-available() (Verfügbarkeit einer XPath-Funktion überprüfen)</a></h2>

<p>Ermittelt, ob eine XPath-Funktion im verwendeten XSLT-Parser verfügbar ist oder nicht. Dient daher als Maßnahme zur Vermeidung von Fehlern.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Funktionsname]</code></td>
<td valign="top">Name einer XPath-Funktion, deren Verfügbarkeit überprüft werden soll.</td>
</tr>
</table>

<p>Liefert <code>true</code> zurück, wenn die Funktion verfügbar ist, und <code>false</code>, wenn sie nicht verfügbar ist.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:choose&gt;
  &lt;xsl:when test="function-available('normalize-space')"&gt;
    &lt;xsl:value-of select="normalize-space(.)" /&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
   &lt;xsl:value-of select="." /&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel überprüft mit Hilfe einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#choose">xsl:choose</a>-Konstruktion, ob die XPath-Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#normalize_space">normalize-space()</a> verfügbar ist. Wenn ja, wird sie innerhalb der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung angewendet, um bei der Ausgabe des aktuellen Elements, das mit <code>.</code> angegeben wird, alle überflüssigen Leerraumzeichen am Anfang und am Ende zu entfernen. Andernfalls, wenn die Funktion nicht verfügbar ist, wird der Inhalt des aktuellen Elements ohne weitere Vorbehandlung ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="generate_id">generate-id() (eindeutigen Bezeichner für ein Element generieren)</a></h2>

<p>Erzeugt im Ergebnisbaum automatisch einen eindeutigen Bezeichner. Der Bezeichner muss nicht bei jedem Generierungsvorgang der gleiche sein (könnte also zum Beispiel durch zeitabhängige Algorithmen erzeugt sein), aber er ist in jedem Fall innerhalb des einzelnen Dokuments eindeutig. Der generierte Bezeichner entspricht in jedem Fall den Konventionen für Bezeichner in XML.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top"><i>(optional)</i> Knoten-Set bzw. einen Pfad nach <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>, der eine ID erhalten soll.</td>
</tr>
</table>

<p>Liefert eine Zeichenkette mit dem generierten Bezeichner zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="absatz"&gt;
&lt;p&gt;&lt;a name="{generate-id(.)}"&gt;
 &lt;xsl:value-of select="." /&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein häufiger vorkommendes XML-Element namens <code>absatz</code>. Jedes dieser Elemente erhält bei der Übersetzung in ein HTML-Konstrukt einen Anker, definiert mit <code>&lt;a&nbsp;name=&gt;...&lt;/a&gt;</code>. Der Wert, der jeweils beim Attribut <code>name</code> vergeben wird, wird automatisch erzeugt, und zwar durch Anwendung der Funktion <code>generate-id()</code>. Als Argument wird das aktuelle Element (<code>.</code>) übergeben. Wichtig sind die geschweiften Klammern, in denen die Funktion bei der Wertzuweisung an <code>name</code> zusätzlich steht. Dies ist nötig, weil die Funktion in diesem Beispiel nicht in der Wertzuweisung an ein Attribut einer XSLT-Anweisung steht, sondern in einer Wertzuweisung an ein Attribut eines Elements des Ergebnisbaums - im Beispiel an das <code>name</code>-Attribut des <code>a</code>-Elements der Ergebnissprache HTML.</p>

<h3 class="inf">Beachten Sie:</h3>

<p><code>generate-id()</code> kann man auch dazu verwenden, um herauszufinden, ob Knoten identisch sind. Beispiel:<br>
<code>&lt;xsl:if test="a = b"&gt;</code> prüft nur, ob a und b den gleichen Inhalt haben.<br>
<code>&lt;xsl:if test="generate-id(a) = generate-id(b)"&gt;</code> prüft dagegen, ob es wahr ist, dass beide Knoten identisch sind.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="id">id() (Element mit bestimmtem Bezeichner auswählen)</a></h2>

<p>Wählt ein Element aufgrund einer ID aus. Dazu muss das Element ein <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../dtd/attribute.htm#mit_identifikationswert">Attribut mit Identifikationswert</a> besitzen, das in der zugehörigen DTD entsprechend definiert sein muss. Da die Wertzuweisungen an solche Attribute dokumentweit eindeutig sein müssen, eignen sie sich hervorragend, um das Element auszuwählen.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[ID-Wert]</code></td>
<td valign="top">Der ID-Wert desjenigen Elements, das ausgewählt werden soll.</td>
</tr>
</table>

<p>Liefert das Element oder mehrere Elemente zurück, deren ID-Wert ausgewählt wurde.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="name"&gt;
&lt;li&gt;&lt;xsl:value-of select="id('p01')" /&gt;&lt;xsl:value-of select="." /&gt;&lt;/li&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein Element namens <code>name</code>. Darin wird in einem HTML Aufzählungspunkt ein fixes Label (denkbar wäre z.B. ein Wert wie <code>Name, Vorname: </code>) und dahinter der aktuelle Wert des Elements <code>name</code> mit <code>&lt;xsl:value-of select="."&nbsp;/&gt;</code> ausgegeben. Der Wert des Labels wird ebenfalls mit einer <code>xsl:value-of</code>-Anweisung ermittelt. Dabei ist im <code>select</code>-Attribut die Funktion <code>id()</code> notiert, die auf ein Element mit dem Identifikationswert <code>p01</code> zugreift. Dieses Element könnte in den XML-Daten beispielsweise so notiert sein:<br> <code>&lt;prefix&nbsp;x="p01"&gt;Name,&nbsp;Vorname: &lt;/prefix&gt;</code><br>
Dabei wäre das Attribut <code>x</code> in der zugehörigen DTD als Attribut mit Identifikationswert definiert.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="key">key() (Elemente mit Hilfe eines Schlüsselwerts auswählen)</a></h2>

<p>Wählt einen Knoten aus, der für einen benannten Schlüssel einen bestimmten Wert besitzt. Sinnvoll, um etwa von allen Elementen nur solche auszuwählen, die aufgrund von Inhalt oder Wertzuweisungen an Attribute bestimmte Kriterien erfüllen.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Name]</code></td>
<td valign="top">Name eines Schlüssels. Der Schlüssel selbst muss zuvor mit Hilfe der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#key">xsl:key</a>-Anweisung definiert worden sein und im <code>name</code>-Attribut der Anweisung den hier angegebenen Namen erhalten haben.</td>
</tr>
<tr>
<td valign="top"><code>[Wert]</code></td>
<td valign="top">Der Wert, der zur Eingrenzung auszuwählender Elemente dient. Nur Elemente, die dem Schlüssel entsprechen und dabei diesen Wert besitzen, werden ausgewählt.</td>
</tr>
</table>

<p>Liefert das erste Element zurück, das den Auswahlkriterien entspricht.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:key name="k3" match="datensatz" use="handelsklasse" /&gt;

&lt;xsl:template match="/"&gt;
 &lt;html&gt;&lt;head&gt;&lt;body&gt;
  &lt;xsl:for-each select="key('k3','III')"&gt;
    &lt;xsl:apply-templates /&gt;
  &lt;/xsl:for-each&gt;
 &lt;/body&gt;&lt;/html&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird mit Hilfe der <code>xsl:key</code>-Anweisung für ein Element namens <code>datensatz</code> ein Schlüssel definiert, der den Namen <code>k3</code> erhält und sich auf den Inhalt eines zu <code>datensatz</code> untergeordneten Elements namens <code>handelsklasse</code> bezieht. Es wird angenommen, dass die XML-Daten unterhalb ihres Wurzelelements aus vielen Elementen vom Typ <code>datensatz</code> bestehen. Durch Anwendung der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#for_each">xsl:for-each</a>-Anweisung in Verbindung mit der Funktion <code>key()</code> im <code>select</code>-Attribut werden nur solche Datensätze ausgewählt, die im untergeordneten Element <code>handelsklasse</code> den Wert <code>III</code> enthalten. Für diesen Fall werden mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#apply_templates">xsl:apply-templates</a> untergeordnete Template-Definitionen aufgerufen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="lang">lang() (Element auf bestimmten Sprachcode überprüfen)</a></h2>

<p>Überprüft, ob ein Element einen bestimmten Sprachcode verwendet. Voraussetzung ist, dass in dem Element das XML-Attribut <code>xml:lang</code> notiert ist, also beispielsweise:<br>
<code>&lt;description xml:lang="de"&gt;</code>die Beschreibung zu irgendetwas<code>&lt;/description&gt;</code><br>
In der DTD wäre folgende zugehörige Definition erforderlich:<br>
<code>&lt;!ATTLIST description&nbsp;&nbsp;xml:lang  NMTOKEN  #IMPLIED&gt;</code><br>
Die Angaben zum Attribut <code>xml:lang</code> können <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../diverses/sprachenlaenderkuerzel.htm">Sprachenkürzel</a> sein.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">für den Ländercode, auf den hin überprüft werden soll (z.B. <code>de</code>).</td>
</tr>
</table>

<p>Liefert <code>true</code> zurück, wenn das Element diesen Ländercode in seinem <code>xml:lang</code>-Attribut angibt, und <code>false</code>, wenn kein <code>xml:lang</code>-Attribut vorhanden ist, oder wenn es einen anderen als den im Argument übergebenen Wert hat.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="description"&gt;
 &lt;xsl:choose&gt;
  &lt;xsl:when test="lang('de')"&gt;
   &lt;h4&gt;&lt;xsl:text&gt;Beschreibung:&lt;/xsl:text&gt;&lt;/h4&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
   &lt;h4&gt;&lt;xsl:text&gt;Description:&lt;/xsl:text&gt;&lt;/h4&gt;
  &lt;/xsl:otherwise&gt;
  &lt;p&gt;&lt;xsl:value-of select="." /&gt;&lt;/p&gt;
 &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel sorgt dafür, dass einem Element namens <code>description</code> im HTML-Ergebnisbaum eine <code>h4</code>-Überschrift vorangestellt wird. Dabei wird mit Hilfe der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#choose">xsl:choose</a>-Anweisung im <code>when</code>-Zweig mit Hilfe der Funktion <code>lang()</code> überprüft, ob das <code>description</code>-Element <code>xml:lang="de"</code> als Attribut enthält. Wenn ja, wird als Text der <code>h4</code>-Überschrift das deutsche Wort <code>Beschreibung</code> ausgegeben, andernfalls das englische Wort <code>Description</code>. Am Ende wird dann noch mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> der Inhalt des <code>description</code>-Elements ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="last">last() (Positionsnummer des letzten Knotens einer Reihe ermitteln)</a></h2>

<p>Ermittelt die Positionsnummer des letzten von mehreren Knoten eines Knoten-Sets.</p>

<p>Erwartet keine Argumente.</p>

<p>Liefert die Positionsnummer des letzten Knotens zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="zahl"&gt;
 &lt;xsl:value-of select="." /&gt;
 &lt;xsl:if test="position() != last()"&gt;
  &lt;xsl:text&gt;, &lt;/xsl:text&gt;
 &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein Element namens <code>zahl</code>. Im Beispiel wird angenommen, dass mehrere solcher Elemente nacheinander innerhalb eines gemeinsamen übergeordneten Elements notiert sind, also beispielsweise die einzelnen Zahlen innerhalb einer Lottozahlenreihe. Bei jeder Anwendung des Templates wird zunächst mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> die aktuelle Zahl ausgegeben. Danach soll hinter allen außer der letzten Zahl ein Komma ausgegeben werden, sodass eine Ausgabe wie z.B. <code>3,15,28,29,33,43</code> entsteht. Dazu wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#if">xsl:if</a> abgefragt, ob die Positionsnummer des aktuellen Elements innerhalb der Reihe (ermittelt mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#position">position()</a>) ungleich (<code>!=</code>) der Positionsnummer des letzten Elements (ermittelt mit der <code>last()</code>-Funktion) ist. Ist dies der Fall, wird ein Komma ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="local_name">local-name() (lokalen Namen eines Knoten-Sets ermitteln)</a></h2>

<p>Ermittelt aus einem Knotennamen mit Namensraumangabe den lokalen Namensteil - aus einem Elementnamen wie <code>xhtml:blockquote</code> würde also <code>blockquote</code> ermittelt.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top"><i>(optional)</i> Ein Knoten-Set bzw. einen Pfad nach <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>, dessen lokaler Name ermittelt werden soll. Fehlt die Angabe des Arguments, wird die Funktion auf das jeweils aktuelle Element angewendet.</td>
</tr>
</table>

<p>Liefert den lokalen Elementnamen zurück, sofern der Elementname aus einer Namensraumangabe und dem lokalen Elementnamen besteht. Ansonsten wird eine leere Zeichenkette zurückgeliefert.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="autor:*"&gt;
 &lt;div&gt;
  &lt;p&gt;Name des Knotens: &lt;b&gt;&lt;xsl:value-of select="name(.)" /&gt;&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;local-name:&lt;b&gt;&lt;xsl:value-of select="local-name(.)" /&gt;&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;Inhalt:&lt;b&gt;&lt;xsl:apply-templates /&gt;&lt;/b&gt;&lt;/p&gt;
 &lt;/div&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Der Beispielausschnitt zeigt eine Template-Definition für angenommene Elemente, die aus dem Namensraum <code>autor</code> stammen. In XML wären das beispielsweise Elemente, die in der Form <code>&lt;autor:vorname&gt;...&lt;/autor:vorname&gt;</code> notiert sind. Das Template ermittelt mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#name">name(.)</a> den vollständigen Namen des aktuellen Knotens, also z.B. <code>autor:vorname</code>, und mit <code>local-name(.)</code> den lokalen Namensteil, also z.B. <code>vorname</code>. Anschließend werden mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#apply_templates">xsl:apply-templates</a> untergeordnete Template-Definitionen angewendet.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="name">name() (Namen eines Knoten-Sets ermitteln)</a></h2>

<p>Ermittelt den vollständigen Namen eines Knoten-Sets, gegebenenfalls auch mit XML-Namensraumangabe.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top"><i>(optional)</i> Ein Knoten-Set bzw. einen Pfad nach <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>, dessen vollständiger Name ermittelt werden soll. Fehlt die Angabe des Arguments, wird die Funktion auf das jeweils aktuelle Element angewendet.</td>
</tr>
</table>

<p>Liefert den Namen des ausgewählten Knoten-Sets zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template name="Kurzbeschreibung"&gt;
 &lt;b&gt;&lt;xsl:value-of select="name()" /&gt;&lt;xsl:text&gt;: &lt;/xsl:text&gt;&lt;/b&gt;&lt;xsl:value-of select="." /&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>Kurzbeschreibung</code>. Darin wird definiert, dass zuerst der Name des Elements ausgegeben wird, also <code>Kurzbeschreibung</code>, dann ein Doppelpunkt, und dann der Inhalt des Elements. Die Ausgabe des Elementnamens wird erreicht durch die <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung, die im <code>select</code>-Attribut als Wert die Funktion <code>name()</code> zugewiesen bekommt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="namespace_uri">namespace-uri() (Namensraum eines Elements ermitteln)</a></h2>

<p>Ermittelt den URI für die DTD zum verwendeten XML-Namensraum. Es handelt sich normalerweise um jene Angaben, die bei der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#stylesheet">xsl:stylesheet</a>-Anweisung im <code>xmlns:</code>-Attribut gemacht wurden. Voraussetzung dafür, dass ein Wert zurückgeliefert wird, ist, dass ein Element eine Namensraumangabe verwendet, also z.B. <code>xsl:template</code> oder <code>xhtml:div</code>.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top"><i>(optional)</i> Ein Knoten-Set bzw. einen Pfad nach <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>, dessen URI der DTD für den XSL-Namensraum ermittelt werden soll. Fehlt die Angabe des Arguments, wird die Funktion auf das jeweils aktuelle Element angewendet.</td>
</tr>
</table>

<p>Liefert den URI zurück, die für den zugehörigen Namensraum des Elements zurückgegeben wurde.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
 &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
  &lt;b&gt;&lt;xsl:text&gt;XSL-URI dieses Stylesheets: &lt;/xsl:text&gt;&lt;/b&gt;
     &lt;xsl:value-of select="namespace-uri(document('')/*)" /&gt;
 &lt;/body&gt;&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt ein vollständiges XSLT-Stylesheet. Im einleitenden <code>stylesheet</code>-Tag wird wie üblich mit <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> der URI der DTD für den XSL-Namensraum angegeben. Im weiteren Verlauf des Stylesheets wird ein Template für das Wurzelelement definiert. Darin wird aber einfach nur der URI des XSL-Namensraums für dieses Stylesheet ausgegeben. Dazu wird bei der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung im <code>select</code>-Attribut als Wert die Funktion <code>namespace-uri()</code> übergeben. Die Ausgabe im Beispiel würde lauten:<br>
<b>XSL-URI dieses Stylesheets:</b> http://www.w3.org/1999/XSL/Transform</p>

<p>Im Beispiel wird der Funktion <code>namespace-uri()</code> als Argument <code>document('')/*</code> übergeben. Das ist folgendermaßen zu verstehen: es soll das Dokument-Element ermittelt werden, was am einfachsten durch die Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#document">document('')</a> (mit dem Leerstring als Parameter) bewerkstelligt wird. Mit dem daran anschließenden <code>/*</code> wird, da sich der gesamte Ausdruck innerhalb eines Aufrufs von <code>namespace-uri()</code> befindet, der Namensraum-URI für alle Elemente innerhalb dieses Dokument-Elements ermittelt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="normalize_space">normalize-space() (Leerzeichen am Anfang und Ende einer Zeichenkette entfernen)</a></h2>

<p>Entfernt am Anfang und am Ende der übergebenen Zeichenkette die Leerraumzeichen und ersetzt mehrere aufeinanderfolgende Leerraumzeichen in der Zeichenkette durch ein einziges Leerzeichen (<code>#x20</code>). Leerraumzeichen sind die Zeichen mit den Hexadezimalwerten <code>#x20</code> (einfaches Leerzeichen), <code>#x9</code> (Tabulator-Zeichen), <code>#xD</code> (Wagenrücklaufzeichen) und <code>#xA</code> (Zeilenvorschub-Zeichen).</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top"><i>(optional)</i> Die Zeichenkette, die behandelt werden soll. Fehlt das Argument, wird die Funktion auf den Inhaltsknoten des aktuellen Knotens angewendet, bei einem Element <code>&lt;name&gt;...&lt;/name&gt;</code> beispielsweise auf dessen Inhalt, also das, was hier durch die drei Pünktchen markiert ist.</td>
</tr>
</table>

<p>Liefert die behandelte Zeichenkette wieder zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="augenfarbe"&gt;
  &lt;tr&gt;
  &lt;td&gt;&lt;xsl:text&gt;Augenfarbe&lt;/xsl:text&gt;&lt;/td&gt;
  &lt;td&gt;&lt;xsl:value-of select="normalize-space()" /&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>augenfarbe</code>. Darin wird eine HTML-Tabellenzeile konstruiert. In der ersten Spalte steht der fixe Text <code>Augenfarbe</code>, und in der zweiten Spalte wird der Wert des Elements ausgegeben. Dabei werden jedoch zuvor führende und abschließende Leerraumzeichen, die z.B. durch unachtsames Editieren oder Behandlung durch andere Programme entstanden sein könnten, entfernt. Um das zu erreichen, wird nicht einfach <code>&lt;xsl:value-of&nbsp;select="."&nbsp;/&gt;</code> notiert, sondern <code>&lt;xsl:value-of&nbsp;select="normalize-space()"&nbsp;/&gt;</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="not">not() (Argument verneinen)</a></h2>

<p>Verneint das übergebene Argument und liefert dessen gegenteiliges Ergebnis zurück.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Bedingung]</code></td>
<td valign="top">Es kann sich um eine Vergleichsoperation handeln, aber auch um eine andere Funktion, die als Rückgabewert entweder <code>true</code> oder <code>false</code> liefert.</td>
</tr>
</table>

<p>Liefert <code>true</code> zurück, wenn die als Argument übergebene Bedingung <code>false</code> ergibt, und <code>false</code>, wenn die Bedingung <code>true</code> ergibt.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="geburtsjahr"&gt;
 &lt;xsl:if test="not(. &amp;gt; '1980')"&gt;
  &lt;xsl:value-of select="." /&gt;
 &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt die Template-Definition eines XML-Elements namens <code>geburtsjahr</code>. Das Geburtsjahr soll nur dann ausgegeben werden, wenn der aktuelle Wert nicht größer ist als 1980. Dazu wird mit Hilfe der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#if">xsl:if</a>-Anweisung eine Bedingung formuliert. Im <code>test</code>-Attribut, das die Bedingung enthält, wird mit <code>.&nbsp;&amp;gt;&nbsp;'1980'</code> die Bedingung "aktueller Wert größer 1980" formuliert. Der gesamte Ausdruck wird jedoch der Funktion <code>not()</code> als Argument übergeben, sodass die Bedingung umgekehrt wird und lautet: "aktueller Wert nicht größer 1980". Dies ist übrigens das gleiche, wie wenn als Bedingung notiert würde: <code>&lt;xsl:if&nbsp;test=".&nbsp;&amp;lt;='1980')"&gt;</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="number">number() (Argument in eine Zahl umwandeln)</a></h2>

<p>Versucht, eine übergebene Zeichenkette als Zahl zu interpretieren und gibt die ermittelte Zahl zurück. Wenn beispielsweise <code>"31"</code> übergeben wird, wird <code>31</code> zurückgeliefert. Wird <code>"xyz"</code> übergeben, wird <code>NaN</code> (not a number) zurückgeliefert. Bei Übergabe von <code>"3xy"</code> wird <code>3</code> zurückgeliefert. Und bei Übergabe von booleschen Werten, also <code>true</code> oder <code>false</code>, wird <code>0</code> für <code>false</code> und <code>1</code> für <code>true</code> zurückgeliefert. Führende und abschließende Leerraumzeichen der übergebenen Zeichenkette werden ignoriert.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette bzw. Wert]</code></td>
<td valign="top"><i>(optional)</i> Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln, oder um den Rückgabewert einer anderen Funktion. Fehlt das Argument, wird die Funktion auf den aktuellen Knoteninhalt angewendet, z.B. auf den Inhalt eines Elements.</td>
</tr>
</table>

<p>Liefert die ermittelte Zahl zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="preis"&gt;
 &lt;xsl:value-of select="number()" /&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>preis</code>. Das Template gibt den Wert des Elements aus, jedoch wird dabei versucht, den Wert numerisch zu interpretieren. Dazu wird im <code>select</code>-Attribut der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung die Funktion <code>number()</code> angewendet. Da <code>number()</code> kein Argument übergeben wird, bezieht sich die Funktion auf den Wert des aktuellen Elements <code>preis</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="position">position() (Positionsnummer des aktuellen Knotens ermitteln)</a></h2>

<p>Ermittelt, der wievielte Knoten ein aktueller Knoten in einem Knoten-Set ist. Bei einem Element namens <code>liste</code> mit beispielsweise 7 untergeordneten Elementen namens <code>listeneintrag</code> hat das zweite dieser Elemente in Bezug auf <code>liste</code> die Positionsnummer 2.</p>

<p>Erwartet keine Argumente.</p>

<p>Liefert die Ordnungszahl des aktuellen Knotens zurück. Beim ersten Knoten 1, beim zweiten 2 usw.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:variable name="anzahl" select="count(//listeneintrag)" /&gt;
...
&lt;xsl:template match="liste"&gt;
  &lt;xsl:for-each select="listeneintrag"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="position()" /&gt;
    &lt;xsl:text&gt;. von &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$anzahl" /&gt;
    &lt;xsl:text&gt;: &lt;/xsl:text&gt;
    &lt;xsl:value-of select="." /&gt;
  &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel nimmt an, dass es ein XML-Element namens <code>liste</code> gibt, das aus mehreren Unterelementen <code>listeneintrag</code> besteht. Zunächst wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#variable">xsl:variable</a> eine Variable namens <code>anzahl</code> definiert, in der die Anzahl der Listeneinträge gespeichert wird. Dazu wird im <code>select</code>-Attribut die Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#count">count()</a> angewendet. Als Argument wird ihr das Element <code>listeneintrag</code> übergeben. In der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#for_each">for-each</a>-Schleife, die alle Listeneinträge abarbeitet, wird vor dem Text des Listeneintrags jeweils die aktuelle Positionsnummer mit <code>position()</code> ausgegeben, und dahinter die Gesamtzahl, die in der Variablen <code>anzahl</code> gespeichert ist, also etwa so:<br>
<code>1. von 5: Text des ersten Listeneintrags<br>
2. von 5: Text des zweiten Listeneintrags</code></p>

<h3 class="inf">Beachten Sie:</h3>

<p><code>&lt;xsl:value-of select="listeneintrag[position()=1]" /&gt;</code> kann auch so notiert werden:<br>
<code>&lt;xsl:value-of select="listeneintrag[1]" /&gt;</code></p>

<p><code>&lt;xsl:value-of select="listeneintrag[position()=last()]" /&gt;</code> kann auch so notiert werden:<br>
<code>&lt;xsl:value-of select="listeneintrag[last()]" /&gt;</code></p>

<p><code>&lt;xsl:if test="position()=1"&gt;</code> ist etwas anderes als <code>&lt;xsl:if test="1"&gt;</code>! Im ersten Fall wird geprüft, ob der aktuell bearbeitete Knoten der erste ist, im zweiten Fall wird geprüft, ob der aktuelle Kontext logisch gesehen wahr ist.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="round">round() (kaufmännisch auf- oder abrunden)</a></h2>

<p>Rundet eine Bruchzahl zur nächstgelegenen Ganzzahl auf. Bei Bruchwerten kleiner als <code>[Wert],5</code> wird abgerundet, bei Bruchwerten größer gleich <code>[Wert],5</code> aufgerundet. Die Zahl <code>5,49</code> wird also auf <code>5</code> abgerundet, und <code>5,5</code> auf <code>6</code> aufgerundet.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zahl]</code></td>
<td valign="top">Die zu rundende Zahl. Es kann sich auch um den Inhalt eines Knotens oder den einer Variablen handeln. Dabei wird der Wert intern zunächst als Zahl umgewandelt, und zwar so, als würde die Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#number">number()</a> angewendet.</td>
</tr>
</table>

<p>Liefert die Ganzzahl zurück, auf die auf- oder abgerundet wurde.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:value-of select="round(betrag)" /&gt;&lt;xsl:text &gt;.-&lt;/xsl:text&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird von einem XML-Element namens <code>betrag</code> angenommen, dass es einen "krummen" Wert enthält, der kaufmännisch gerundet werden soll. Dazu wird beim Auswählen des Inhalts von <code>betrag</code> mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a> im <code>select</code>-Attribut die Funktion <code>round()</code> aufgerufen. Sie bewirkt, dass der Elementinhalt aufgerundet wird, bevor er in den Ergebnisbaum der Datenausgabe übernommen wird.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="starts_with">starts-with() (Überprüfen, ob Zeichenkette mit bestimmter Teilzeichenkette beginnt)</a></h2>

<p>Findet heraus, ob am Beginn einer Zeichenkette eine bestimmte Teilzeichenkette vorkommt.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">Zeichenkette, die durchsucht werden soll. Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln.</td>
</tr>
<tr>
<td valign="top"><code>[Teilzeichenkette]</code></td>
<td valign="top">Diejenige Zeichenfolge, nach der am Beginn der durchsuchten Zeichenkette gesucht wird. Es kann sich direkt um Text handeln, aber auch um den Inhalt eines Knotens oder den Wert einer Variablen.</td>
</tr>
</table>

<p>Liefert <code>true</code> zurück, wenn die Zeichenkette mit der Teilzeichenkette beginnt, und <code>false</code>, wenn sie nicht damit beginnt.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="mitarbeitername"&gt;
&lt;p&gt;
 &lt;xsl:if test="starts-with(.,'Frau')"&gt;
  &lt;b&gt;&lt;xsl:value-of select="." /&gt;&lt;/b&gt;
 &lt;/xsl:if&gt;
  &lt;xsl:if test="starts-with(.,'Herr')"&gt;
  &lt;i&gt;&lt;xsl:value-of select="." /&gt;&lt;/i&gt;
 &lt;/xsl:if&gt;
&lt;/p&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird für ein XML-Element namens <code>mitarbeitername</code> ein Template definiert. Dabei wird mit  <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#if">xsl:if</a> abgefragt, ob der Elementinhalt mit <code>Frau</code> oder mit <code>Herr</code> beginnt. Im Fall "Frau" wird der Name in Fettschrift in den HTML-Ergebnisbaum geschrieben. Einträge, die mit <code>Herr</code> beginnen, werden dagegen in Kursivschrift geschrieben. Die <code>xsl:if</code>-Abfrage benutzt dazu die Funktion <code>starts-with()</code>. Als Parameter werden der Funktion der Inhalt des aktuellen Knotens (<code>.</code>) übergeben, sowie die Suchzeichenfolge <code>Frau</code> bzw. <code>Herr</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="string">string() (Argument in Zeichenkette umwandeln)</a></h2>

<p>Interpretiert ein übergebenes Argument als Zeichenkette und gibt die ermittelte Zeichenkette zurück. Wenn beispielsweise <code>31</code> übergeben wird, wird <code>"31"</code> zurückgeliefert. Negative Zahlen erhalten ein vorangestelltes Minuszeichen, Bruchzahlen einen Dezimalpunkt. Bei Übergabe von booleschen Werten, also <code>true</code> oder <code>false</code>, wird <code>"true"</code> bzw. <code>"false"</code> als Zeichenkette zurückgeliefert.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Argument]</code></td>
<td valign="top"><i>(optional)</i> Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln, oder um den Rückgabewert einer anderen Funktion. Fehlt das Argument, wird die Funktion auf den aktuellen Knoteninhalt angewendet, z.B. auf den Inhalt eines Elements.</td>
</tr>
</table>

<p>Liefert die ermittelte Zeichenkette zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="spannung"&gt;
 &lt;xsl:value-of select="string()" /&gt;&lt;b&gt;&lt;xsl:text&gt; Volt&lt;/xsl:text&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>spannung</code>. Das Template gibt den Wert des Elements aus, jedoch wird dabei der numerische Inhalt in eine Zeichenkette umgewandelt. Dazu wird im <code>select</code>-Attribut der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung die Funktion <code>string()</code> angewendet. Da <code>string()</code> kein Argument übergeben wird, bezieht sich die Funktion auf den Wert des aktuellen Elements <code>spannung</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="string_length">string-length() (Anzahl Zeichen einer Zeichenkette ermitteln)</a></h2>

<p>Ermittelt, wie lang eine Zeichenkette ist.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top"><i>(optional)</i> Zeichenkette, deren Länge ermittelt werden soll. Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln. Falls das Argument keine Zeichenkette ist, sondern beispielsweise eine Zahl, wird es zunächst intern mit der <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#string">string()</a>-Funktion in eine Zeichenkette umgewandelt. Fehlt das Argument, wird die Funktion auf den aktuellen Knoteninhalt angewendet, z.B. auf den Inhalt eines Elements.</td>
</tr>
</table>

<p>Liefert die Anzahl der Zeichen zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="mitteilungstext"&gt;
  &lt;xsl:choose&gt;
   &lt;xsl:when test="string-length() &amp;lt; 20"&gt;
    &lt;p&gt;&lt;b&gt;Fehler: zu geringe Mitteilungsmenge!&lt;/b&gt;&lt;/p&gt;
   &lt;/xsl:when&gt;
   &lt;xsl:otherwise&gt;
    &lt;p&gt;&lt;xsl:value-of select="." /&gt;&lt;/p&gt;
   &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>mitteilungstext</code>. Der Inhalt dieses Elements soll nur dann in den Ergebnisbaum übernommen werden, wenn er mindestens 20 Zeichen besitzt. Dazu wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#choose">xsl:choose</a> eine logische Verzweigung realisiert. Im <code>xsl:when</code>-Zweig wird abgefragt, ob der Elementinhalt kleiner als 20 Zeichen ist. Dazu wird die Funktion <code>string-length()</code> angewendet. Da kein Argument übergeben wird, bezieht sie sich automatisch auf den Inhalt des aktuellen Elements. Wenn weniger als 20 Zeichen ermittelt werden, wird eine Fehlermeldung in die Ausgabe geschrieben. Andernfalls (<code>xsl:otherwise</code>) wird der Inhalt von <code>mitteilungstext</code> in den Ergebnisbaum geschrieben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="substring">substring() (Teilzeichenkette aus Zeichenkette extrahieren)</a></h2>

<p>Extrahiert aus einer Zeichenkette einen Teil ab einer bestimmten Zeichenposition und auf Wunsch eine bestimmte Anzahl von Zeichen.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">Zeichenkette, aus der ein Teil extrahiert werden soll. Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln. Falls das Argument keine Zeichenkette ist, sondern beispielsweise eine Zahl, wird es zunächst intern mit der <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#string">string()</a>-Funktion in eine Zeichenkette umgewandelt.</td>
</tr>
<tr>
<td valign="top"><code>[Zahl]</code></td>
<td valign="top">Position innerhalb der Zeichenkette, ab der extrahiert werden soll. Wenn z.B. ab dem 1. Zeichen extrahiert werden soll, muss 1 übergeben werden, wenn ab dem 20. Zeichen extrahiert werden soll, ist 20 zu übergeben.</td>
</tr>
<tr>
<td valign="top"><code>[Zahl]</code></td>
<td valign="top"><i>(optional)</i> Anzahl der Zeichen, die extrahiert werden sollen. Fehlt dieses Argument, wird bis zum Ende der Zeichenkette extrahiert.</td>
</tr>
</table>

<p>Liefert die extrahierte Teilzeichenkette zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="ort"&gt;
&lt;tr&gt;
 &lt;td&gt;&lt;xsl:value-of select="substring(.,1,5)" /&gt;&lt;/td&gt;
 &lt;td&gt;&lt;xsl:value-of select="substring(.,7)" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>ort</code>, von dem angenommen wird, dass es Daten in der Form <code>81379&nbsp;München</code> enthält. Postleitzahl und Ortsname sollen bei der Ausgabe in den Ergebnisbaum auseinandergenommen und in zwei getrennte Tabellenzellen übernommen werden. Dazu wird dem <code>select</code>-Attribut der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung jeweils die Funktion <code>substring()</code> zugewiesen. Sie extrahiert beim ersten der beiden Aufrufe für den Inhalt des aktuellen Elements, der mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#current">current() bzw. .</a> ermittelt wird, die ersten 5 Zeichen, also die Postleitzahl, und beim zweiten Aufruf die Zeichen ab Position 7 bis zum Ende der Ortsangabe, also den Ortsnamen ohne die Postleitzahl.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="substring_after">substring-after() (Zeichenkette ab einer Position mit Teilzeichenkette ermitteln)</a></h2>

<p>Prüft, ob eine Zeichenkette eine bestimmte Teilzeichenkette enthält. Ist das der Fall, wird diejenige Restzeichenkette zurückgegeben, die nach dem ersten Vorkommen der Teilzeichenkette folgt. Dies ist z.B. sinnvoll, um in Daten, die aus dem Schema <code>Variablenname=zugewiesener&nbsp;Wert</code> bestehen, den Wert zu extrahieren. Analog dazu arbeitet die Funktion <code>substring-before()</code>, die aus den gleichen Daten den Variablennamen extrahieren kann.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">Zeichenkette, aus der ein Teil extrahiert werden soll. Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln. Falls das Argument keine Zeichenkette ist, sondern beispielsweise eine Zahl, wird es zunächst intern mit der <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#string">string()</a>-Funktion in eine Zeichenkette umgewandelt.</td>
</tr>
<tr>
<td valign="top"><code>[Teilzeichenkette]</code></td>
<td valign="top">Zeichenkette, die in der zuvor angegebenen Zeichenkette vorkommen soll. Es kann sich auch um ein einzelnes Zeichen handeln.</td>
</tr>
</table>

<p>Liefert die Restzeichenkette hinter der Teilzeichenkette zurück, falls die Teilzeichenkette gefunden wurde. Andernfalls wird eine leere Zeichenkette zurückgegeben. Die Gegenfunktion <code>substring-before()</code> gibt dementsprechend den Teil der Zeichenkette zurück, der vor der Teilzeichenkette steht.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="config-eintrag"&gt;
 &lt;th&gt;&lt;xsl:value-of select="substring-before(current(),'=')" /&gt;&lt;/th&gt;
 &lt;td&gt;&lt;xsl:value-of select="substring-after(current(),'=')" /&gt;&lt;/td&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel nimmt an, dass es ein XML-Element namens <code>config-eintrag</code> gibt, in dem Bezeichnungen und Werte durch ein Gleichheitszeichen getrennt sind, z.B. <code>Breite=475m</code>. In der Template-Definition für dieses Element sollen der Teil vor dem Gleichheitszeichen in eine HTML-Tabellenkopfzelle übernommen werden, und der Teil hinter dem Gleichheitszeichen in eine Tabellendatenzeile. Dazu wird im ersten Teil dem <code>select</code>-Attribut der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung zuerst die Funktion <code>substring-before()</code> zugewiesen, im zweiten Teil die Funktion <code>substring-after()</code>. In beiden Fällen wird der Inhalt des aktuellen Elements, ermittelt mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#current">current()</a>, durchsucht. Als Zeichenkette, die das Signal für die davor bzw. dahinter zu extrahierende Teilzeichenkette ist, dient das Gleichheitszeichen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="substring_before">substring-before() (Zeichenkette vor einer Position mit Teilzeichenkette ermitteln)</a></h2>

<p>Ist die Gegenfunktion zu <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#substring_after">substring-after()</a>. Beispiel siehe dort.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="sum">sum() (Summe von Zahlenwerten ermitteln)</a></h2>

<p>Ermittelt die Gesamtsumme der Zahlenwerte des Augangsknotens. Wenn Werte nicht als Zahl interpretiert werden können, wird <code>NaN</code> (<i>not a number</i>) ermittelt.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Knoten-Set]</code></td>
<td valign="top">Ein Knoten-Set, für das die Summe seiner in Zahlen interpretierten Werte ermittelt werden soll. Sinnvollerweise enthält das Knoten-Set mehrere Knoten mit Werten, die als Zahlen interpretierbar sind, und deren Summe aus irgendeinem Grund interessant ist.</td>
</tr>
</table>

<p>Liefert die Summe der ermittelten Werte zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="viereck"&gt;
&lt;p&gt;
&lt;b&gt;&lt;xsl:value-of select="name()" /&gt; Umfang:&lt;/b&gt;&lt;xsl:value-of select="sum(@*)" /&gt;cm
&lt;/p&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt eine Template-Definition für ein XML-Element namens <code>viereck</code>, das etwa so notiert sein könnte:<br>
<code>&lt;viereck links="12" rechts="12" oben="20" unten="20" /&gt;</code><br>
In der Übersetzung nach HTML wird einfach in einem Textabsatz der Umfang des Vierecks ausgegeben. Dazu wird mit <code>select="sum(@*)"</code> die Summe aller Attributwerte des <code>viereck</code>-Elements ermittelt. Bei dem zuvor notierten XML-Beispiel würde also 64 herauskommen, da dies die Summe der Attributwerte 12, 12, 20 und 20 ist. Das Argument <code>@*</code>, das im Beispiel der Funktion <code>sum()</code> übergeben wird, steht für "alle Attribute des Elements".</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="system_property">system-property() (Systemeigenschaften ermitteln)</a></h2>

<p>Ermittelt Informationen über den verwendeten XSLT-Prozessor.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">Eine Eigenschaft des XSLT-Prozessors. Folgende Angaben sollten von jedem XSLT-Prozessor unterstützt werden: <code>'xsl:version'</code> (Version des XSLT-Standards, der vom Prozessor interpretiert wird), <code>'xsl:vendor'</code> (Hersteller der Prozessor-Software) und <code>'xsl:vendor-url'</code>  (URI des Herstellers der Prozessor-Software).</td>
</tr>
</table>

<p>Liefert den ermittelten Wert zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="zusatzinfos"&gt;
 &lt;p&gt;&lt;b&gt;&lt;xsl:text&gt;XSL Version: &lt;/xsl:text&gt;&lt;/b&gt;
   &lt;xsl:value-of select="system-property('xsl:version')" /&gt;&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;&lt;xsl:text&gt;XSL Prozessor-Hersteller: &lt;/xsl:text&gt;&lt;/b&gt;
   &lt;xsl:value-of select="system-property('xsl:vendor')" /&gt;&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;&lt;xsl:text&gt;Hersteller URL-Adresse: &lt;/xsl:text&gt;&lt;/b&gt;
   &lt;xsl:value-of select="system-property('xsl:vendor-url')" /&gt;&lt;/p&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt, wie man ein XML-Element, das in den XML-Daten beispielsweise als leeres Element definiert sein könnte, als Signalgeber benutzen kann, um in einer XSLT-Transformation an die betreffende Stelle bestimmte Daten einzusetzen. Im Beispiel wird ein XML-Element namens <code>zusatzinfos</code> angenommen, das so eine Funktion hat. Denn in der Template-Definition für dieses Element wird nicht dessen Inhalt ausgegeben, sondern es werden mit der <code>system-property()</code>-Funktion diverse Eigenschaften des verwendeten XSLT-Prozessors ermittelt und in den HTML-Ergebnisbaum mit übernommen. Dazu werden jeweils den <code>select</code>-Attributen der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisungen Aufrufe von <code>system-property()</code> übergeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="translate">translate() (Suchen und Ersetzen von Zeichen in einer Zeichenkette)</a></h2>

<p>Ersetzt einzelne Zeichen in einer Zeichenkette in andere Zeichen.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Zeichenkette]</code></td>
<td valign="top">Zeichenkette, in der gesucht und ersetzt werden soll. Es kann sich z.B. um den Inhalt eines Elements oder den Wert einer Variablen handeln. Falls das Argument keine Zeichenkette ist, sondern beispielsweise eine Zahl, wird es zunächst intern mit der <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#string">string()</a>-Funktion in eine Zeichenkette umgewandelt.</td>
</tr>
<tr>
<td valign="top"><code>[Zeichen]</code></td>
<td valign="top">Ein oder mehrere Zeichen, die ersetzt werden sollen.</td>
</tr>
<tr>
<td valign="top"><code>[Zeichen]</code></td>
<td valign="top">Ein oder mehrere Zeichen, durch welche die zuvor angegebenen Zeichen ersetzt werden sollen. Mögliche Angaben sind z.B. <code>','</code> oder <code>']['</code>. Dieses Argument muss übergeben werden, kann aber auch einen leeren Inhalt haben (<code>''</code>). Dann werden die Zeichen, die im zweiten Argument genannt sind, einfach durch nichts ersetzt, also gelöscht.</td>
</tr>
</table>

<p>Liefert die behandelte Zeichenkette zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="ortsname"&gt;
 &lt;b&gt;
 &lt;xsl:value-of select="translate(current(),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')" /&gt;
 &lt;/b&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel definiert ein Template für ein XML-Element namens <code>ortsname</code>. Der Inhalt des Elements wird in den Ergebnisbaum ausgegeben, doch dabei werden alle Kleinbuchstaben in Großbuchstaben umgewandelt. Zu diesem Zweck wird dem <code>select</code>-Attribut der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#value_of">xsl:value-of</a>-Anweisung die Funktion <code>translate()</code> zugewiesen. Diese bestimmt für den Inhalt des aktuellen Elements, ermittelt mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#current">current()</a>, dass die Kleinbuchstaben von a bis z durch entsprechende Großbuchstaben ersetzt werden.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="true">true() (booleschen Wert für "wahr" erzeugen)</a></h2>

<p>Bejaht einen Ausdruck.</p>

<p>Erwartet keine Argumente</p>

<p>Liefert einfach den logischen Wert <code>true</code> zurück.</p>

<h3 class="xmp">Beispielauszug aus einem XSL-Stylesheet:</h3>

<pre>
&lt;xsl:variable name="passwortanzeige" select="true()"/&gt;

&lt;xsl:template name="passwort"&gt;
 &lt;xsl:choose&gt;
  &lt;xsl:when test="$passwortanzeige"&gt;
    &lt;xsl:value-of select="." /&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
   &lt;xsl:text&gt;[Passwort]&lt;/xsl:text&gt;
  &lt;/xsl:otherwise&gt;
 &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#variable">xsl:variable</a> eine Variable namens <code>passwortanzeige</code> definiert, deren Wert auf den logischen Wert <code>true</code> gesetzt wird. Verantwortlich dafür ist der Einsatz der Funktion <code>true()</code>, die einfach dem <code>select</code>-Attribut zugewiesen wird und dadurch für das Setzen des Wertes sorgt. Weiterhin zeigt das Beispiel eine Template-Definition für ein Element namens <code>passwort</code>. Innerhalb dieser Template-Definition wird in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xsltelemente.htm#choose">xsl:choose</a>-Konstruktion abgefragt, wie es mit der Passwortanzeige steht. Wenn die Variable <code>$passwortanzeige</code> wahr ist, wird mit <code>&lt;xsl:value-of select="."&nbsp;/&gt;</code> der Wert des <code>passwort</code>-Elements ausgegeben. Andernfalls wird nur die Zeichenkette <code>[Passwort]</code> ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><img src="../../src/xpath10.gif" width="30" height="30" alt="XPath 1.0" title="XPath 1.0">&nbsp;<a class="an" name="unparsed_entity_uri">unparsed-entity-uri() (ungeparste Einträge der DTD ermitteln)</a></h2>

<p>Erlaubt es, auf DTD-Einträge zuzugreifen, die vom Parser nicht analysiert wurden. Dies betrifft vor allem <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../dtd/entities.htm#externe">Entities für externe Ressourcen</a>.</p>

<p>Erwartet folgende Argumente:</p>

<table>
<tr>
<td valign="top"><code>[Name]</code></td>
<td valign="top">Der Name des nicht geparsten DTD-Eintrags (Entities).</td>
</tr>
</table>

<p>Liefert den URI des Entities zurück, der hinter <code>SYSTEM</code> oder <code>PUBLIC</code> angegeben ist. Die entsprechende Adresse kann dann im Ergebnisbaum an eine geeignete Stelle eingesetzt werden.</p>

<h3 class="xmp">Beispielauszug aus einer DTD:</h3>

<pre>
&lt;!ENTITY firmenlogo SYSTEM "images/logo.jpg" NDATA JPEG&gt;
</pre>

<h3 class="xmp">Beispielauszug aus einer entsprechenden XML-Datei:</h3>

<pre>
&lt;bild quelle="firmenlogo" /&gt;
</pre>

<h3 class="xmp">Beispielauszug aus einem zugehörigen XSL-Stylesheet:</h3>

<pre>
&lt;xsl:template match="bild"&gt;
 &lt;img src="{unparsed-entity-uri(@quelle)}" alt="Firmenlogo" /&gt;
&lt;/xsl:template&gt;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt eine externe Entity-Definition in einer DTD. Dort wird ein Entity namens <code>firmenlogo</code> definiert, das eine JPEG-Grafik zugewiesen bekommt. Im zweiten Teil des Beispiels wird gezeigt, wie dieses Entity in einer XML-Datei zur Anwendung gelangt. Ein XML-Element namens <code>bild</code> hat ein Attribut namens <code>quelle</code>, dem das Entity zugewiesen wird. Der dritte Teil des Beispiels schließlich zeigt eine zugehörige Definition im XSL-Stylesheet. Dort wird für das Element <code>bild</code> ein Template definiert, in dem das XML-Konstrukt in ein HTML-Konstrukt zum Anzeigen einer Grafik übersetzt wird. Dem <code>src</code>-Attribut des <code>img</code>-Elements wird dabei die Funktion <code>unparsed-entity-uri()</code> zugewiesen. Der Funktion wird als Argument das Attribut <code>@quelle</code> des <code>bild</code>-Elements übergeben. Die Funktion liefert den zugehörigen URI wie in der DTD definiert zurück, also <code>images/logo.jpg</code>.<br>
Beachten Sie die geschweiften Klammern, die erforderlich sind, wenn eine XPath-Funktion im Code des Ergebnisbaums verwendet wird. Mehr dazu im Abschnitt über <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>.</p>



<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" class="doc">
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a>
</td></tr>
<tr><td class="doc"><a href="../../javascript/intro.htm"><img src="../../src/next.gif" width="10" height="10" border="0" hspace="10" alt="weiter"></a></td>
<td width="100%"><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../javascript/intro.htm">Einführung in JavaScript und DOM</a>
</td></tr>
<tr>
<td class="doc"><a href="xpathsyntax.htm"><img src="../../src/prev.gif" width="10" height="10" border="0" hspace="10" alt="zurück"></a></td>
<td><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="xpathsyntax.htm">XPath-Syntax</a>
</td>
</tr>
<tr><td colspan="2" class="doc">&nbsp;</td>
</tr>
<tr>
<td colspan="2" class="nav"><a class="an" name="bottom"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">XML/DTDs</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Darstellung von XML-Daten</a></td>
</tr>
</table>

<p>&copy; 2007 <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../editorial/impressum.htm">Impressum</a></p>

</body>
</html>
