<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>SELFHTML: Perl / Funktionsreferenz / Funktionen für die Kontrolle des laufenden Scripts</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Welche Funktionen es in Perl gibt, um Scripts kontrolliert ablaufen zu lassen.">
<meta name="keywords"       content="SELFHTML, Perl, Funktionen, Perl-Funktionen, Script-Ablauf, Kontrolle, Fehlerbehandlung, Error-Handling, caller, defined, die, eval, exit, local, my, quotemeta, reset, return, scalar, wantarray, warn">
<meta name="author"         content="Redaktion SELFHTML, selfhtml81@selfhtml.org">
<meta name="robots"         content="noindex, nofollow">
<meta name="DC.Publisher"   content="SELFHTML e. V.">
<meta name="DC.Date"        content="2005-11-09T00:29:27+01:00">
<meta name="DC.Identifier"  content="http://de.selfhtml.org/perl/funktionen/kontrolle.htm">
<meta name="DC.Language"    content="de">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.created" content="2001-10-27T08:00+01:00">
<meta name="SELF.Pagetype"  content="page">
<link rel="alternate" type="application/atom+xml" title="SELFHTML-Weblog (Atom, gesamt)" href="http://aktuell.de.selfhtml.org/weblog/atom-feed">
<link rel="alternate" type="application/rss+xml" title="SELFHTML-Weblog (RSS, Auszüge)" href="http://aktuell.de.selfhtml.org/weblog/rss-feed">
<link rel="shortcut icon" type="image/x-icon" href="../../src/favicon.ico">
<link rel="author" title="Impressum" href="../../editorial/impressum.htm">
<link rel="contents" title="Inhaltsverzeichnis" href="../../navigation/inhalt.htm">
<link rel="index" title="Stichwortverzeichnis" href="../../navigation/stichwort.htm">
<link rel="search" title="Suche" href="../../navigation/suche/index.htm">
<link rel="help" title="Hilfe" href="../../editorial/index.htm">
<link rel="copyright" title="Urheberrecht" href="../../editorial/copyright.htm">
<link rel="top" title="SELFHTML" href="../../index.htm">
<link rel="up" title="Perl-Funktionen" href="index.htm">
<link rel="next" title="Funktionen für Datum und Uhrzeit" href="datumzeit.htm">
<link rel="prev" title="Funktionen für Berechnungen" href="berechnungen.htm">
<link rel="first" title="Funktionen für Zeichenketten" href="zeichenketten.htm">
<link rel="last" title="Funktionen für Module und Packages" href="module.htm">
</head>
<body>

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td colspan="2" class="nav"><a class="an" name="top"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Funktionen</a></td>
</tr>
<tr>
<td class="doc" width="110"><a href="../../index.htm"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></a></td>
<td class="docbot" width="100%"><h1 class="ph1">Funktionen für die Kontrolle des laufenden Scripts</h1></td>
</tr>
<tr>
<td class="doctop">
<img src="../../src/dokx.gif" width="30" height="20" vspace="6" alt="Informationsseite">
</td>
<td valign="top" nowrap="nowrap">
<p>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#allgemeines">Allgemeines zu diesen Funktionen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#caller">caller</a> - Aufrufkontext ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#defined">defined</a> - Definition einer Variablen überprüfen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#die">die</a> - Script wegen eines Fehlers abbrechen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#eval">eval</a> - Anweisungen oder Anweisungsblöcke interpretieren lassen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#exit">exit</a> - Script beenden<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#local">local</a> - Wert von Variablen lokal begrenzen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#my">my</a> - Gültigkeitsbereich von Variablen begrenzen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#quotemeta">quotemeta</a> - Alle Zeichen außer A-Z, a-z, 0-9 und _ maskieren<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#return">return</a> - aus Subroutine zurückkehren und Wert zurückgeben<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#scalar">scalar</a> - Ausdruck in skalarem Kontext bewerten<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#wantarray">wantarray</a> - Überprüfen ob Listenkontext gegeben ist<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#warn">warn</a> - Warnungen ausgeben<br>
</p>
</td>
</tr><tr><td colspan="2" class="doc">&nbsp;<a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>&nbsp;</td></tr>
</table>



<h2><a class="an" name="allgemeines">Allgemeines zu diesen Funktionen</a></h2>

<p>Die hier versammelten Funktionen dienen vor allem dazu, bestimmte Dinge für das Script festzulegen, zu kontrollieren oder den Ablauf des Scripts zu beeinflussen. So kann eine <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/subroutinen.htm">Subroutine</a> beispielsweise ermitteln, von wo aus sie aufgerufen wurde. Für eine Variable kann überprüft werden, ob sie einen Wert besitzt oder nicht. Die Gültigkeit (Lebensdauer) von Variablen kann auf bestimmte Bereiche des Scripts begrenzt werden. Scripts können in Fehlerfällen oder kritischen Situationen abgebrochen werden oder Warnungen ausgeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="caller">caller - Aufrufkontext ermitteln</a></h2>

<p>Ermittelt, von wo aus der aktuelle Programmteil aufgerufen wurde, und aus welchem Kontext heraus.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> (optional) die Rückverfolgungstiefe als Zahl. Wenn Sie mit diesem Parameter experimentieren wollen, probieren Sie zunächst, den Wert <code>1</code> zu übergeben. Höhere Werte können dazu führen, dass weniger Information ermittelt wird als erhofft.</p>

<p>Gibt wahlweise einen Skalar oder eine Liste zurück. Wenn der Rückgabewert nur in einem Skalar gespeichert wird, enthält dieser nach Aufruf der Funktion den Namen des aufrufenden <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../module/intro.htm#packages_module">Packages</a>. Welche weiteren Rückgabewerte in einer Liste gespeichert werden, zeigt das folgende Beispiel.</p>

<h3 class="xmp"><a class="an" name="beispiel1">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle1.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
my $Infos = Aufrufe_Starten();
print "$Infos\n";
print "&lt;/body&gt;&lt;/html&gt;\n";

sub Aufrufe_Starten {
  my $Info_Einfach = Aufruf_Info_Einfach();
  my $A_S = "&lt;h3&gt;Einfache Aufruf-Infos:&lt;/h3&gt;&lt;p&gt;".$Info_Einfach."&lt;/p&gt;";
  my $Info_Ausfuehrlich = Aufruf_Info_Ausfuehrlich();
  $A_S = $A_S."&lt;h3&gt;Ausführliche Aufruf-Infos:&lt;/h3&gt;&lt;p&gt;".$Info_Ausfuehrlich."&lt;/p&gt;";
  return($A_S);
}

sub Aufruf_Info_Einfach {
   (my $Package, my $Datei, my $Zeile) = caller();
   my $A_I_E = "&lt;strong&gt;Aufruf erfolgte aus Package:&lt;/strong&gt; ".$Package."&lt;br&gt;" if (defined $Package);
   $A_I_E = $A_I_E."&lt;strong&gt;Aufruf erfolgte aus Datei:&lt;/strong&gt; ".$Datei."&lt;br&gt;" if (defined $Datei);
   $A_I_E = $A_I_E."&lt;strong&gt;Aufruf erfolgte aus Programmzeile:&lt;/strong&gt; ".$Zeile if (defined $Zeile);
   return($A_I_E);
}

sub Aufruf_Info_Ausfuehrlich {
   (my $Package, my $Datei, my $Zeile, my $Subroutine, my $HasArgs, my $WantArray, my $EvalText, my $IsRequire) = caller(1);
   my $A_I_A = "&lt;strong&gt;Aufruf erfolgte aus Package:&lt;/strong&gt; ".$Package."&lt;br&gt;" if (defined $Package);
   $A_I_A = $A_I_A."&lt;strong&gt;Aufruf erfolgte aus Datei:&lt;/strong&gt; ".$Datei."&lt;br&gt;" if (defined $Datei);
   $A_I_A = $A_I_A."&lt;strong&gt;Aufruf erfolgte aus Programmzeile:&lt;/strong&gt; ".$Zeile."&lt;br&gt;" if (defined $Zeile);
   $A_I_A = $A_I_A."&lt;strong&gt;Aufruf erfolgte aus Subroutine:&lt;/strong&gt; ".$Subroutine."&lt;br&gt;" if (defined $Subroutine);
   $A_I_A = $A_I_A."&lt;strong&gt;HasArgs:&lt;/strong&gt; ".$HasArgs."&lt;br&gt;" if (defined $HasArgs);
   $A_I_A = $A_I_A."&lt;strong&gt;WantArray:&lt;/strong&gt; ".$WantArray."&lt;br&gt;" if (defined $WantArray);
   $A_I_A = $A_I_A."&lt;strong&gt;EvalText:&lt;/strong&gt; ".$EvalText."&lt;br&gt;" if (defined $EvalText);
   $A_I_A = $A_I_A."&lt;strong&gt;IsRequire:&lt;/strong&gt; ".$IsRequire."&lt;br&gt;" if (defined $IsRequire);
   return($A_I_A);
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel gibt HTML-Code aus. Während der HTML-Ausgabe wird die Subroutine <code>Aufrufe_Starten()</code> aufgerufen. Der Rückgabewert des Aufrufs wird in dem Skalar <code>$Infos</code> gespeichert und anschließend ausgegeben.<br>
Die Subroutine <code>Aufrufe_Starten()</code> ruft ihrerseits wieder die Subroutinen <code>Aufruf_Info_Einfach()</code> und <code>Aufruf_Info_Ausfuehrlich()</code> auf. Aus den Rückgabewerten dieser beiden Routinen wird eine Zeichenkette namens <code>$A_S</code> zusammengesetzt und zurückgegeben.<br>
In <code>Aufruf_Info_Einfach</code> steht die einfache Variante eines typischen Aufrufs von <code>caller</code>. Dabei werden drei Listenelemente als Rückgabewert erwartet: der Name des aufrufenden Packages, der aufrufenden Perl-Datei, und die Nummer der Programmzeile, in der der Aufruf erfolgte.<br>
Die Subroutine <code>Aufruf_Info_Ausfuehrlich</code> zeigt dagegen den erweiterten Aufruf von <code>caller</code>. Dabei werden acht Listenelemente als Rückgabewerte erwartet. Neben den drei Elementen der einfachen Variante sind das der Name der aufrufenden Subroutine und folgende Zusatzinformationen:<br>
<code>$HasArgs</code> ist 1, wenn beim Aufruf Argumente übergeben wurden (dazu zählt auch eine leere Liste), ansonsten 0.<br>
<code>$WantArray</code> speichert, ob die Funktion im Listenkontext aufgerufen wurde.<br>
<code>$EvalText</code> speichert einen Inhalt, wenn der Aufruf aus einer <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#eval">eval()</a>-Bewertung heraus erfolgt (jedoch nicht unbedingt bei Blockbewertungen mit <code>eval{...}</code>).<br>
<code>$IsRequire</code> speichert <code>1</code> als Inhalt, wenn der Aufruf aus <code>eval</code> heraus erfolgte, und wenn dabei eine der Funktionen  <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="module.htm#use">use</a> oder <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="module.htm#require">require</a> im Spiel sind.<br>
Die beiden Subroutinen <code>Aufruf_Info_Einfach</code> und <code>Aufruf_Info_Ausfuehrlich</code> im obigen Beispiel stellen aus den gewonnenen Informationen die Zeichenketten <code>$A_I_E</code> bzw. <code>$A_I_A</code> zusammen und geben diese am Ende zurück.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="defined">defined - Definition einer Variablen überprüfen</a></h2>

<p>Variablen, egal, ob Skalare, Listen- bzw. Array-Elemente oder Hash-Elemente, haben, solange ihnen nicht explizit irgendein Wert zugewiesen wird, den Wert <code>undef</code>. Mit dieser Funktion können Sie überprüfen, ob einer Variablen bereits ein Wert zugewiesen wurde oder nicht.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> die zu überprüfende Variable.</p>

<p>Gibt <code>1</code> bzw. ein logisches "wahr" zurück, wenn der Variablen ein Wert zugewiesen ist, und <code>0</code> bzw. ein logisches "falsch", wenn kein Wert zugewiesen ist.</p>

<h3 class="xmp"><a class="an" name="beispiel2">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle2.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $ErsterSatz;
my $ZweiterSatz = "Den ersten beissen die Katzen";

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
&amp;Satz_aufsagen;
$ErsterSatz = "...und den letzten wie bekannt die Hunde";
undef $ZweiterSatz;
print "&lt;p&gt;&lt;/p&gt;&lt;i&gt;So - und jetzt noch einmal:&lt;/i&gt;&lt;/p&gt;";
&amp;Satz_aufsagen;
print "&lt;/body&gt;&lt;/html&gt;\n";

sub Satz_aufsagen {
  if(defined $ErsterSatz) {
    print "Der erste Satz lautet &lt;strong&gt;$ErsterSatz&lt;/strong&gt;&lt;br&gt;\n";
  }
  if(defined $ZweiterSatz) {
    print "Der zweite Satz lautet &lt;strong&gt;$ZweiterSatz&lt;/strong&gt;&lt;br&gt;\n";
  }
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispielscript definiert zunächst zwei Skalare namens <code>$ErsterSatz</code> ohne Wertzuweisung und <code>$ZweiterSatz</code> mit Wertzuweisung. Das Script enthält eine Subroutine namens <code>Satz_aufsagen</code>. Darin wird mit <code>defined</code> für die beiden Skalare überprüft, ob ihnen ein Wert zugewiesen wurde. Wenn ja, wird dieser Wert ausgegeben.<br>
Das Script erzeugt HTML-Code und ruft dabei zunächst einmal die Subroutine <code>Satz_aufsagen</code> auf. Anschließend erhält der bislang undefinierte Skalar <code>$ErsterSatz</code> einen Wert, und der Skalar <code>$ZweiterSatz</code> wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="listenhashes.htm#undef">undef</a> in jenen Zustand versetzt, in dem ihm kein Wert (bzw. der "Nichtwert" <code>undef</code>) zugewiesen ist. Danach wird <code>Satz_aufsagen</code> nochmals aufgerufen.<br>
Beim ersten Aufruf von <code>Satz_aufsagen</code> wird nur "Den ersten beissen die Katzen" ausgegeben, beim zweiten Aufruf nur "...und den letzten wie bekannt die Hunde".</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Der Anfangswert <code>undef</code> einer Variablen, den Sie mit der Funktion <code>undef</code> wieder herstellen können, ist etwas anderes als der so genannte Leerstring (<code>""</code>). Eine leere Zeichenkette ist durchaus ein zugewiesener Wert!</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="die">die - Script wegen eines Fehlers abbrechen</a></h2>

<p>Beendet ein Script, wenn es keinen Sinn hat, das Script weiter auszuführen. Wird z.B. gern verwendet, wenn eine wichtige Datei nicht geöffnet werden kann.<br>
Schreibt Fehlermeldungen auf die Standardfehlerausgabe <code>STDERR</code> und beendet das Script mit dem aktuellen Wert der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/vordefiniert.htm">vordefinierten Variablen</a> <code>$!</code>. Bei der CGI-Schnittstelle eines Webervers ist die Standardfehlerausgabe meistens eine Log-Datei, in der solche Fehlermeldungen gesammelt werden. Suchen Sie gegebenenfalls in der Dokumentation zu Ihrem Webserver nach, wo und wie der Server CGI-Fehlermeldungen protokolliert.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> Eine Liste, die auf die Standardfehlerausgabe <code>STDERR</code> geschrieben werden soll. Sinnvollerweise enthält die Liste eine oder mehrere entsprechende Fehlermeldungen.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

open(TEXT, "&lt;/daten/texte/nichtda.txt") || die "Fehler aufgetreten: $!";
my @Zeilen = &lt;TEXT&gt;;
close(TEXT);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel versucht, mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#open">open</a> eine Datei zu öffnen, die aber nicht vorhanden ist. Dadurch wird der Oder-Zweig hinter dem <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/operatoren.htm#logisch">logischen Operator</a> <code>||</code> (steht für "oder") aktiv. Dort ist die Funktion <code>die</code> notiert. Sie schreibt auf die Standardfehlerausgabe, dass ein Fehler aufgetreten ist. Indem sie dabei auch die vordefinierte Variable <code>$!</code> mit in die Ausgabe schreibt, wird auch mitprotokolliert, welcher Fehler aufgetreten ist. In diesem Fall ist auch die Anweisung <code>use&nbsp;CGI::Carp&nbsp;qw(fatalsToBrowser)</code> sehr hilfreich, denn der Fehler wird dadurch zusätzlich auf die Standardausgabe geschrieben und kann so je nach Situation im Browser zur Anzeige gelangen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="eval">eval - Anweisungen oder Anweisungsblöcke interpretieren lassen</a></h2>

<p>Perl-Scripts werden normalerweise intern zu <strong>Operationscode</strong> (sogenannten Opcodes) kompiliert, bevor sie ausgeführt werden. Das merken Sie als Programmierer beispielsweise daran, dass der Perl-Interpreter vor der Ausführung abbricht, sobald das Script Syntaxfehler enthält. Mit Hilfe der <code>eval</code>-Funktion können Sie jedoch den Perl-Interpreter während der Laufzeit eines Scripts aufrufen und innerhalb des Scripts beliebigen Perl-Code interpretieren lassen. Wenn Sie so wollen, kann ein Perl-Script auf diese Weise selber Perl-Scripts schreiben und deren Ausführung in die eigene Ausführung einbetten. In die Code-Erzeugung dürfen natürlich auch Variableninhalte einfließen, die das Script verwaltet.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> <strong>entweder</strong> eine Zeichenkette, die Perl-Code enthält, <strong>oder</strong> einen Anweisungsblock in geschweiften Klammern, vergleichbar einem Anweisungsblock innerhalb einer Subroutine oder innerhalb einer <code>if</code>-Abfrage.<br>
Der Unterschied zwischen beiden Möglichkeiten besteht darin, dass eine übergebene Zeichenkette tatsächlich erst zur Laufzeit kompiliert wird, während der Anweisungsblock in der internen Vorab-Kompilierung mit berücksichtigt wird. Dadurch werden beispielsweise schwere Fehler, die zum Scriptabbruch führen, in einem übergebenen Anweisungsblock bereits bei der Kompilierung erkannt, in einer übergebenen Zeichenkette jedoch erst während der Ausführung.</p>

<p>Gibt das Ergebnis der zuletzt ausgeführten Anweisung in der übergebenen Zeichenkette oder dem übergebenen Anweisungsblock zurück. Im Fehlerfall wird <code>undef</code> zurückgegeben, und die aufgetretene Fehlermeldung ist über die <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/vordefiniert.htm">vordefinierte Variable</a> <code>$@</code> abfragbar.</p>

<h3 class="xmp">Beispiel 1 eines vollständigen CGI-Scripts in Perl:</h3>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Rechenergebnis = eval($ENV{'QUERY_STRING'});

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
print "Das Ergebnis der übergebenen Rechenoperation lautet &lt;strong&gt;$Rechenergebnis&lt;/strong&gt;&lt;br&gt;\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Script erwartet beim Aufruf einen Übergabeparameter, der über URI hinter einem Fragezeichen notiert wird. Der Übergabeparameter besteht in einer Rechenoperation. Es kann sich auch um geklammerte, komplexe Rechenausdrücke handeln, z.B. <code>((6+7)*4)+(5/7)</code>. Nur Leerzeichen sind bei diesem einfachen Beispielscript nicht erlaubt, da sie bei der Übergabe in der URI-Zeile umformatiert werden.<br>
Über die <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../servercgi/cgi/umgebungsvariablen.htm">CGI-Umgebungsvariable</a> <code>$ENV{'QUERY_STRING'}</code> kann das Script auf die übergebene Rechenoperation zugreifen. Es übergibt die Umgebungsvariable gleich an die Funktion <code>eval</code>. Die wiederum übergibt die übergebene Zeichenkette, also die Rechenoperation, zur Laufzeit an den Perl-Interpreter. Zurückgegeben wird der Wert dieser Anweisung, und das ist in dem Fall einfach das Rechenergebnis, so wie Perl es in einem Skalar speichern würde, wenn man ihm diese Rechenoperation zuweisen würde.<br>
Zur Kontrolle gibt das Script HTML-Code mit dem Rechenergebnis aus.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Scripts wie im Beispiel oben können extrem gefährlich sein. Benutzen Sie so etwas niemals als öffentlich zugängliches CGI-Script! Denn der übergebene Code, den das Script vom Anwender erhält, wird gnadenlos ausgeführt. Wenn der Anwender jemand ist, der sich auskennt, kann er statt der geforderten Rechenoperation beispielsweise einen Aufruf von <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="systemaufrufe.htm#system">system</a> übergeben, bei dem ein ganzer Verzeichnisbaum gelöscht oder die Festplatte formatiert wird.</p>

<h3 class="xmp"><a class="an" name="beispiel3">Beispiel 2 eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle3.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Zahl_1 = int(rand(50));
my $Zahl_2 = int(rand(5));
my $Ergebnis;
eval { $Ergebnis = $Zahl_1 / $Zahl_2; };

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";

if($@) {
  print "Folgender Fehler ist aufgetreten: $@\n";
}
else {
  print "$Zahl_1 geteilt durch $Zahl_2 ist $Ergebnis\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>In diesem Beispiel wird die Funktion <code>eval</code> wie in der Praxis oft üblich zum Abfangen von Fehlern verwendet. Das Script ermittelt mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="berechnungen.htm#rand">rand</a> zwei Zufallszahlen <code>$Zahl_1</code> und <code>$Zahl_2</code>. Anschließend dividiert es Zahl 1 durch Zahl 2. Da bei den ermittelten Zufallszahlen jedoch auch der Wert 0 vorkommen kann, würde ein schwerer Fehler auftreten, wenn Zahl 2 diesen Wert hat. Denn eine Division durch 0 führt auf allen Computersystemen zu einem Fehler. Das Script bettet die Anweisung mit der Division aus diesem Grund in einen <code>eval</code>-Block ein. Falls die Zahl 2 tatsächlich den Wert 0 hat, wird abgebrochen, und in der vordefinierten Variablen <code>$@</code> steht anschließend die von Perl erzeugte Fehlermeldung.<br>
Das Beispiel gibt HTML-Code aus. Dabei fragt es ab, ob <code>$@</code> einen Inhalt enthält. Wenn ja, wird der Fehler ausgegeben. Wenn nein, wird das Ergebnis der erfolgreichen Division ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="exit">exit - Script beenden</a></h2>

<p>Beendet das Script und gibt einen Wert an den aufrufenden Prozess zurück.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> (optional) einen zurückzugebenden Wert. Die üblichen Werte, die auch von fremden aufrufenden Prozessen am ehesten erkannt werden, sind <code>0</code> für "erfolgreich beenden" und <code>1</code> für "Beenden mit Fehler". Wenn Sie keinen Parameter übergeben, wird automatisch <code>0</code> verwendet.</p>

<h3 class="xmp"><a class="an" name="beispiel4">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle4.pl">Anzeigebeispiel: So sieht's aus</a> - ohne Übergabeparameter<br>
<img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle4.pl?Newbie">Anzeigebeispiel: So sieht's aus</a> - mit dem String "Newbie" als Übergabeparameter<br>(Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

if($ENV{'QUERY_STRING'} eq "") {
   HTML_Output("Username beim Aufruf erwartet!");
   exit(1);
}
else {
   HTML_Output("Hallo $ENV{'QUERY_STRING'}, wie geht's?");
   exit(0);
}

sub HTML_Output {
  print "Content-type: text/html\n\n";
  print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
  print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
  print "$_[0]\n";
  print "&lt;/body&gt;&lt;/html&gt;\n";
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Script erwartet beim Aufruf einen Übergabeparameter, der hinter einem an den URI angehängten Fragezeichen notiert wird. Der Übergabeparameter besteht in einem User-Namen. Durch Auswerten der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../servercgi/cgi/umgebungsvariablen.htm">CGI-Umgebungsvariablen</a> <code>$ENV{'QUERY_STRING'}</code> gelangt das Script an den übergebenen Namen. Wenn die Umgebungsvariable leer ist (<code>""</code>), wurde kein Name übergeben. In diesem Fall ruft das Script die Subroutine <code>HTML_Output</code> auf und lässt sie eine Fehlermeldung senden. Anschließend wird das Script mit <code>exit(1)</code> beendet. Im anderen Fall, wenn alles in Ordnung ist und ein Name übergeben wurde, ruft das Script ebenfalls <code>HTML_Output</code> auf, diesmal jedoch mit einer netten Begrüßung des Users. In diesem Fall beendet sich das Script anschließend mit <code>exit(0)</code>.</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Es ist kein guter Programmierstil, <code>exit</code> in Subroutinen zu verwenden. Wenn das Script in solchen Programmteilen fehlerhafte Situationen erkennt, sollte es besser mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#return">return</a> einen Wert zurückgeben, der an einer zentralen Stelle im Script als Fehler erkannt wird und dort zu einem Aufruf von <code>exit</code> führt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="local">local - Wert von Variablen lokal begrenzen</a></h2>

<p>Beschränkt den Wert einer Variablen (egal ob Skalar, Liste oder Hash usw.) auf lokale Gültigkeit. Die Beschränkung kann sich auf einen <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../intro.htm#anweisungsbloecke">Anweisungsblock</a> oder einen der Bereiche beziehen, die aus diesem Anweisungsblock heraus aufgerufen werden. Wenn es eine gleichnamige Variable außerhalb des Blocks gibt, wird dieser innerhalb des Anweisungsblocks temporär ein neuer Wert zugewiesen. Anwenden können Sie diese Funktion bei der Ersteinführung, also der Deklaration einer Variablen.</p>

<p>Beachten Sie, dass <code>local</code> nicht wirklich eine lokale Variable erzeugt, sondern nur eine globale Variable mit einem lokal gültigen Wert. Verwenden Sie <code>local</code> daher nur in begründeten Ausnahmefällen! "Echte" lokal gültige Variablen werden durch <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#my">my</a> deklariert.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> eine Variable, der temporär ein neuer Wert zugewiesen werden soll.</p>

<h3 class="xmp"><a class="an" name="beispiel5">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle5.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);
use vars qw($Zahl_1 $Zahl_2);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
my $Ergebnis = Subroutine_1();
print "$Ergebnis\n";
print "&lt;/body&gt;&lt;/html&gt;\n";

sub Subroutine_1 {
   local $Zahl_1 = 10;
   $Zahl_1 = $Zahl_1 * 2;
   $Zahl_2 = Subroutine_2();
   return($Zahl_1 + $Zahl_2);
}

sub Subroutine_2 {
  return($Zahl_1 + 100);

}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel deklariert zu Beginn zwei Skalare <code>$Zahl_1</code> und <code>$Zahl_2</code>. Dies sind globale Variablen, die überall Gültigkeit haben und an jeder Stelle des Scripts verändert werden können. Das Beispiel enthält weiter unten jedoch auch noch eine Subroutine namens <code>Subroutine_1</code>. Innerhalb dieser Subroutine, die aus Sicht von Perl einen Anweisungsblock darstellt, wird mit <code>local $Zahl_1</code> einer dieser globalen Variablen für die Subroutine <code>Subroutine_1</code> ein anderer Wert zugewiesen, nämlich <code>10</code>. Würde das <code>local</code> fehlen, so würde einfach der globalen Variablen <code>$Zahl_1</code> ein neuer Wert zugewiesen.<br>
<code>$Zahl_1</code> wird in der darauffolgenden Anweisung mit 2 multipliziert. Hinterher steht <code>20</code> als Wert in <code>$Zahl_1</code>, da die Multiplikation mit dem temporären Wert <code>10</code> vorgenommen wird.<br>
Aus <code>Subroutine_1</code> heraus wird anschließend <code>Subroutine_2</code> aufgerufen. Dort wird wiederum die Variable <code>$Zahl_1</code> verwendet. Zu diesem Zeitpunkt ist im Script-Ablauf der globale Wert <code>5</code> der Variablen <code>$Zahl_1</code> noch immer durch den temporären Wert <code>20</code> ersetzt. Da er auch in Bereichen Gültigkeit hat, die von <code>Subroutine_1</code> aus aufgerufen werden, wird dieser Wert innerhalb von <code>Subroutine_2</code> weiter verwendet (hier liegt ein sichtbarer Unterschied zur Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#my">my</a>). Zum aktuellen Wert 20 wird 100 addiert. Der Wert, den <code>Subroutine_2</code> mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#return">return</a> zurückgibt, lautet also 120.<br>
<code>Subroutine_1</code> gibt nach dem Aufruf von <code>Subroutine_2</code> ebenfalls das Ergebnis einer Addition an den aufrufenden Befehl zurück. Da <code>$Zahl_2</code> den Wert <code>120</code> hat, wird also der Wert <code>140</code> zurückgegeben.<br>
Im Hauptprogramm erzeugt das Beispiel HTML-Code. Dabei wird <code>Subroutine_1</code> aufgerufen und deren Rückgabewert im Skalar <code>$Ergebnis</code> gespeichert. Zur Kontrolle wird das Ergebnis ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="my">my - Gültigkeitsbereich von Variablen begrenzen</a></h2>

<p>Schränkt den Gültigkeitsbereich einer Variablen (egal ob Skalar, Liste oder Hash usw.) auf einen <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../module/intro.htm#packages_module">Namensraum</a> oder einen <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../intro.htm#anweisungsbloecke">Anweisungsblock</a> ein. Wenn es eine gleichnamige Variable außerhalb des Blocks gibt, wird diese nicht berührt. Anwenden können Sie diese Funktion bei der Definition einer Variablen.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> eine Variable, deren Gültigkeitsbereich eingeschränkt werden soll.</p>

<h3 class="xmp"><a class="an" name="beispiel6">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle6.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);
use vars qw($Zahl_1);

$Zahl_1 = 1;

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
my $Ergebnis = Subroutine_1();
print "$Ergebnis\n";
print "&lt;/body&gt;&lt;/html&gt;\n";

sub Subroutine_1 {
   my $Zahl_1 = 10;
   my $Zahl_2 = Subroutine_2();
   return($Zahl_1 + $Zahl_2);
}

sub Subroutine_2 {
 return($Zahl_1 + 100);
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel deklariert zu Beginn einen Skalar <code>$Zahl_1</code>. Dies ist eine globale Variable, die überall Gültigkeit hat und an jeder Stelle des Scripts verändert werden kann. Die Deklaration erfolgt mit dem <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../module/standardmodule.htm">Standardmodul</a> <code>vars</code>. Der Grund dafür ist, dass die Verwendung von <code>use strict</code> sonst keine Deklaration globaler Variablen erlaubt und einen Fehler erzeugen würde. Im Beispiel sehen Sie, wie das Modul <code>vars</code> eingesetzt wird. Mit <code>use</code> eingebunden, steht in der Klammer hinter <code>qw</code> der Name <code>$Zahl_1</code>, also der Name der Variablen, die global deklariert werden soll. In der Klammer hinter <code>qw</code> können Sie als Liste, durch Leerzeichen getrennt, auch mehrere globale Variablen angeben.</p>

<p>Das Beispielscript enthält weiter unten eine Subroutine namens <code>Subroutine_1</code>. Innerhalb dieser Subroutine, die aus Sicht von Perl einen Anweisungsblock darstellt, wird mit <code>my $Zahl_1</code> eine Variable deklariert, die den gleichen Namen hat wie die globale Variable. Durch Anwendung von <code>my</code> ist es jedoch eine eigene neue Variable, die mit <code>10</code> initialisiert wird. Würde das <code>my</code> fehlen, so würde einfach der globalen Variablen <code>$Zahl_1</code> ein neuer Wert zugewiesen.<br>
Aus <code>Subroutine_1</code> heraus wird <code>Subroutine_2</code> aufgerufen. Dort wird wieder die Variable <code>$Zahl_1</code> verwendet. Zu diesem Zeitpunkt im Script-Ablauf existieren beide Variablen <code>$Zahl_1</code>. Da diejenige, die in <code>Subroutine_1</code> deklariert wurde, jedoch nur dort Gültigkeit hat, ist innerhalb von <code>Subroutine_2</code> wieder die globale Variable gemeint. Zu deren Wert <code>1</code> wird <code>100</code> addiert. Der Wert, den <code>Subroutine_2</code> mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#return">return</a> zurückgibt, lautet also <code>101</code>.<br>
<code>Subroutine_1</code> gibt nach dem Aufruf von <code>Subroutine_2</code> ebenfalls das Ergebnis einer Addition an den aufrufenden Befehl zurück. In diesem Fall ist mit <code>$Zahl_1</code> wieder diejenige Variable gemeint, die innerhalb des gleichen Blocks, also innerhalb von <code>Subroutine_1</code> deklariert wurde, und die den Wert <code>10</code> hat. Da <code>$Zahl_2</code> den Wert <code>101</code> hat, wird also der Wert <code>111</code> zurückgegeben.<br>
Im Hauptprogramm gibt das Beispiel HTML-Code aus. Dabei wird <code>Subroutine_1</code> aufgerufen und deren Rückgabewert im Skalar <code>$Ergebnis</code> gespeichert. Zur Kontrolle wird das Ergebnis ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="quotemeta">quotemeta - Alle Zeichen außer A-Z, a-z, 0-9 und _ maskieren</a></h2>

<p>Wandelt eine Zeichenkette so um, dass alle Zeichen außer A bis Z, a bis z, 0 bis 9 und Unterstrich _ mit einem Backslash <code>\</code> maskiert werden.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> eine Zeichenkette, die umgewandelt werden soll.</p>

<p>Gibt die umgewandelte Zeichenkette zurück.</p>

<h3 class="xmp"><a class="an" name="beispiel7">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle7.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";

my $Normaltext = "+++Test+++";
my $Normallaenge = length($Normaltext);
my $Quotematatext = quotemeta($Normaltext);
my $Quotematalaenge = length($Quotematatext);

print "&lt;strong&gt;$Normaltext&lt;/strong&gt; wurde umgewandelt in &lt;strong&gt;$Quotematatext&lt;/strong&gt;&lt;br&gt;\n";
print "Textlänge zuvor: &lt;strong&gt;$Normallaenge&lt;/strong&gt; Zeichen&lt;br&gt;\n";
print "Textlänge jetzt: &lt;strong&gt;$Quotematalaenge&lt;/strong&gt; Zeichen\n";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt HTML-Code. Dabei demonstriert es die Wirkungsweise von <code>quotemeta</code>. Ein Skalar namens <code>$Normalext</code> wird zunächst mit einem Wert belegt, der neben dem Wort "Test" diverse Pluszeichen enthält. Außerdem wird mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="zeichenketten.htm#length">length</a> die Länge der Zeichenkette ermittelt. Durch die anschließende Anwendung der Funktion <code>quotemeta</code> auf <code>$Normaltext</code> werden die Pluszeichen maskiert. Der Rückgabewert der Funktion wird in einem neuen Skalar namens <code>$Quotemetatext</code> gespeichert. Auch dessen Länge wird mit <code>length</code> ermittelt. Zur Kontrolle gibt das Script alle ermittelten Daten aus. Die maskierte Version hat 6 Zeichen mehr, da jedes Pluszeichen maskiert wurde.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="return">return - aus Subroutine zurückkehren und Wert zurückgeben</a></h2>

<p>Gibt einen Wert an die Anweisung zurück, welche die <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/subroutinen.htm">Subroutine</a> aufgerufen hat.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> (optional) ein Wert, der zurückgegeben werden soll. Es kann sich um eine Zahl, eine Zeichenkette oder um eine beliebige Variable (auch um eine komplette Liste oder einen Hash) handeln. Wenn kein Parameter übergeben wird, wird einfach die Subroutine verlassen und je nach zuletzt ausgeführtem Kontext eine leere Liste oder ein Skalar mit dem Wert <code>undef</code> zurückgegeben.</p>

<h3 class="xmp"><a class="an" name="beispiel8">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle8.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
my $Ausgabe = fett("eine wichtige Angelegenheit");
print "&lt;p&gt;$Ausgabe&lt;/p&gt;\n";
$Ausgabe = kursiv("eine noch wichtigere Angelegenheit");
$Ausgabe = fett($Ausgabe);
print "&lt;p&gt;$Ausgabe&lt;/p&gt;\n";
print "&lt;/body&gt;&lt;/html&gt;\n";

sub fett {
  my $fetterText = "&lt;strong&gt;$_[0]&lt;/strong&gt;";
  return $fetterText;
}

sub kursiv {
  my $kursiverText = "&lt;i&gt;$_[0]&lt;/i&gt;";
  return $kursiverText;
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel enthält zwei Subroutinen namens <code>fett</code> und <code>kursiv</code>. In beiden Subroutinen wird ein übergebener Parameter erwartet, der in dem vordefinierten Array für Übergabeparameter (<code>@_</code>) an erster Stelle (<code>$_[0]</code>) steht. Dieser übergebene Parameter wird in die HTML-Tags für fett bzw. kursiv gesetzt. Die Skalare <code>$fetterText</code> bzw. <code>$kursiverText</code>, die dieses Konstrukt speichern, werden anschließend mit <code>return</code> zurückgegeben.<br>
Das Script erzeugt HTML-Code. Während der Ausgabe ruft es die beiden Subroutinen auf. Der Rückgabewert wird jeweils in dem Skalar <code>$Ausgabe</code> gespeichert. Im zweiten Fall werden sogar beide Subroutinen hintereinander aufgerufen. Dadurch wird der übergebene Text erst kursiv, dann fett, also insgesamt fett kursiv. Zur Kontrolle werden die HTML-Konstrukte ausgegeben.</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Subroutinen geben auch dann etwas zurück, wenn sie nicht mit <code>return</code> verlassen werden. Wenn Sie beispielsweise eine Subroutine so aufrufen:<br>
<code>$Ausgabe = Test();</code><br>
und die Subroutine so aussieht:<br>
<code>sub Test { $x = 1; }</code><br>
dann ist in <code>$Ausgabe</code> anschließend der Wert <code>1</code> gespeichert.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="scalar">scalar - Ausdruck in skalarem Kontext bewerten</a></h2>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> einen beliebigen Ausdruck. Es kann sich um eine Variable, einen Funktionsaufruf, eine Berechnung, eine Zuweisung usw. handeln.</p>

<p>Gibt den Wert zurück, den der übergebene Ausdruck bei skalarem Kontext liefert.</p>

<h3 class="xmp"><a class="an" name="beispiel9">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle9.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
my $Singular = "ein Tisch";
my @Plural = ("ein Tisch","noch ein Tisch");
my $Ausgabe_1 = scalar($Singular);
my $Ausgabe_2 = scalar(@Plural);
my $Ausgabe_3 = scalar(time() &gt; 900000000 ? 1 : 0);
print "Ausgabe 1: $Ausgabe_1&lt;br&gt;\n";
print "Ausgabe 2: $Ausgabe_2&lt;br&gt;\n";
print "Ausgabe 3: $Ausgabe_3\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel gibt HTML-Code aus. Dabei definiert es einen Skalar namens <code>$Singular</code> und eine Liste namens <code>@Plural</code>. Auf beide wird die Funktion <code>scalar</code> angewendet. Der skalare Rückgabewert wird in den Skalaren <code>$Ausgabe_1</code> und <code>$Ausgabe_2</code> gespeichert. Außerdem wird noch ein dritter Skalar <code>$Ausgabe_3</code> definiert, dem der skalare Kontext einer komplexeren Anweisung zurückgegeben wird. In der Anweisung wird ermittelt, ob der Rückgabewert der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="datumzeit.htm#time">time</a> größer als 900000000 ist. Wenn ja, wird 1 zurückgegeben, wenn nein, wird 0 zurückgegeben. Anschließend gibt das Script die 3 ermittelten Werte aus.<br>
<code>$Ausgabe_1</code> gibt einfach den Inhalt des Skalars <code>$Singular</code> aus, also <code>ein Tisch</code>. Da der bewertete Ausdruck ein Skalar ist, hat der skalare Kontext keinen Einfluss auf den zurückgegebenen Wert.<br>
<code>$Ausgabe_2</code> gibt eine Zahl aus, nämlich 2. Der Grund ist, dass die skalare Interpretation einer Liste, im Beispiel der Liste <code>@Plural</code>, die Anzahl der Elemente ermittelt, die in der Liste enthalten sind.<br>
<code>$Ausgabe_3</code> gibt 1 oder 0 aus, je nachdem, welchen Wert <code>time</code> zurückgeliefert hat. Da 1 und 0 normale Einzelwerte sind, ist der skalare Kontext bereits gegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="wantarray">wantarray - Überprüfen ob Listenkontext gegeben ist</a></h2>

<p>Erwartet keine Parameter</p>

<p>Gibt <code>1</code> bzw. <code>TRUE</code> zurück, wenn das aufrufende Programm oder die aufrufende Subroutine einen Listenkontext erwartet, und <code>0</code> bzw. <code>FALSE</code>, wenn ein skalarer Kontext erwartet wird. Gibt <code>undef</code> zurück, wenn gar kein Kontext erwartet wird (sogenannter <i>void context</i>).</p>

<h3 class="xmp"><a class="an" name="beispiel10">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle10.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";

my @Zahlen = (1,2,3,4,5);

my $Normalsumme = Summe_ermitteln(@Zahlen);
print "Die normale Summe von 1,2,3,4,5 ist &lt;strong&gt;$Normalsumme&lt;/strong&gt;&lt;br&gt;\n";

my @Kumulativsummen = Summe_ermitteln(@Zahlen);
print "Die Kumulativsummen von 1,2,3,4,5 sind &lt;strong&gt;@Kumulativsummen&lt;/strong&gt;&lt;br&gt;\n";

print "&lt;/body&gt;&lt;/html&gt;\n";

sub Summe_ermitteln {
   if(wantarray) {
     my @Summe = @_;
     my $Wert;
     foreach my $Summe (@Summe) {
        $Summe = $Wert += $Summe;
     }
     return @Summe;
   }
   else {
     my $Wert;
     foreach my $Summe (@_) {
        $Wert += $Summe;
     }
     return $Wert;
   }
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel enthält eine Subroutine namens <code>Summe_ermitteln</code>. Die Funktion erwartet einen Array von Zahlen als Parameter, die über die Parameterliste <code>@_</code> abgefragt werden können. Innerhalb der Funktion wird mit <code>if(wantarray)</code> abgefragt, ob die Anweisung, die die Subroutine aufruft, als Rückgabewert eine Liste oder einen Skalar erwartet. Wenn eine Liste erwartet wird, wird der <code>if</code>-Zweig ausgeführt. Wenn ein Skalar erwartet wird, dann der <code>else</code>-Zweig. Im <code>if</code>-Zweig ist ein Algorithmus notiert, der aus den übergebenen Zahlen Kumulativsummen ermittelt. Die Kumulativsummen werden in einer Liste namens <code>@Summe</code> festgehalten. Diese Liste wird am Ende zurückgegeben. Im <code>else</code>-Zweig dagegen ermittelt die Funktion einfach nur die Summe der übergebenen Zahlen und hält das Ergebnis in dem Skalar <code>$Wert</code> fest, den sie am Ende zurückgibt.<br>
Im Hauptprogramm wird HTML-Code erzeugt. Dabei wird insgesamt zweimal die Subroutine <code>Summe_ermitteln</code> aufgerufen. Einmal wird der Rückgabewert in einem Skalar namens <code>$Normalsumme</code> gespeichert, und beim anderen mal in einer Liste namens <code>@Kumulativsummen</code>. Dadurch wird beim ersten Aufruf der Subroutine der <code>else</code>-Zweig ausgeführt, und beim zweiten Aufruf der <code>if</code>-Zweig. Zur Kontrolle gibt das Script die jeweils ermittelten Ergebnisse aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="warn">warn - Warnungen ausgeben</a></h2>

<p>Schreibt Warnungen auf die Standardfehlerausgabe <code>STDERR</code>, ohne das Script zu beenden (im Gegensatz zu <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#die">die</a>). Für die CGI-Schnittstelle eines Webservers ist die Standardfehlerausgabe meistens eine Log-Datei, in der solche Fehlermeldungen gesammelt werden. Suchen Sie gegebenenfalls in der Dokumentation zu Ihrem Webserver nach, wo und wie der Server CGI-Fehlermeldungen protokolliert.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> Eine Liste mit der oder den Meldungen, die auf die Standardfehlerausgabe <code>STDERR</code> geschrieben werden sollen.</p>

<h3 class="xmp"><a class="an" name="beispiel11">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle11.pl">Anzeigebeispiel: So sieht's aus</a> - ohne Übergabeparameter
<br><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/kontrolle11.pl?hallo">Anzeigebeispiel: So sieht's aus</a> - mit dem String "hallo" als Übergabeparameter<br>(Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Daten = $ENV{'QUERY_STRING'};

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";

if(! -e "/tmp/idx.txt") {
  warn("idx.txt nicht gefunden. Datei wird deshalb neu erzeugt\n");
  open(FILE,"&gt;/tmp/idx.txt");
  print FILE "$Daten\n";
}
else {
  open(FILE,"&gt;&gt;/tmp/idx.txt");
  print FILE "$Daten\n";
}
print "&lt;strong&gt;in Datei geschrieben:&lt;/strong&gt; $Daten\n";
close(FILE);

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Script erwartet einen Übergabeparameter, der hinter einem Fragezeichen notiert wird. Der Übergabeparameter ist in diesem Beispiel ein User-Name. Durch Auswerten der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../servercgi/cgi/umgebungsvariablen.htm">CGI-Umgebungsvariablen</a> <code>$ENV{'QUERY_STRING'}</code> gelangt das Script an die übergebenen Daten.<br>
Das Script erzeugt HTML-Code. Währenddessen versucht es, mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#open">open</a> eine Datei namens <code>/usr/web/temp/idx.txt</code> zu öffnen, um die übergebenen Daten ans Ende der Datei zu schreiben. Falls die Datei nicht existiert, wird sie im <code>if</code>-Zweig zwar neu erzeugt (falls das Verzeichnis <code>/usr/web/temp</code> zumindest schon existiert), aber es wird mit <code>warn</code> eine entsprechende Warnung auf die Standardfehlerausgabe, die dem error_log des Webservers entspricht, geschrieben. Sie erhalten diese Warnung also <strong>nicht</strong> im Browserfenster angezeigt.<br>
Zur Kontrolle wird auch noch übermittelt, welche Daten in die Datei geschrieben wurden. Diese Mitteilung sehen Sie allerdings in Ihrem Browser.<br>
Die <code>if</code>-Abfrage überprüft mit dem <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm#dateitest">Dateitestoperator</a> <code>-e</code>, ob die Datei bereits existiert. Abhängig davon ist die Reaktion des Scripts.</p>



<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" class="doc">
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a>
</td></tr>
<tr><td class="doc"><a href="datumzeit.htm"><img src="../../src/next.gif" width="10" height="10" border="0" hspace="10" alt="weiter"></a></td>
<td width="100%"><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="datumzeit.htm">Funktionen für Datum und Uhrzeit</a>
</td></tr>
<tr>
<td class="doc"><a href="listenhashes.htm"><img src="../../src/prev.gif" width="10" height="10" border="0" hspace="10" alt="zurück"></a></td>
<td><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="berechnungen.htm">Funktionen für Berechnungen</a>
</td>
</tr>
<tr><td colspan="2" class="doc">&nbsp;</td>
</tr>
<tr>
<td colspan="2" class="nav"><a class="an" name="bottom"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Funktionen</a></td>
</tr>
</table>

<p>&copy; 2007 <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../editorial/impressum.htm">Impressum</a></p>

</body>
</html>
