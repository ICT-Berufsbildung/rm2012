<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>SELFHTML: Perl / Funktionsreferenz / Funktionen für Betriebssystemaufrufe</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Welche Funktionen es in Perl gibt, um Daten aus Konfigurationsdateien des Rechners zu ermitteln.">
<meta name="keywords"       content="SELFHTML, Perl, Funktionen, Perl-Funktionen, Systemaufrufe, System-Calls, alarm, exec, fork, getpgrp, getppid, getpriority, kill, pipe, setpgrp, setpriority, sleep, system, times, wait, waitpid">
<meta name="author"         content="Redaktion SELFHTML, selfhtml81@selfhtml.org">
<meta name="robots"         content="noindex, nofollow">
<meta name="DC.Publisher"   content="SELFHTML e. V.">
<meta name="DC.Date"        content="2005-11-06T15:17:41+01:00">
<meta name="DC.Identifier"  content="http://de.selfhtml.org/perl/funktionen/systemaufrufe.htm">
<meta name="DC.Language"    content="de">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.created" content="2001-10-27T08:00+01:00">
<meta name="SELF.Pagetype"  content="page">
<link rel="alternate" type="application/atom+xml" title="SELFHTML-Weblog (Atom, gesamt)" href="http://aktuell.de.selfhtml.org/weblog/atom-feed">
<link rel="alternate" type="application/rss+xml" title="SELFHTML-Weblog (RSS, Auszüge)" href="http://aktuell.de.selfhtml.org/weblog/rss-feed">
<link rel="shortcut icon" type="image/x-icon" href="../../src/favicon.ico">
<link rel="author" title="Impressum" href="../../editorial/impressum.htm">
<link rel="contents" title="Inhaltsverzeichnis" href="../../navigation/inhalt.htm">
<link rel="index" title="Stichwortverzeichnis" href="../../navigation/stichwort.htm">
<link rel="search" title="Suche" href="../../navigation/suche/index.htm">
<link rel="help" title="Hilfe" href="../../editorial/index.htm">
<link rel="copyright" title="Urheberrecht" href="../../editorial/copyright.htm">
<link rel="top" title="SELFHTML" href="../../index.htm">
<link rel="up" title="Perl-Funktionen" href="index.htm">
<link rel="next" title="Funktionen für Informationen aus Konfigurationsdateien" href="konfiguration.htm">
<link rel="prev" title="Funktionen für Datei- und Verzeichnis-Management" href="dateiverwaltung.htm">
<link rel="first" title="Funktionen für Zeichenketten" href="zeichenketten.htm">
<link rel="last" title="Funktionen für Module und Packages" href="module.htm">
</head>
<body>

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td colspan="2" class="nav"><a class="an" name="top"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Funktionen</a></td>
</tr>
<tr>
<td class="doc" width="110"><a href="../../index.htm"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></a></td>
<td class="docbot" width="100%"><h1 class="ph1">Funktionen für Betriebssystemaufrufe</h1></td>
</tr>
<tr>
<td class="doctop">
<img src="../../src/dokx.gif" width="30" height="20" vspace="6" alt="Informationsseite">
</td>
<td valign="top" nowrap="nowrap">
<p>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#allgemeines">Allgemeines zu diesen Funktionen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#qx">qx(...)</a> - Andere Programme/Scripts ausführen und STDOUT auffangen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#alarm">alarm</a> - SIGALARM in n Sekunden zustellen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#exec">exec</a> - Fremdprogramm aufrufen und eigenen Prozess beenden<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#fork">fork</a> - Kindprozess erzeugen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#getpgrp">getpgrp</a> - Prozessgruppe einer Prozessnummer (pid) ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#getppid">getppid</a> - Prozessnummer (pid) des Elternprozesses ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#getpriority">getpriority</a> - Priorität eines Prozesses oder Benutzers ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#kill">kill</a> - Signal an Prozess senden<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#pipe">pipe</a> - Pipe erzeugen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#setpgrp">setpgrp</a> - Prozessgruppe für Prozess bestimmen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#setpriority">setpriority</a> - Priorität eines Prozesses oder Benutzers setzen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sleep">sleep</a> - aktuellen Prozess anhalten<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#system">system</a> - Fremdprogramm aufrufen und eigenen Prozess erhalten<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#times">times</a> - Laufzeit des aktuellen Prozesses ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#wait">wait</a> - auf das Ende eines Kindprozesses warten<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#waitpid">waitpid</a> - auf das Ende eines Kindprozesses mit bestimmter Prozessnummer (pid) warten<br>
</p>
</td>
</tr><tr><td colspan="2" class="doc">&nbsp;<a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>&nbsp;</td></tr>
</table>



<h2><a class="an" name="allgemeines">Allgemeines zu diesen Funktionen</a></h2>

<p>Unter "Betriebssystemaufrufe" sind hier Funktionen versammelt, die sich vor allem eng am Konzept der Unix-Betriebssysteme orientieren. Nur wenige der Funktionen sind auf andere Systeme portierbar.</p>

<p>Unix-Systeme verwalten laufende "Programme" in so genannten Prozessen. Jeder Prozess hat eine Prozessnummer (PID). Außerdem gibt es Prozessgruppen. Jeder Prozess gehört zu einer Prozessgruppe. Prozessgruppen haben ebenfalls Nummern. Auch Ihr Perl-Script stellt, wenn es ausgeführt wird, einen solchen Prozess dar, der einer Prozessgruppe angehört. Bei vielen der hier beschriebenen Funktionen können Sie den aktuellen Prozess, also den Ihres Perl-Scripts, durch die "virtuelle" Prozessnummer <code>0</code> ansprechen. Über <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/vordefiniert.htm">vordefinierte Variablen</a> können Sie jedoch auch die tatsächliche Prozessnummer herausfinden und benutzen. Das folgende Beispielscript zeigt die entsprechenden Variablen im Einsatz:</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
print "Prozessnummer (PID): &lt;strong&gt;$$&lt;/strong&gt;&lt;br&gt;\n";
print "Reale Benutzergruppe (GID) des Prozesses: &lt;strong&gt;$(&lt;/strong&gt;&lt;br&gt;\n";
print "Effektive Benutzergruppe (GID) des Prozesses: &lt;strong&gt;$)&lt;/strong&gt;\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Mit <code>$$</code> sprechen Sie die Nummer des aktuellen Prozesses an. Der Prozess läuft unter einer bestimmten User-ID, die wiederum einer oder mehreren Gruppen angehört. Wenn das Script beispielsweise mit <code>setgid</code> gestartet wurde, enthält die reale Gruppen-ID die Gruppe(n), von der aus gestartet wurde, die effektive Gruppen-ID enthält die Gruppe(n), in die gewechselt wurde (die aktuelle also). Das Beispiel-CGI-Script gibt die entsprechenden Daten aus.</p>

<p>Weitere wichtige Konzepte der Unix-Betriebssysteme, auf die Sie mit Perl-Funktionen Zugriff haben, sind Alarme, Kindprozesse und die so genannten Pipes. Nähere Informationen dazu finden Sie in der Unix-Fachliteratur.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="qx">qx(...) - Andere Programme/Scripts ausführen und STDOUT auffangen</a></h2>

<p>Hierbei handelt es sich eigentlich nicht um eine Perl-Funktion, sondern um eine besondere Form des <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/zeichenketten.htm#regeln">Notierens von Zeichenketten</a>. Das <code>qx</code> steht für <i>quoted executable</i>. Die darin eingeschlossene Zeichenkette wird von Perl einfach in einen Kommandozeilenaufruf umgesetzt. Die Standardausgabe des aufgerufenen Kommandos, Fremdprogramms oder Scripts wird aufgefangen und kann in einer Variablen gespeichert werden. Eine andere Möglichkeit, diese Art von ausführbaren Zeichenketten zu notieren, sind die so genannten <i>Backticks</i>. Dabei arbeiten Sie anstelle von <code>qx(irgendein Kommando)</code> mit dem rückwärts gerichteten Accent-Zeichen <code>`</code> und notieren <code>`irgendein Kommando`</code>.</p>

<p>Die Funktionalität der ausführbaren Zeichenketten ist für CGI-Scripts extrem nützlich, um die Ausgaben anderer Prozesse auffangen und an den Browser senden lassen zu können. So lassen sich beispielsweise <img src="../../src/kap.gif" width="15" height="13" alt="Kapitel">&nbsp;<a href="../../xml/index.htm">XML</a>-Daten mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../xml/darstellung/xslgrundlagen.htm">XSLT</a> und einem XSLT-Prozessor in HTML übersetzen. Wenn dieser Prozessor seine Ergebnisse auf den <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#allgemeines">Standardausgabekanal</a> <code>STDOUT</code> schreibt, kann das CGI-Script die Ausgabe auffangen und an den Webserver zur Weiterleitung übergeben. Das folgende Beispiel zeigt dies.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
my $Output = qx(/usr/bin/saxon /daten/xml/kunden.xml /daten/xml/kunden.xsl);
print "$Output";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Mehr als dieses winzige Script ist nicht nötig, um XML-Daten in HTML-Form an den Webserver zur Übergabe an einen aufrufenden Browser zu senden - sofern ein XSLT-Prozessor die Übersetzungsarbeit leistet. Das Beispiel führt folgendes Kommando aus:<br>
<code>/usr/bin/saxon /daten/xml/kunden.xml /daten/xml/kunden.xsl</code><br>
Dabei ist <code>saxon</code> der Name eines XSLT-Prozessors, also eines ausführbaren Programms. Dieses Programm erwartet im Normalfall zwei Aufrufparameter: erstens die Angabe einer XML-Datei, und zweitens die Angabe einer dazu passenden XSL-Datei mit XSLT-Anweisungen. Saxon übersetzt die XML-Auszeichnungen aufgrund der XSLT-Angaben in HTML-Konstrukte und gibt das Ergebnis, eine vollständige HTML-Datei, auf die Standardausgabe aus. Das Script fängt diese Standardausgabe auf, indem es sie in der Variablen <code>$Output</code> speichert. In dieser Variablen steht also nach dem Saxon-Aufruf der gesamte Inhalt der HTML-Daten. Ein einfacher print-Befehl genügt anschließend, um die gesamten HTML-Daten auszugeben.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Die Art der Klammerung bei Verwendung von <code>qx</code> ist egal. Sie können auch eckige oder geschweifte Klammern oder Schrägstriche verwenden - von letzteren ist allerdings abzuraten, weil viele Kommandos Pfadangaben benötigen und Sie in diesem Fall alle Schrägstriche bei Pfadangaben maskieren müssten.</p>

<p>Bei Pfadangaben sollten Sie auch bei <code>qx(...)</code> stets die einfachen Schrägstriche verwenden - auch wenn das Perl-Script unter Windows ausgeführt wird.</p>

<p>Mit Backticks würde der Aufruf des obigen Beispiels lauten:<br>
<code>my $Output = `/usr/bin/saxon /daten/xml/kunden.xml /daten/xml/kunden.xsl`;</code><br>
Um die Backticks zu erzeugen, halten Sie auf den meisten Systemen die Shift-Taste gedrückt, tippen einmal auf die Taste mit den französischen Accent-Zeichen und anschließend die Leertaste.</p>

<p>Im Link-Verzeichnis des Online-Angebots von SELFHTML aktuell finden Sie Links zu <img src="../../src/serverdok.gif" width="15" height="10" alt="Online-Seite">&nbsp;<a target="_top" href="http://aktuell.de.selfhtml.org/links/xml-software.htm">XML-Software</a>. Dort finden Sie ebenso Verweise zu Produkten wie Saxon.</p>

<p>Die hier beschriebene Möglichkeit ist auf alle Kommandos anwendbar, die etwas auf die Standardausgabe <code>STDOUT</code> schreiben, also z.B. auch auf Betriebssystem-Kommandos wie <code>ls</code> (bzw. <code>dir</code>), oder auch auf andere Perl-Scripts. Einige solcher Programme oder Kommandos schreiben ihren Output bei fehlerhaften Aufrufen jedoch nicht auf <code>STDOUT</code>, sondern auf <code>STDERR</code>. Solche Ausgaben werden von den hier beschriebenen ausführbaren Zeichenketten <strong>nicht</strong> aufgefangen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="alarm">alarm - SIGALARM in n Sekunden zustellen</a></h2>

<p>Unix-spezifischer Befehl. Bewirkt, dass der Prozess einen SIGALARM nach einer bestimmten Anzahl Sekunden erhält, wenn z.B. ein kritischer Befehl nicht funktioniert.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> die Anzahl Sekunden, bis der Alarm aktiv wird. </p>

<p>Gibt die Anzahl Sekunden zurück, die verstrichen sind.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\n";

eval {
  local $SIG{ALRM} = sub { die "Alarm" };
  alarm(2);
  system("/usr/bin/perl -c /usr/web/myhome/cgi-bin/freelink.pl");
  alarm(0);
};
if ($@ and $@ !~ /Alarm/) {
  print "Problem! 2 Sekunden vergangen!\n";
}
else {
  print "Alles klar!\n";
}
print "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt, wie Sie einen "kritischen Systemaufruf" mit Hilfe eines Timeout-Alarms behandeln können. Dazu wird in dem Script zunächst ein für solche Behandlung typischer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="kontrolle.htm#eval">eval</a>-Block notiert. Darin wird mit der typischen Anweisung:<br>
<code>local $SIG{ALRM} = sub { die "Alarm" };</code><br>
eine Behandlungsroutine für SIGALARM definiert. Anschließend wird mit <code>alarm(2)</code> ein Timeout von 2 Sekunden definiert, bevor der Alarm aktiv wird. Mit <code>alarm(0)</code> wird der Alarm wieder zurückgesetzt.<br>
Danach wird versucht, mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#system">system</a> den Perl-Interpreter aufzurufen, und zwar so, dass er ein bestimmtes Script auf die Gültigkeit seiner Syntax überprüft. Sollte dieser Vorgang mehr als 2 Sekunden dauern, wird der Alarm aktiv.<br>
Mit der Abfrage <code>if ($@ and $@ !~ /Alarm/)</code> wird überprüft, ob der Alarm aktiv wurde. Wenn ja, wird eine entsprechende Meldung ausgegeben. Im <code>else</code>-Zweig kann der Code stehen, der ausgeführt wird, wenn alles in Ordnung war. Im Beispiel wird einfach ebenfalls eine entsprechende Meldung ausgegeben.</p>

<h3 class="inf">Beachten Sie</h3>

<p>Aufrufe mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#system">system</a> oder <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#qx">qx(...)</a> in Verbindung mit <code>alarm</code> können zu sogenannten Zombies führen. Möglicherweise müssen Sie sie für solche Zwecke mit Hilfe von <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#fork">fork</a> und <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#exec">exec</a> selbst implementieren.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="exec">exec - Fremdprogramm aufrufen und eigenen Prozess beenden</a></h2>

<p>Startet einen anderen Prozess und beendet das aktuelle Script. Der aktuelle Prozess wird dabei durch den neuen Prozess vollständig ersetzt. Wenn Sie das aktuelle Script nicht beenden wollen, benutzen Sie <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#system">system</a>, <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#qx">qx(...)</a> oder <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#open">open</a> mit dem Pipe-Zeichen <code>|</code>.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> Kommandozeilenaufruf des gewünschten Programms,<br>
<strong>2.</strong> bis <strong>n.</strong> (optional) Liste mit Aufrufparametern.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

exec("/usr/bin/perl","mystats.pl") if -e "mystats.pl";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel fragt mit Hilfe des <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm#dateitest">Dateitestoperators</a> <code>-e</code> ab, ob eine Datei namens <code>mystats.pl</code> im aktuellen Verzeichnis existiert. Wenn ja, wird der Perl-Interpreter (in einem eigenen neuen Prozess) gestartet und führt <code>mystats.pl</code> aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="fork">fork - Kindprozess erzeugen</a></h2>

<p>Unix-spezifischer Befehl. Erzeugt eine Kopie des aktuellen Prozesses, die dem aktuellen erzeugenden Prozess untergeordnet ist. Ein Perl-Script kann sich auf diese Weise gabeln (engl. <i>fork</i>) und Daten in zwei getrennten Prozessen verarbeiten. Auf geöffnete Dateien können dabei beide Prozesse zugreifen. Alles übrige, wie Variablen usw., wird vom Elternprozess in den Kindprozess kopiert. Die Variable, die den Rückgabewert von <code>fork</code> speichert, hat jedoch im Elternprozess einen Wert, nämlich die Prozessnummer des Kindprozesses, während sie im Kindprozess den Wert <code>0</code> hat.<br>
Obwohl <code>fork</code> eigentlich aus der Unix-Welt stammt, lässt sich diese Funktion mittlerweile auch unter ActivePerl für Windows nutzen.</p>

<p>Erwartet keine Parameter.</p>

<p>Gibt die vom Betriebssystem zugewiesene Prozessnummer des Kindprozesses zurück.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
my $Eltern_pid = $$;
my $Kind_pid = fork();

if($Kind_pid) {
  print "&lt;p&gt;Hier ist der Elternprozess. Der Kindprozess hat die PID &lt;strong&gt;$Kind_pid&lt;/strong&gt;&lt;/p&gt;\n";
  wait;
}
else {
  my $Eltern_pid = getppid();
  print "&lt;p&gt;Hier ist der Kindprozess. Der Elternprozess hat die PID &lt;strong&gt;$Eltern_pid&lt;/strong&gt;&lt;/p&gt;\n";
  exit(0);
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt mit <code>fork</code> einen Kindprozess. Der Rückgabewert der Funktion, die Prozessnummer des Kindprozesses, wird in dem Skalar <code>$Kind_pid</code> gespeichert. Im Beispiel ist daraufhin eine <code>if</code>-Abfrage notiert. Mit <code>if($Kind_pid)</code> wird abgefragt, ob der Skalar <code>$Kind_pid</code> einen Wert ungleich <code>0</code> hat. Ist das der Fall, werden Anweisungen ausgeführt, die zum Elternprozess gehören. Im Beispiel wird eine Meldung ausgegeben, dass sich das Script im Elternprozess befindet. Außerdem wird die Prozessnummer des Kindprozesses ausgegeben. Danach wird mit der Anweisung <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#wait">wait</a> gewartet, bis der Kindprozess beendet ist. Im <code>else</code>-Zweig, in den das Script gelangt, wenn <code>Kind_pid</code> den Wert <code>0</code> hat, wird dagegen ausgegeben, dass der Kindprozess aktiv ist. Außerdem wird die Prozessnummer des Elternprozesses ausgegeben. Danach wird der Kindprozess mit der Anweisung <code>exit(0);</code> beendet. Der Elternprozess, der darauf nur gewartet hat, gibt dann noch die letzte Zeile HTML-Code aus.<br>
Das besondere Verhalten des Scripts, das in zwei Prozessen läuft, zeigt sich im Beispiel darin, dass <strong>sowohl</strong> der <code>if</code>-Zweig <strong>als auch</strong> der <code>else</code>-Zweig ausgeführt werden. Das erklärt sich daraus, dass die <code>if</code>-Bedingung für den Elternprozess wahr ist, die <code>else</code>-Alternative dagegen für den Kindprozess.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="getpgrp">getpgrp - Prozessgruppe einer Prozessnummer (pid) ermitteln</a></h2>

<p>Unix-spezifischer Befehl.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> eine Prozessnummer, zu der die zugehörige Prozessgruppe ermittelt werden soll. Um die Prozessgruppe des aktuellen Prozesses zu ermitteln, müssen Sie <code>0</code> übergeben.</p>

<p>Gibt die Gruppennummer zurück.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

my $Gruppennummer = getpgrp(0);
print "Die Prozessgruppe des aktuellen Prozesses ist &lt;strong&gt;$Gruppennummer&lt;/strong&gt;\n";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel ermittelt die Gruppennummer des aktuellen Prozesses mit <code>getpgrp</code> und gibt HTML-Code mit der ermittelten Nummer aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="getppid">getppid - Prozessnummer (pid) des Elternprozesses ermitteln</a></h2>

<p>Unix-spezifischer Befehl.</p>

<p>Erwartet keine Parameter.</p>

<p>Gibt die Prozessnummer (PID) des Elternprozesses des aktuellen Scripts zurück.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

my $Eltern_pid = getppid();
print "Die PID des Elternprozesses lautet &lt;strong&gt;$Eltern_pid&lt;/strong&gt;\n";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel ermittelt die PID des Elternprozesses mit <code>getppid</code> und gibt HTML-Code mit der ermittelten Nummer aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="getpriority">getpriority - Text</a></h2>

<p>Unix-spezifischer Befehl. Ermittelt die aktuelle Priorität eines Prozesses, einer Prozessgruppe oder eines Benutzers. Prozesse mit höherer Priorität erhalten unter den aktuell laufenden Prozessen mehr Systemressourcen zur Ausführung.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> eine Angabe dazu, ob Sie die Priorität für einen bestimmten Prozess, eine Prozessgruppe oder einen Benutzer ermitteln wollen. Dazu übergeben Sie am besten eine der Konstanten, die in <code>resource.ph</code> definiert sind (siehe unten).<br>
<strong>2.</strong> die Nummer des Prozesses, der Prozessgruppe oder des Benutzers.</p>

<p>Gibt die Priorität des Prozesses, der Prozessgruppe oder des Benutzers als Zahl zurück. Der mögliche Wertebereich ist abhängig vom System.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

require "resource.ph";
my $Prio = getpriority(&amp;PRIO_PROCESS,0);
print "Prioritaet des aktuellen Prozesses: $Prio\n";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel ermittelt mit <code>getpriority</code> die Priorität des aktuellen Prozesses und gibt diese aus. Dazu wird mit <code>require&nbsp;"resource.ph"</code> die Kopfdatei eingebunden, die die Definition der folgenden Konstanten enthält:</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Konstante:</th>
<th>Bedeutung:</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>PRIO_PROCESS</code></td>
<td class="tabxpl">Die Priorität eines bestimmten Prozesses ermitteln, dessen Prozessnummer (oder 0 für den aktuellen Prozess) im zweiten Parameter von <code>getpriority</code> angegeben wird.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>PRIO_PGRP</code></td>
<td class="tabxpl">Die Priorität einer Prozessgruppe ermitteln, deren Nummer (oder 0 für die aktuelle Prozessgruppe) im zweiten Parameter angegeben wird.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>PRIO_USER</code></td>
<td class="tabxpl">Die Priorität eines Benutzers ermitteln, dessen Benutzernummer (UID - oder 0 für den aktuelle Benutzer) im zweiten Parameter angegeben wird.</td>
</tr>
</table>

<p>Durch Voranstellen eines <code>&amp;</code>-Zeichens können Sie eine der Konstanten wie im Beispiel gezeigt als ersten Parameter übergeben.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Diese Funktion führt zu einem schweren Fehler, wenn das System keine Prozess- bzw. Benutzerverwaltung im Sinne von Unix kennt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="kill">kill - Signal an Prozess senden</a></h2>

<p>Unix-spezifischer Befehl. Damit können Sie aus einem Perl-Script heraus Signale an andere laufende Prozesse auf dem Rechner senden und diese dadurch beeinflussen. Interessant ist dies vor allem, wenn Sie in Ihrem Perl-Script eigene Kindprozesse erzeugen (siehe <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#fork">fork</a>). Eltern- und Kindprozess können dann durch Signale kommunizieren.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> Nummer oder Name einer Konstante (siehe Tabelle weiter unten) des gewünschten Signals (oder Sie übergeben <code>0</code>, um herauszufinden, ob der Prozess mit der nachfolgend übergebenen Prozessnummer noch "am Leben" ist),<br>
<strong>2.</strong> bis <strong>n.</strong> einer oder mehrere Prozesse, an die das Signal gesendet werden soll.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

my $Kind_pid = fork();

if(kill(0,$Kind_pid)) {
  print "&lt;p&gt;Hier meldet sich ein Prozess&lt;/p&gt;\n";
  kill("KILL",$Kind_pid);
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#fork">fork</a> einen Kindprozess. Mit <code>if(kill(0,$Kind_pid))</code> wird abgefragt, ob dieser Prozess am Leben ist. Wenn ja, wird ausgegeben, dass sich ein Prozess meldet. Da im Beispiel für den Kindprozess kein eigener Perl-Code notiert ist und Kindprozesse einfach erst mal alles vom Elternprozess kopieren, würden <strong>beide</strong> Prozesse sich melden und <code>Hier meldet sich ein Prozess</code> ausgeben. Doch im Beispiel wird das verhindert, indem der Elternprozess den Kindprozess mit <code>kill("KILL",$Kind_pid)</code> tötet, bevor dieser die Anweisung mit der Ausgabe der Meldung ausführen kann. Die Meldung wird also insgesamt nur einmal ausgegeben.</p>

<p>Die folgende Tabelle enthält typische Signale mit Namen, wie Sie sie als ersten Parameter an <code>kill</code> übergeben können. Eine Garantie, dass alle hier aufgelisteten Signale auf jedem Rechner in Perl funktionieren, besteht nicht. Auch die entsprechenden Nummern wurden hier weggelassen, da sie von System zu System schwanken können. Maßgeblich ist letztendlich immer, was auf dem jeweiligen Rechner in der Datei <code>/usr/include/signal.h</code> definiert ist.</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Name:</th>
<th>Bedeutung:</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"HUP"</code></td>
<td class="tabxpl">Ereignis: Verbindung beendet</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"INT"</code></td>
<td class="tabxpl">Ereignis: allgemeine Unterbrechung</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"QUIT"</code></td>
<td class="tabxpl">Ereignis: Endekennzeichen</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"ILL"</code></td>
<td class="tabxpl">Anweisung ist illegal</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"TRAP"</code></td>
<td class="tabxpl">Anweisung ist eine "Falle"</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"ABRT"</code></td>
<td class="tabxpl">Abbruch</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"FPE"</code></td>
<td class="tabxpl">Fehler bei Fließkommaberechnung</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"KILL"</code></td>
<td class="tabxpl">Prozess "abschießen" (Unix: kill -9)</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"BUS"</code></td>
<td class="tabxpl">Bus-Übertragungsfehler</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"SEGV"</code></td>
<td class="tabxpl">Segment-Schutzverletzung im Speicher</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"PIPE"</code></td>
<td class="tabxpl">Fehler bei Pipe-Kommunikation</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"ALARM"</code></td>
<td class="tabxpl">Allgemeiner Alarm</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"TERM"</code></td>
<td class="tabxpl">Beendigung</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"USR1"</code></td>
<td class="tabxpl">Benutzerdefiniert 1</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"USR2"</code></td>
<td class="tabxpl">Benutzerdefiniert 2</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"CHLD"</code></td>
<td class="tabxpl">Signal vom Kindprozess</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"PWR"</code></td>
<td class="tabxpl">Stromausfall</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"WINCH"</code></td>
<td class="tabxpl">Fenstergröße wurde von einem Hintergrundprozess geändert</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"URG"</code></td>
<td class="tabxpl">Dringende Bedingung</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"IO"</code></td>
<td class="tabxpl">Asynchrone Ein-/Ausgabe</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"STOP"</code></td>
<td class="tabxpl">Prozess anhalten</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"TSTP"</code></td>
<td class="tabxpl">Prozess vom Terminal aus anhalten</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"CONT"</code></td>
<td class="tabxpl">Angehaltenen Prozess fortführen</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"TTIN"</code></td>
<td class="tabxpl">Prozess anhalten durch Lesen vom kontrollierenden Terminal</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"TTOU"</code></td>
<td class="tabxpl">Prozess anhalten durch Schreiben auf kontrollierendes Terminal</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"VTALARM"</code></td>
<td class="tabxpl">Virtueller Zeittaktgeber abgelaufen</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"PROF"</code></td>
<td class="tabxpl">Profil-Zeittaktgeber abgelaufen</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"XCPU"</code></td>
<td class="tabxpl">CPU-Belastungsgrenze erreicht</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>"XSFZ"</code></td>
<td class="tabxpl">Dateigrößengrenze erreicht</td>
</tr>
</table>

<h3 class="inf">Beachten Sie:</h3>

<p>Mit dem folgenden Script können Sie abfragen, welche Signale unter welchen Signalnummern auf Ihrem Server-Rechner konfiguriert sind:</p>

<pre>
#!/usr/bin/perl

use Config;

defined $Config{sig_name} || die "Kein Konfigmodul?";
foreach $name (split(' ', $Config{sig_name})) {
  $i++;
  printf "%3d) %s \t", $i, $name;
  if (($i % 5) == 0) { print "\n";  }
}
print "\n";
</pre>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="pipe">pipe - Pipe erzeugen</a></h2>

<p>Unix-spezifischer Befehl. Ermöglicht zwei Prozessen, miteinander zu kommunizieren. Eine "Pipe" (Pfeife, Röhre) ist dabei der Kommunikationskanal für die beiden Prozesse. Es gibt einen Kanal zum Schreiben von Daten und einen zum Lesen von Daten. Für beide Kanäle gibt es jeweils ein "Handle". Diese Lese- und Schreib-Handles sind ganz ähnlich den <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#allgemeines">Datei-Handles</a>. Typischerweise wird eine Pipe eröffnet, bevor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#fork">fork</a> ein Kindprozess erzeugt wird. Eltern- und Kindprozess können dann über die geöffnete Pipe Daten austauschen.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> den Namen eines Lese-Handles (frei vergebbar),<br>
<strong>2.</strong> den Namen eines Schreib-Handles (frei vergebbar)</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\n";

pipe(LESE_HANDLE, SCHREIB_HANDLE);
my $Kind_pid = fork();

if ($Kind_pid) {
 close(LESE_HANDLE);
 my $old_handle = select(SCHREIB_HANDLE);
 $| = 1;
 for (my $i=1;$i&lt;=5;$i++) {
   sleep(1);
   print SCHREIB_HANDLE "$i (gesendet vom Elternprozess)\n";
 }
 close(SCHREIB_HANDLE);
 wait;
 select($old_handle);
}
else {
 close(SCHREIB_HANDLE);
my $Speicher;
 while(defined($Speicher = &lt;LESE_HANDLE&gt;)) {
   print "Empfangen: $Speicher \n";
 }
 exit(0);
}
print "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt mit <code>pipe</code> eine Pipe. Über die beiden übergebenen Handle-Namen <code>LESE_HANDLE</code> und <code>SCHREIB_HANDLE</code> ist anschließend der Nachrichtenaustausch zwischen zwei Prozessen möglich. Mit Hilfe von <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#fork">fork</a> erzeugt das Script einen Kindprozess. Der Elternprozess läuft im <code>if</code>-Zweig des nachfolgenden Codes, der Kindprozess im <code>else</code>-Zweig. Beim Erzeugen des Kindprozesses wird alles kopiert - außer den beiden Handles aus der Pipe. Diese werden nicht kopiert, bleiben allerdings für beide Prozesse verfügbar. Deshalb muss jeder Prozess erst mal das nicht benötigte Handle mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#close">close</a> schließen. Um die Pufferung der Daten abschalten zu können, muss im <code>if</code>-Zweig außerdem mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#select">select</a> das Schreib-Handle ausgewählt werden. Alle Anweisungen sowohl des <code>if</code>- als auch des <code>else</code>-Zweiges werden insgesamt fünf mal ausgeführt. Denn in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#for">for-Schleife</a>, die von 1 bis 5 zählt, schreibt der Elternprozess, nachdem er zu Testzwecken eine Sekunde lang anhält (siehe <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sleep">sleep</a>), den aktuellen Zählerstand in das Schreib-Handle. Der Kindprozess im <code>else</code>-Zweig kann diese Daten lesen, indem er eine <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#while">while-Schleife</a> verwendet und darin das Lese-Handle ausliest. Zur Kontrolle gibt der Kindprozess aus, was er eingelesen hat.</p>

<table class="doc" width="100%"><tr><td>
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>
</td></tr></table>



<h2><a class="an" name="setpgrp">setpgrp - Prozessgruppe für Prozess bestimmen</a></h2>

<p>Unix-spezifischer Befehl. Ordnet einen Prozess einer Prozessgruppe zu.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> die Prozessnummer (PID) des gewünschten Prozesses (<code>0</code> für aktuellen Prozess übergeben),<br>
<strong>2.</strong> die Nummer der Prozessgruppe, der dieser Prozess zugeordnet werden soll  (<code>0</code> für aktuelle Prozessgruppe übergeben).</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
my $gruppe_alt = getpgrp(0);
print "Prozessgruppe alt: &lt;strong&gt;$gruppe_alt&lt;/strong&gt;&lt;br&gt;\n";

setpgrp(0,0);

my $gruppe_neu = getpgrp(0);
print "Prozessgruppe neu: &lt;strong&gt;$gruppe_neu&lt;/strong&gt;\n";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel ordnet den aktuellen Prozess der aktuellen Prozessgruppe zu und erzeugt so seine eigene Prozessgruppe. Zum Vergleich wird die aktuelle Prozessgruppe vorher und hinterher ausgelesen und jeweils ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="setpriority">setpriority - Priorität eines Prozesses oder Benutzers setzen</a></h2>

<p>Unix-spezifischer Befehl. Setzt die aktuelle Priorität eines Prozesses, einer Prozessgruppe oder eines Benutzers. Prozesse mit höherer Priorität erhalten unter den aktuell laufenden Prozessen mehr Systemressourcen zur Ausführung.<br>
Da diese Funktion "systemkritisch" ist, steht sie auf den meisten Unix-Systemen nur  Benutzern mit root-Kennung zur Verfügung.</p>

<p>Parameter wie bei <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#getpriority">getpriority</a></p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

require "resource.ph";
my $Prio = getpriority(&amp;PRIO_PROCESS,0);
$Prio += 1;
setpriority (&amp;PRIO_PROCESS, 0, $Prio);
print "Neue Prioritaet des aktuellen Prozesses: $Prio\n";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel liest mit <code>getpriority</code> die Priorität des aktuellen Prozesses ein, erhöht sie anschließend um 1 und setzt dann mit <code>setpriority</code> den neuen Wert. Zur Kontrolle gibt das Script den aktuellen Wert der Priorität aus.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Diese Funktion führt zu einem schweren Fehler, wenn das System keine Prozess- bzw. Benutzerverwaltung im Sinne von Unix kennt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="sleep">sleep - aktuellen Prozess anhalten</a></h2>

<p>Hält die Ausführung des Scripts für eine bestimmte Anzahl Sekunden an und fährt dann fort.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> die Anzahl Sekunden, die angehalten werden soll. Wenn nichts übergeben wird, wird "für ewig" angehalten.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

use strict;

sleep(10);
exec("/usr/bin/perl","aufwachen.pl");
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel wartet nach Aufruf von <code>sleep(10)</code> 10 Sekunden und führt dann mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#exec">exec</a> ein anderes Script aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="system">system - Fremdprogramm aufrufen und eigenen Prozess erhalten</a></h2>

<p>Ruft ein anderes Programm auf und ermittelt dessen Rückgabewert. Wenn Sie daran interessiert sind, welche Ausgaben das andere Programm erzeugt, sollten Sie die Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="einausgabe.htm#open">open</a> mit dem Zeichen <code>|</code> oder <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#qx">qx(...)</a> bzw. <code>`...`</code> (Backticks) benutzen.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> eine Zeichenkette oder eine Liste. Werden mehrere Parameter, also eine Liste, übergeben, wird der erste Parameter als das auszuführende Programm bzw. Kommando interpretiert, und die übrigen Parameter als Übergabeparameter für das Programm bzw. Kommando.</p>

<p>Gibt den Rückgabewert des ausgeführten Programms oder Kommandos zurück.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

(my $Datei_1, my $Datei_2) = split(/&amp;/,$ENV{'QUERY_STRING'});
my $Pfaddatei_1 = "/usr/web/daten/alt/".$Datei_1;
my $Pfaddatei_2 = "/usr/web/daten/neu/".$Datei_2;
my $Vergleich = system("cmp $Pfaddatei_1 $Pfaddatei_2 &gt;/dev/null");

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test-Ausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
if($Vergleich == 0) {
  print "&lt;tt&gt;$Pfaddatei_1&lt;/tt&gt;&lt;br&gt;und&lt;br&gt;&lt;tt&gt;$Pfaddatei_2&lt;/tt&gt;&lt;br&gt;&lt;strong&gt;sind gleich!&lt;/strong&gt;!\n";
}
else {
  print "&lt;tt&gt;$Pfaddatei_1&lt;/tt&gt;&lt;br&gt;und&lt;br&gt;&lt;tt&gt;$Pfaddatei_2&lt;/tt&gt;&lt;br&gt;&lt;strong&gt;sind verschieden!&lt;/strong&gt;!\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispielscript ermittelt den Inhalt der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../servercgi/cgi/umgebungsvariablen.htm">CGI-Umgebungsvariablen</a> <code>QUERY_STRING</code>, erwartet in dem übergebenen Parameter ein kaufmännisches Und (<code>&amp;</code>) und trennt den Teil davor und den dahinter in die Skalare <code>$Datei_1</code> und <code>$Datei_2</code>. Die beiden Daten werden als Dateien interpretiert. Ein Beispielaufruf des Scripts könnte lauten:<br>
<var>/cgi-bin/script.pl?news.htm&amp;news.htm</var><br>
Das Script hängt die beiden gleichnamigen Dateien an unterschiedliche Pfadnamen auf dem Server und erzeugt damit zwei unterschiedliche Dateipfadangaben in den Skalaren <code>$Pfaddatei_1</code> und <code>$Pfaddatei_2</code>. Mit <code>system</code> wird nun der Shell-Befehl <code>cmp</code> (unter Unix) gestartet, der zwei Dateien daraufhin überprüft, ob sie gleich sind. Dem Befehl werden die beiden Skalare mit den Pfadangaben übergeben. Eine Ausgabe soll der Befehl in diesem Fall nicht erzeugen. Deshalb wird seine Ausgabe nach <code>/dev/null</code> umgeleitet. Der Rückgabewert des <code>system</code>-Aufrufs und damit des <code>cmp</code>-Befehls wird jedoch gespeichert, nämlich im Skalar <code>$Vergleich</code>. Wenn der Wert <code>0</code> ist, sind die verglichenen Dateien gleich, andernfalls unterschiedlich. Diese Information wird zurückgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="times">times - Laufzeit des aktuellen Prozesses ermitteln</a></h2>

<p>Ermittelt die Laufzeit eines Prozesses (und, wenn vorhanden, seiner Kindprozesse) von der Erzeugung bis zum Ausführen dieses <code>times</code>-Aufrufs. Ermittelt werden für jeden Prozess jeweils zwei Werte: "user time" und "system time". Während "user time" bezeichnet, wie lange der Prozess selber gelaufen ist, gibt "system time" die Zeit an, wie lange der Prozess das Betriebssystem beschäftigt hat. Die Summe beider Zeiten ist die gesamte verbrauchte CPU-Zeit.<br>
Die gemessenen Zeiten basieren auf so genannten Uhrenticks. Die Anzahl der Uhrenticks pro Sekunde ist auf Unix-Systemen einstellbar (<code>TICKSPERSEC</code> in der Datei <code>conf.h</code>).</p>

<p>Erwartet keine Parameter.</p>

<p>Gibt eine Liste mit Laufzeiten in Sekunden (Fließkommazahlen mit Angaben zu Sekundenbruchteilen) zurück. Schema:<br>
<code>($user_time,$system_time[,$user_time_Kind,$system_time_Kind,...])</code></p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $x;
for(my $i = 0; $i &lt; 1000; $i++) {
  for(my $k = 0; $k &lt; 100; $k++) {
    $x = $i * $k / time();
  }
}

my ($Systemzeit, $Userzeit) = times();
my $CPU_Zeit = $Systemzeit + $Userzeit;

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
print "verbrauchte Systemzeit: &lt;strong&gt;$Systemzeit&lt;/strong&gt; Sekunden&lt;br&gt;\n";
print "verbrauchte Userzeit: &lt;strong&gt;$Userzeit&lt;/strong&gt; Sekunden&lt;br&gt;\n";
print "verbrauchte CPU-Zeit: &lt;strong&gt;$CPU_Zeit&lt;/strong&gt; Sekunden\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel enthält zwei verschachtelte <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#for">for-Schleifen</a>, in denen sehr viel zu rechnen ist (es werden insgesamt 100.000 Funktionsaufrufe von <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="datumzeit.htm#time">time</a> und Bruchzahlrechnungen durchgeführt). Anschließend ermittelt das Beispiel die benötigten Zeiten. Vom Aufruf der Funktion <code>times</code> werden die ersten beiden Listenelemente, also die für den aktuellen Prozess, in den Skalaren <code>$Systemzeit</code> und <code>$Userzeit</code> festgehalten. Aus der Summe dieser beiden wird noch die CPU-Zeit ermittelt und in <code>$CPU_Zeit</code> gespeichert. Zur Kontrolle gibt das Script die ermittelten Zeiten aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="wait">wait - auf das Ende eines Kindprozesses warten</a></h2>

<p>Unix-spezifischer Befehl.</p>

<p>Erwartet keine Parameter.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

#use strict;
use CGI::Carp qw(fatalsToBrowser);

$| = 1;
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
my $Kind_pid = fork();

if($Kind_pid) {
  print "&lt;p&gt;Hier ist der Elternprozess.&lt;/p&gt;\n";
  wait();
  print "&lt;p&gt;Der Kindprozess ist zuende.&lt;/p&gt;\n";
}
else {
  print "&lt;p&gt;Hier ist der Kindprozess.&lt;/p&gt;\n";
  exit(0);
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#fork">fork</a> einen Kindprozess. Mit <code>if($Kind_pid)</code> wird abgefragt, ob der Skalar <code>$Kind_pid</code> einen Wert ungleich <code>0</code> hat. Ist das der Fall, werden Anweisungen ausgeführt, die zum Elternprozess gehören. Im Beispiel wird eine Meldung ausgegeben, dass sich das Script im Elternprozess befindet. Im <code>else</code>-Zweig, in den das Script gelangt, wenn <code>Kind_pid</code> den Wert <code>0</code> hat, wird dagegen ausgegeben, dass der Kindprozess aktiv ist.<br>
Normalerweise würde erst der <code>if</code>-Zweig abgearbeitet, dann der <code>else</code>-Zweig. Durch die Anweisung <code>wait()</code> im <code>if</code>-Zweig wartet jedoch der Elternprozess auf das Ende des Kindprozesses, bevor er fortfährt. So wird vorher der <code>else</code>-Zweig abgearbeitet, und anschließend die letzte Meldung im <code>if</code>-Zweig ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="waitpid">waitpid - auf das Ende eines Kindprozesses mit bestimmter Prozessnummer (pid) warten</a></h2>

<p>Unix-spezifischer Befehl. Ruft im Gegensatz zu <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#wait">wait</a> direkt das Betriebssystem auf.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> Die Prozessnummer (PID) des gewünschten Kindprozesses.<br>
<strong>2.</strong> Schalter (Flags - siehe Tabelle weiter unten)</p>

<p>Gibt die Prozessnummer (PID) des beendeten Prozesses zurück, oder <code>-1</code>, wenn der gewünschte Kindprozess nicht oder nicht mehr existiert. Auf manchen Systemen ist auch der Rückgabewert <code>0</code> möglich - er bedeutet, dass der Kindprozess noch immer läuft (d.h. ein Timeout beim Warten überschritten wurde).</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

#use strict;
use CGI::Carp qw(fatalsToBrowser);
use POSIX;

$| = 1;
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
my $Kind_pid = fork();

if($Kind_pid) {
  print "&lt;p&gt;Hier ist der Elternprozess.&lt;/p&gt;\n";

  use POSIX ":sys_wait_h";
  do {
    my $Kind_pid = waitpid(-1,&amp;WNOHANG);
  } until $Kind_pid == -1;

  print "&lt;p&gt;Der Kindprozess ist zuende.&lt;/p&gt;\n";
}
else {
  print "&lt;p&gt;Hier ist der Kindprozess.&lt;/p&gt;\n";
  exit(0);
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel tut das gleiche wie jenes bei <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#wait">wait</a>. In diesem Fall wird jedoch mit einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#do">do-until-Schleife</a> gewartet, bis der Kindprozess zuende ist. Das ist der Fall, wenn die Funktion <code>waitpid</code> den Rückgabewert <code>-1</code> liefert, der Kindprozess also nicht mehr existiert.</p>

<p>Der Funktion <code>waitpid</code> wird im Beispiel das Flag <code>&amp;WNOHANG</code> übergeben. Die Konstanten dazu werden im <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../module/standardmodule.htm">Standardmodul</a> <code>POSIX</code> definiert. Daher ist es erforderlich, dieses Modul so wie im Beispiel mit <code>use&nbsp;POSIX&nbsp;":sys_wait_h"</code> einzubinden.<br>
Die folgende Tabelle listet die Flags auf, die Sie an der Stelle übergeben können.</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Flag:</th>
<th>Bedeutung:</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WEXITSTATUS</code></td>
<td class="tabxpl">Enthält den Rückgabewert des Kindprozesses (genauer: die untersten 8 Bit, also einen Wert bis maximal 255).</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WIFEXITED</code></td>
<td class="tabxpl">Hat den Wert <code>true</code> oder <code>1</code>, wenn der Kindprozess normal beendet wurde.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WIFSIGNALED</code></td>
<td class="tabxpl">Hat den Wert <code>true</code> oder <code>1</code>, wenn der Kindprozess durch ein unbeantwortetes Signal beendet wurde.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WIFSTOPPED</code></td>
<td class="tabxpl">Hat den Wert <code>true</code> oder <code>1</code>, wenn der Kindprozess angehalten wurde.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WNOHANG</code></td>
<td class="tabxpl">Der aufrufende Prozess wird nicht blockiert, falls der Kindprozess nicht sofort reagiert. In einem solchen Fall wird <code>waitpid()</code> sofort beendet und liefert 0 zurück.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WSTOPSIG</code></td>
<td class="tabxpl">Die Nummer des Signals, das zum Anhalten des Kindprozesses führte (das Anhalten des Kindprozesses) kann mit <code>&amp;WIFSTOPPED</code> ermittelt werden.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WTERMSIG</code></td>
<td class="tabxpl">Die Nummer des Signals, das vom Kindprozess nicht beantwortet wurde und deshalb zu dessen Beenden führte (ob dies der Fall ist, kann mit <code>&amp;WIFSIGNALED</code> ermittelt werden.</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>&amp;WUNTRACED</code></td>
<td class="tabxpl"><code>waitpid()</code> kehrt mit dem Status eines bereits gestoppten Kindprozesses zurück, dessen exit-Rückgabewert aber noch nicht abgefragt wurde.</td>
</tr>
</table>

&nbsp;

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" class="doc">
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a>
</td></tr>
<tr><td class="doc"><a href="konfiguration.htm"><img src="../../src/next.gif" width="10" height="10" border="0" hspace="10" alt="weiter"></a></td>
<td width="100%"><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="konfiguration.htm">Funktionen für Informationen aus Konfigurationsdateien</a>
</td></tr>
<tr>
<td class="doc"><a href="dateiverwaltung.htm"><img src="../../src/prev.gif" width="10" height="10" border="0" hspace="10" alt="zurück"></a></td>
<td><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm">Funktionen für Datei- und Verzeichnis-Management</a>
</td>
</tr>
<tr><td colspan="2" class="doc">&nbsp;</td>
</tr>
<tr>
<td colspan="2" class="nav"><a class="an" name="bottom"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Funktionen</a></td>
</tr>
</table>

<p>&copy; 2007 <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../editorial/impressum.htm">Impressum</a></p>

</body>
</html>
