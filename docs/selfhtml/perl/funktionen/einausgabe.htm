<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>SELFHTML: Perl / Funktionsreferenz / Funktionen für Ein-/Ausgabe und Lesen/Schreiben von Daten</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"     content="Welche Funktionen es in Perl gibt, um eingegebene Daten oder Daten aus Dateien zu lesen und Daten am Bildschirm auszugeben oder in eine Datei zu schreiben.">
<meta name="keywords"        content="SELFHTML, Perl, Funktionen, Perl-Funktionen, Dateien, Verzeichnisse, Dateifunktionen, Verzeichnisfunktionen, Ein-/Ausgabefunktionen, Eingabekanal, Ausgabekanal, Dateihandle, Dateizeiger, STDIN, STDOUT, STDERR, binmode, close, closedir, eof, fileno, flock, format, getc, open, opendir, print, printf, read, readdir, rewinddir, seek, seekdir, select, sysopen, sysread, sysseek, syswrite, tell, telldir, write">
<meta name="author"         content="Redaktion SELFHTML, selfhtml81@selfhtml.org">
<meta name="robots"         content="noindex, nofollow">
<meta name="DC.Publisher"   content="SELFHTML e. V.">
<meta name="DC.Date"        content="2005-11-16T01:48:05+01:00">
<meta name="DC.Identifier"  content="http://de.selfhtml.org/perl/funktionen/einausgabe.htm">
<meta name="DC.Language"    content="de">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.created" content="2001-10-27T08:00+01:00">
<meta name="SELF.Pagetype"  content="page">
<link rel="alternate" type="application/atom+xml" title="SELFHTML-Weblog (Atom, gesamt)" href="http://aktuell.de.selfhtml.org/weblog/atom-feed">
<link rel="alternate" type="application/rss+xml" title="SELFHTML-Weblog (RSS, Auszüge)" href="http://aktuell.de.selfhtml.org/weblog/rss-feed">
<link rel="shortcut icon" type="image/x-icon" href="../../src/favicon.ico">
<link rel="author" title="Impressum" href="../../editorial/impressum.htm">
<link rel="contents" title="Inhaltsverzeichnis" href="../../navigation/inhalt.htm">
<link rel="index" title="Stichwortverzeichnis" href="../../navigation/stichwort.htm">
<link rel="search" title="Suche" href="../../navigation/suche/index.htm">
<link rel="help" title="Hilfe" href="../../editorial/index.htm">
<link rel="copyright" title="Urheberrecht" href="../../editorial/copyright.htm">
<link rel="top" title="SELFHTML" href="../../index.htm">
<link rel="up" title="Perl-Funktionen" href="index.htm">
<link rel="next" title="Funktionen für Datei- und Verzeichnis-Management" href="dateiverwaltung.htm">
<link rel="prev" title="Funktionen für Datum und Uhrzeit" href="datumzeit.htm">
<link rel="first" title="Funktionen für Zeichenketten" href="zeichenketten.htm">
<link rel="last" title="Funktionen für Module und Packages" href="module.htm">
</head>
<body>

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td colspan="2" class="nav"><a class="an" name="top"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Funktionen</a></td>
</tr>
<tr>
<td class="doc" width="110"><a href="../../index.htm"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></a></td>
<td class="docbot" width="100%"><h1 class="ph1">Funktionen für Ein-/Ausgabe und Lesen/Schreiben von Daten</h1></td>
</tr>
<tr>
<td class="doctop">
<img src="../../src/dokx.gif" width="30" height="20" vspace="6" alt="Informationsseite">
</td>
<td valign="top" nowrap="nowrap">
<p>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#allgemeines">Allgemeines zu diesen Funktionen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#binmode">binmode</a> - Ein-/Ausgabekanal binär behandeln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#close">close</a> - Ein-/Ausgabekanal schließen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#closedir">closedir</a> - Verzeichnis schließen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#eof">eof</a> - auf Dateiende prüfen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#fileno">fileno</a> - Nummer eines geöffneten Ein-/Ausgabekanal<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#flock">flock</a> - geöffnete Datei vor Zugriffen schützen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#format">format</a> - Daten vor dem Ausgeben formatieren<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#getc">getc</a> - nächstes Zeichen lesen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> - Ein-/Ausgabekanal öffnen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#opendir">opendir</a> - Verzeichnis öffnen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#print">print</a> - Daten ausgeben<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#printf">printf</a> - Daten formatiert ausgeben<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#read">read</a> - bestimmte Anzahl Zeichen lesen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#readdir">readdir</a> - Verzeichniseinträge ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#rewinddir">rewinddir</a> - auf ersten Verzeichniseintrag positionieren<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#seek">seek</a> - Dateizeiger positionieren<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#seekdir">seekdir</a> - Verzeichniszeiger positionieren<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#select">select</a> - Ein-/Ausgabekanal auswählen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sysopen">sysopen</a> - Datei systemnah öffnen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sysread">sysread</a> - bestimmte Anzahl Zeichen systemnah lesen<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sysread">sysseek</a> - Dateizeiger systemnah positionieren<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#syswrite">syswrite</a> - bestimmte Anzahl Zeichen systemnah schreiben<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#tell">tell</a> - Position des Dateizeigers ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#telldir">telldir</a> - Position des Verzeichniszeigers ermitteln<br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#write">write</a> - formatierte Daten schreiben
</p>
</td>
</tr><tr><td colspan="2" class="doc">&nbsp;<a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>&nbsp;</td></tr>
</table>



<h2><a class="an" name="allgemeines">Allgemeines zu diesen Funktionen</a></h2>

<p>Zu den Grundlagen der Unix-Philosophie (Perl entstand in der Unix-Welt) gehört, dass jedem Prozess drei <strong>Standardkanäle</strong> zugeordnet werden (können). Es gibt grundsätzlich einen voreingestellten <strong>Eingabekanal</strong> <code>STDIN</code> - <i>standard input</i> -, einen voreingestellten <strong>Ausgabekanal</strong> <code>STDOUT</code> - <i>standard output</i> - und einen voreingestellten <strong>Kanal für Fehlermeldungen</strong> <code>STDERR</code> - <i>standard error</i>. <code>STDIN</code> ist normalerweise mit der Tastatur verbunden oder aber mit einem anderen Gerät, beispielsweise einer Netzwerkschnittstelle, <code>STDOUT</code> und <code>STDERR</code> mit dem Terminal, also beispielsweise dem Monitor. Solange man nur etwas hineinschreibt oder daraus liest, verhalten sich diese Standardkanäle wie normale Dateien. Der große Vorteil besteht darin, dass die von ihnen übermittelten oder gespeicherten Daten umgelenkt werden können, sodass die Ausgabe von <code>STDOUT</code> auf dem Bildschirm erscheinen und der Inhalt von <code>STDERR</code> gleichzeitig in eine Protokolldatei (log) geschrieben werden kann. Ob diese Kanäle einer Software zur Verfügung stehen, ist davon abhängig, ob die Software-Entwickler sie vorgesehen haben.</p>

<p>Für Perl gibt es alle drei Standardkanäle. Ein Perl-Script kann also von <code>STDIN</code> Daten lesen und auf <code>STDOUT</code> Daten ausgeben. Bei Verwendung eines Webservers mit CGI-Schnittstelle werden die Daten aus <code>STDOUT</code> nun in eine spezielle Datei umgeleitet, die vom Webserver an den Web-Browser weitergegeben wird. Dasselbe geschieht mit den Daten, die der Webserver gemeinsam mit einer Browser-Anfrage erhält - der Webserver leitet sie in <strong>seinen</strong> Ausgabekanal <code>STDOUT</code>, womit diese Daten (z.B. Formulardaten) dem über ein CGI-Script aufgerufenen Perl-Interpreter bereitgestellt werden können.</p>

<p>Die drei Kanäle stellen für Perl so genannte <strong>Handles</strong> dar. Neben diesen Standardkanälen zur Ein- und Ausgabe können Sie als Programmierer eigene Kanäle zur Ein- und Ausgabe öffnen. Dabei vergeben Sie auch eigene Namen für die Handles. Das ist zum Beispiel erforderlich, wenn Sie Daten statt von der Tastatureingabe aus einer Datei lesen oder statt auf den Bildschirm in eine Datei schreiben wollen. Um eine Datei lesen oder schreiben zu können, erzeugen Sie also einfach ein Datei-Handle. Dies passiert beim Öffnen einer Datei - hierzu dient vor allem die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a>. Nachdem Sie eine Datei geöffnet und dabei ein Datei-Handle vergeben haben, haben Sie über das Datei-Handle Zugriff auf die Datei.</p>

<p>Perl stellt diverse Funktionen zur Verfügung, um auf Dateien lesend und schreibend zugreifen zu können. Zu einem Datei-Handle gehört ferner ein Dateizeiger. Der Dateizeiger speichert beim Lesen und Schreiben die aktuelle Byteposition innerhalb der Datei. Sie können die Position des Dateizeigers ermitteln und den Dateizeiger zum Beispiel bei Dateien mit bestimmten Dateiformaten an eine andere Position setzen. Auf diese Weise können Sie Schreib- und Lesevorgänge genau steuern.</p>

<p>Für Verzeichnisse - Ordner eines Dateisystems - gibt es eigene Funktionen. Ein Verzeichnis können Sie ebenfalls öffnen. Dann können Sie Einträge des Verzeichnisses lesen, zum Beispiel, um zu ermitteln, ob in dem Verzeichnis Dateien eines bestimmten Typs vorkommen. Verzeichnisfunktionen erkennen Sie an dem <code>dir</code> im Namen. So sind etwa <code>open</code> oder <code>seek</code> Dateifunktionen, während <code>opendir</code> und <code>seekdir</code> Verzeichnisfunktionen sind.</p>

<p>Neben den normalen Funktionen zum Lesen und Schreiben von Dateien gibt es auch systemnahe Varianten der entsprechenden Funktionen. Benutzen Sie solche Funktionen jedoch nur, wenn Sie einen besonderen Grund dazu haben! Diese Art von Funktionen erkennen Sie am <code>sys</code> im Namen. Während beispielsweise <code>read</code> eine normale Lesefunktion ist, ist <code>sysread</code> die entsprechende systemnahe Variante dieser Funktion.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Perl-Scripts, die Sie als CGI-Scripts einsetzen, können mit Hilfe dieser Funktionen Dateien auf dem Server-Rechner lesen und schreiben. Auf das Dateisystem eines entfernten Client-Rechners, dessen dort laufender Browser vom Webserver Daten angefordert hat, haben Sie mit diesen Funktionen <strong>keinen</strong> Zugriff (auch wenn das manchmal von einigen weniger erfahrenen Perl-Bastlern gewünscht und an manchen Stellen diskutiert wird)!</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="binmode">binmode - Datei binär behandeln</a></h2>

<p>Wichtig, um Binärdateien (z.B. Grafikdateien) korrekt einzulesen oder zurückzuschreiben, wenn das Betriebssystem, unter dem das Perl-Script läuft, zwischen Text- und Binärdateien unterscheidet. Unix macht diese Unterscheidung nicht, die Funktion <code>binmode</code> ist deshalb für Perl-Scripts unter Unix bedeutungslos. Windows dagegen unterscheidet zwischen Text- und Binärmodus.<br>
Bei nicht binären Dateien, also bei Klartextdateien, werden die zwei aufeinander folgenden Steuerzeichen CR (Carriage Return) und LF (Line Feed) beim Lesen der Datei unter Windows automatisch zu einem LF zusammengefasst. Beim Schreiben einer Textdatei wird jedes LF automatisch wieder in zwei Zeichen CR und LF umgewandelt.<br>
Durch Aufruf der Funktion <code>binmode</code> schalten Sie diesen Automatismus aus. So verhindern Sie, dass der Automatismus an Stellen greift, an denen er nicht greifen soll, etwa, wenn Sie numerisch gespeicherte Daten einlesen, die zufällig zwei Bytes in Folge enthalten können, deren Werte den Zeichenwerten für CR und LF entsprechen.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Handle eines Ein-/Ausgabekanals.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $AnzahlBytes = -s "/usr/web/src/ship.gif";
my $Speicher;
open(GRAFIK, "&lt;/usr/web/src/ship.gif");
binmode(GRAFIK);
my $geleseneBytes = read(GRAFIK, $Speicher, $AnzahlBytes);
close(GRAFIK);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
print "&lt;h1&gt;der Inhalt der Grafikdatei als Zeichensalat:&lt;/h1&gt;\n";
print "&lt;p&gt;&lt;tt&gt;$Speicher&lt;/tt&gt;&lt;/p&gt;";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel liest eine GIF-Grafikdatei binär ein. Dazu wird die Datei mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> geöffnet. Anschließend wird die Funktion <code>binmode</code> mit dem Datei-Handle der geöffneten Datei (<code>GRAFIK</code>) aufgerufen. Danach wird die Datei mit der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#read">read</a> eingelesen.<br>
Zu Testzwecken wird HTML-Code, der den eingelesenen Inhalt der Grafik als Zeichensalat darstellt, wieder ausgegeben. Der eingelesene Inhalt befindet sich nach dem Einlesen im Skalar <code>$Speicher</code>.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Weitere Einzelheiten zum Einlesen binärer Dateien werden bei der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#read">read</a> beschrieben.</p>

<p>Der verwendete Ausdruck <code>-s</code> zum Feststellen der Dateigröße, gespeichert in <code>$AnzahlBytes</code>, gehört zu einer Reihe ähnlicher Ausdrücke, die das Ermitteln von Eigenschaften einer Datei erlauben. Weitere Einzelheiten dazu im Abschnitt über <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm#dateitest">Dateitestoperatoren</a>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="close">close - Datei schließen</a></h2>

<p>Schließt eine Datei, die zuvor mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> geöffnet wurde.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Handle eines geöffneten Ein-/Ausgabekanals, der geschlossen werden soll.</p>

<h3 class="xmp">Beispiel mit Erläuterung:</h3>

<p>Ein vollständiges Beispiel mit Erläuterung der beiden zusammenhängenden Funktionen <code>open</code> und <code>close</code> wird bei der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> behandelt.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Wenn Sie eine zuvor geöffnete Datei nicht explizit mit <code>close</code> schließen, wird die Datei von Perl beim Beenden des Scripts automatisch geschlossen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="closedir">closedir - Verzeichnis schließen</a></h2>

<p>Schließt ein Verzeichnishandle, das zuvor mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#opendir">opendir</a> geöffnet wurde.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Verzeichnishandle.</p>

<h3 class="xmp">Beispiel mit Erläuterung:</h3>

<p>Ein vollständiges Beispiel mit Erläuterung der drei zusammenhängenden Funktionen <code>opendir</code>, <code>readdir</code> und <code>closedir</code> wird bei der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#opendir">opendir</a> behandelt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="eof">eof - auf Dateiende prüfen</a></h2>

<p>Fragt eine geöffnete Datei daraufhin ab, ob der Dateizeiger das Dateiende erreicht hat.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Handle des Ein-/Ausgabekanals.</p>

<p>Gibt <code>true</code> zurück, wenn das Dateiende erreicht ist, und <code>false</code>, wenn es nicht erreicht ist.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $max = 100000;
my $i = 0;
my $Status = 0;

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
open(DATEI, "&lt;/usr/chatlog/lastnight.txt");
while(1) {
 if(eof(DATEI)) {
   $Status = 1;
   last;
 }
 if($i &gt; $max) {
   $Status = 2;
   last;
 }
 getc(DATEI);
 $i++;
}
close(DATEI);
if($Status == 1) {
 print "&lt;p&gt;Datei war kleiner als $max Bytes, daher ganz gelesen&lt;/p&gt;\n";
}
if($Status == 2) {
 print "&lt;p&gt;Datei war zu groß, daher nur $max Bytes gelesen&lt;/p&gt;\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt HTML-Code. Dabei wird mit der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> eine Textdatei <code>/usr/chatlog/lastnight.txt</code> geöffnet. Die geöffnete Datei wird in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#while">while-Schleife</a> mit der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#getc">getc</a> Zeichen für Zeichen eingelesen. Da die Schleifenbedingung <code>(1)</code> immer wahr ist, werden innerhalb der Schleife Abbruchbedingungen formuliert. Wenn das Dateiende erreicht ist - <code>if(eof(DATEI))</code> - wird der Skalar <code>$Status</code> auf 1 gesetzt und die Schleife durch <code>last</code> beendet.<br>
Die Schleife wird aber auch dann beendet, wenn mehr Zeichen eingelesen wurden, als in <code>$max</code> definiert sind. In diesem Fall wird <code>$Status</code> auf 2 gesetzt.<br>
Durch Abfragen des Wertes von <code>$Status</code> kann nach Beenden der Schleife festgestellt werden, was die Schleife zum Abbruch gebracht hat. Abhängig davon wird ein entsprechender Satz ausgegeben.</p>

<h3 class="inf">Beachten Sie:</h3>

<p><code>if(eof(DATEI))</code> ("wenn Dateiende erreicht") oder <code>while(! eof(DATEI))</code> ("solange Dateiende nicht erreicht") sind typische Formulierungen beim Einsatz der Funktion <code>eof</code>. Sinnvoll sind solche Abfragen und Schleifenbedingungen vor allem dann, wenn Sie Dateien zeichenweise (mit der Funktion <code>getc</code>) oder blockweise (mit der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#read">read</a>) einlesen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="fileno">fileno - Nummer einer geöffneten Datei</a></h2>

<p>Jeder geöffnete Ein-/Ausgabekanal hat intern eine Nummer, auch die nicht selbst geöffneten Ausgabekanäle <code>STDIN</code>, <code>STDOUT</code> und <code>STDERR</code>. Mit dieser Funktion können Sie die interne Nummer eines Ein-/Ausgabekanals ermitteln.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Handle eines Ein-/Ausgabekanals.</p>

<p>Gibt die interne Nummer des Ein-/Ausgabekanals zurück.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
open(DATEI, "&lt;/usr/texte/wichtig.txt");
my $Datei = fileno(DATEI);
close(DATEI);
my $Eingabe = fileno(STDIN);
my $Ausgabe = fileno(STDOUT);
my $Fehler = fileno(STDERR);
print "Eingabe= $Eingabe, Ausgabe = $Ausgabe, Fehler = $Fehler, Datei = $Datei\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt HTML-Code für den aufrufenden Browser. Dabei wird mit der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> eine Textdatei <code>/usr/texte/wichtig.txt</code> geöffnet. Mit <code>fileno(DATEI)</code> wird die interne Nummer des Handles dieser Datei ermittelt und in einem Skalar <code>$Datei</code> gespeichert. Ebenso werden die internen Nummern der drei Standardkanäle ermittelt und in entsprechenden Skalaren gespeichert. Schließlich gibt das Script die ermittelten Nummern aus.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="flock">flock - geöffnete Datei vor Zugriffen schützen</a></h2>

<p>Regelt, wie andere Prozesse auf eine Datei zugreifen können, während der aktuelle Prozess die Datei geöffnet hält. Bei CGI-Scripts kann dies <strong>sehr wichtig</strong> sein. Denn während ein vom Browser eines Anwenders aufgerufenes Script seine Arbeit verrichtet, kann ja bereits ein weiterer Browser eines anderen Anwenders das selbe Script aufrufen. Die beiden Prozesse arbeiten dann im Arbeitsspeicher des Server-Rechners zwar unabhängig voneinander, führen aber nun mal den gleichen Code aus und greifen auf die gleichen Dateien zu. Damit nicht ein anderer Prozess Daten löscht, die der aktuelle Prozess gerade geschrieben hat, ist es dem Prozess zum Beispiel möglich, die Datei vor Zugriffen zu schützen.</p>

<p><strong>Wichtig:</strong> Bei Betriebssystemen, die intern kein <code>flock</code> implementiert haben, führt die Anwendung dieser Funktion zu einem Fehler, so etwa auch bei Windows 95/98 (sofern Ihr Perl-Script in einer solchen Systemumgebung laufen sollte).</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Handle der geöffneten Datei.<br>
<strong>2. </strong>die Nummer einer Sperroption oder eine Konstante - erlaubt sind die Nummern <code>1</code>, <code>2</code>, <code>4</code> und <code>8</code> oder die Konstanten <code>LOCK_SH</code>, <code>LOCK_EX</code>,  <code>LOCK_NB</code> und <code>LOCK_UN</code>.</p>
<ul><li>Nummer <code>1</code> oder Konstante <code>LOCK_SH</code> bedeutet <i>shared</i> (Datei mit anderen Prozessen teilen, zum Beispiel, wenn ein Prozess, der lesend auf eine Datei zugreift, andere Prozesse nicht stören soll, die gleichzeitig diese Datei lesen),</li>
<li>Nummer <code>2</code> oder Konstante <code>LOCK_EX</code> bedeutet <i>exclusive</i> (keinem anderen Prozess irgendeinen Zugriff auf die Datei erlauben),</li>
<li>Nummer <code>8</code> oder Konstante <code>LOCK_UN</code> bedeutet <i>unlock</i> (Zugriffsschutz ausdrücklich wieder aufheben).</li>
<li>Nummer <code>4</code> oder Konstante <code>LOCK_NB</code> bedeutet <i>non-blocking</i> (nur in Verbindung mit <code>1</code> oder <code>2</code> bzw. <code>LOCK_SH</code> oder <code>LOCK_EX</code> erlaubt und beendet den Zugriffsversuch auf die Datei sofort statt zu warten, bis ein Zugriff möglich ist).</li>
</ul>

<p>Die Konstanten können Sie nur verwenden, wenn Sie das Modul <code>Fcntl</code> einbinden (siehe Beispiel weiter unten).</p>

<p>Gibt <code>true</code> zurück, wenn der Vorgang erfolgreich war, und <code>false</code>, wenn er nicht erfolgreich war.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);
use Fcntl ':flock';
$| = 1;

open(DATENDATEI, "&lt;/db/daten.csv");
flock(DATENDATEI, LOCK_EX);

# angenommen, hier passiert etwas Zeitaufwändiges,
# und derweil versucht ein anderer Prozess auf die gleiche Datei zuzugreifen
# dann greift die Sperre

flock(DATENDATEI, LOCK_UN);
close(DATENDATEI);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Wenn Sie anstelle der Nummern lieber die Konstanten verwenden möchten, müssen Sie zuerst einen Befehl zum Einbinden des Sperrmoduls notieren, etwa in der obigen Form:<br>
<code>use Fcntl ':flock';</code></p>

<p>Nachdem Sie eine Datei erfolgreich geöffnet und ein entsprechendes Datei-Handle für den Zugriff auf die Datei haben, können Sie die Sperroptionen für die Datei festlegen. Im Beispiel geschieht das nach dem Aufruf der <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a>-Funktion mit Hilfe der Anweisung <code>flock(DATENDATEI, LOCK_EX);</code></p>

<p>Dabei ist <code>DATENDATEI</code> das Datei-Handle, und <code>LOCK_EX</code> die Angabe zur gewünschten Sperroption. Im Beispiel wird die Datei exklusiv gesperrt. Solange die Sperre innerhalb des Scripts nicht aufgehoben oder die Datei geschlossen wird, kann kein anderer Prozess, der <code>flock</code> beachtet, gleichzeitig in die Datei schreiben.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Die beiden Befehle<br>
<code>flock(DATENDATEI, LOCK_UN);<br>
close(DATENDATEI);</code><br>
dienen im obigen Beispiel nur zum besseren Verständnis. Das explizite Beenden der Sperre ist eigentlich überflüssig, wenn es erst beim Schließen der Datei mit der <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#close">close</a>-Funktion erfolgen soll. Denn <code>close</code> hebt zugleich jede Angabe zur Dateisperre auf.</p>

<p>Die Anweisung <code>$| = 1;</code> im obigen Beispiel dient zum Ausschalten der gepufferten Ausgabe (vgl. dazu <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/vordefiniert.htm">vordefinierte Variablen</a> in Perl). Dies ist beim Sperren von Dateien zu empfehlen. Denn andernfalls kann es passieren, dass durch gepufferte und verzögerte Ausgabe das Schreiben von Daten erst dann stattfindet, wenn die Sperre bereits aufgehoben ist. Dies würde den ganzen Zweck der Sperre überflüssig machen.</p>

<p>Wenn Sie mit der Sperroption <code>4</code> bzw. <code>LOCK_NB</code> arbeiten möchten, müssen Sie diese Option durch eine bitweise Oder-Verknüpfung mit einer Option zum Sperren verknüpfen. Beispiele:<br>
<code>flock(DATENDATEI, LOCK_EX | LOCK_NB);<br>
flock(DATENDATEI, LOCK_SH | LOCK_NB);</code></p>

<p><strong>Wichtig:</strong> <code>flock</code> erzwingt keine Sperre, sondern hat lediglich empfehlenden Charakter. Der Zugriffsschutz ist nur dann wirksam, wenn alle Prozesse, die auf die Datei zugreifen, <code>flock</code> beachten.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="format">format - Daten vor dem Ausgeben formatieren</a></h2>

<p>Dies ist eine mächtige Funktion, um Daten vor der Ausgabe an einem zeichenorientierten Ausgabegerät wie Textbildschirm oder Zeilendrucker ansprechend zu formatieren. Im Zusammenhang mit CGI-Scripts findet diese Funktion kaum Verwendung, da die wenigsten Browser zeichenorientiert arbeiten.</p>

<h3 class="xmp">Beispiel 1:</h3>
<pre>
#!/usr/bin/perl -w

use strict;

my $Zuname = "Hummel";
my $Vorname = "Hilde";
my $Wohnort = "Hammelbach";

format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  aus @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$Vorname, $Zuname, $Wohnort
.
write;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>In Beispiel 1 wird folgendes ausgegeben:</p>
<pre>
Hilde           Hummel          aus Hammelbach
</pre>

<p>Die Formatierung der Ausgabe geschieht durch das <code>format</code>-Konstrukt. Die eigentliche Ausgabe geschieht durch den anschließenden Befehl <code>write</code>.</p>

<p>Bei dem Konstrukt zur Formatierung geben Sie hinter <code>format</code> einen Namen für das Format an, normalerweise den Namen des gewünschten Datei-Handles. Der Name ist jedoch in Wirklichkeit kein Datei-Handle, er sieht nur so aus. Das Default-Format für ein Datei-Handle hat lediglich den gleichen Namen wie das Datei-Handle. Im obigen Beispiel wird der Formatname <code>STDOUT</code> angegeben, weil auf die Standardausgabe <code>STDOUT</code> geschrieben werden soll. Hinter dem Formatnamen folgt ein Gleichheitszeichen.<br>
Die Zeilen, die danach folgen, bestehen immer aus Zeilenpaaren. Zuerst werden eine oder mehrere <strong>Formatierzeile(n)</strong> notiert, und anschließend eine <strong>Argumentzeile</strong>. In der Formatierzeile definieren Sie mit Hilfe spezieller Zeichensymbole das Ausgabeformat für bestimmte Felder, und in der Argumentzeile nennen Sie die Variablen, die in den entsprechenden Feldern darüber ausgegeben werden.<br>
Mit einem Punkt (<strong>.</strong>) in einer eigenen Zeile wird das Format-Konstrukt beendet.</p>

<p>Für die Formatierzeile gibt es folgende Regeln:</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Anweisung</th>
<th>Bedeutung</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>@&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code></td>
<td class="tabxpl">Feld linksbündig ausrichten. Die Anzahl der <code>&lt;</code>-Zeichen bestimmt die Feldbreite in Zeichen. Längere Inhalte werden bei der Ausgabe links abgeschnitten.
</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>@&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></td>
<td class="tabxpl">Feld rechtsbündig ausrichten. Die Anzahl der <code>&gt;</code>-Zeichen bestimmt die Feldbreite in Zeichen. Längere Inhalte werden bei der Ausgabe rechts abgeschnitten.
</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>@||||||</code></td>
<td class="tabxpl">Feld zentriert ausrichten. Die Anzahl der <code>|</code>-Zeichen bestimmt die Feldbreite in Zeichen. Längere Inhalte werden bei der Ausgabe rechts abgeschnitten.
</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>@#.##</code></td>
<td class="tabxpl">Feld als Zahl mit Dezimalzeichen formatieren. Als Dezimalzeichen ist nur der Punkt erlaubt. Die Anzahl der <code>#</code>-Zeichen vor dem Punkt bestimmt die Vorkomma-Feldbreite, kleinere Zahlen werden dabei rechts zum Dezimalzeichen hin ausgerichtet. Die Anzahl der <code>#</code>-Zeichen hinter dem Punkt bestimmt die Nachkomma-Feldbreite. Bei weniger Nachkommaziffern als angegebenen Zeichen werden Nullen angehängt.
</td>
</tr>
</table>

<p>Zusätzlich zu diesen Formatiermöglichkeiten gibt es einige <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/vordefiniert.htm">vordefinierte Variablen</a>, die Sie für die Ausgabe benutzen können.</p>

<h3 class="xmp">Beispiel 2:</h3>
<pre>
#!/usr/bin/perl -w

use strict;

format STDOUT =
Seite @&lt;&lt;    @&gt;&gt;&gt;&gt;&gt;&gt;&gt;
$%, $~
.
write;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>In Beispiel 2 wird folgendes ausgegeben:</p>
<pre>
Seite 0        STDOUT
</pre>

<p>Die Formatierung der Ausgabe geschieht durch ein <code>format</code>-Konstrukt. Anstelle gewöhnlicher Variablen werden jedoch spezielle vordefinierte Variablen ausgegeben. Folgende spezielle Variablen sind möglich:</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Anweisung</th>
<th>Bedeutung</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$%</code></td>
<td class="tabxpl">aktuelle Seitennummer</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$=</code></td>
<td class="tabxpl">Anzahl Zeilen pro Seite</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$-</code></td>
<td class="tabxpl">Anzahl übrig gebliebener Zeilen auf der aktuellen Seite</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$~</code></td>
<td class="tabxpl">Name des aktuellen Formats - per Voreinstellung der Name des benutzten Datei-Handles</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$^</code></td>
<td class="tabxpl">Name des aktuellen Kopfseitenformats - per Voreinstellung der Name aktuellen Formats plus der Zeichenfolge <code>_TOP</code></td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$:</code></td>
<td class="tabxpl">Trennzeichen(folge) bei mehrzeiligen Einträgen</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>$^L</code></td>
<td class="tabxpl">Trennzeichen(folge) für Seitentrenner</td>
</tr>
</table>

<p>Für längere Ausgaben, zum Beispiel von Dateien, können Sie auch Kopfzeilen benutzen. Das folgende Beispiel zeigt, wie Sie eine Datei ausgeben können:</p>

<h3 class="xmp">Beispiel 3:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use vars qw($Zeile);

open(DATEI,"&lt;/usr/texte/daten.txt");

format STDOUT_TOP =
****************************************************
Seite @>>
$%
****************************************************
.

format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$Zeile;
.

while(&lt;DATEI&gt;) {
  chomp $_;
  $Zeile = $_;
  write;
}
close(DATEI);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>In Beispiel 3 werden von einer angenommenen Textdatei von jeder Zeile die ersten 15 Zeichen ausgegeben.</p>

<p>Die Formatierung der Ausgabe in Beispiel 3 geschieht durch zwei <code>format</code>-Konstrukte. Die beiden Konstrukte erhalten die Namen <code>STDOUT_TOP</code> und <code>STDOUT</code>. Durch die Zeichenfolge <code>_TOP</code> am Ende eines Formatnamens teilen Sie Perl mit, dass es sich um eine Kopfzeilendefinition handelt. Im Beispiel wird die Kopfzeile mit zwei aus Sternchen bestehenden Linien und die dazwischenstehende aktuelle Seitenzahl formatiert.</p>

<p>Im weiteren Verlauf von Beispiel 3 sehen Sie, wie die Datei in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#while">while-Schleife</a> zeilenweise in eine Variable namens <code>$Zeile</code> eingelesen wird. Diese Variable wird - ebenfalls in der Schleife - jeweils ausgegeben. Für die Formatierung der Ausgabe ist das Format-Konstrukt mit dem Namen <code>STDOUT</code> verantwortlich. Dort wird die Variable <code>$Zeile</code> in der gewünschten Form ausgegeben.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Die Variable <code>$Zeile</code> muss im obigen Beispiel global deklariert werden. Daher die Anweisung <code>use vars qw($Zeile);</code> zu Beginn.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="getc">getc - nächstes Zeichen lesen</a></h2>

<p>Liest ein Zeichen aus einer zuvor geöffneten Datei und positioniert den Dateizeiger um ein Zeichen weiter.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Datei-Handle.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\n";
open(DATEI, "&lt;/usr/texte/wichtig.txt");
my $Bytes = 0;
while(! eof(DATEI)) {
 my $Zeichen = getc(DATEI);
 print "$Zeichen";
 $Bytes++;
}
close(DATEI);
print "&lt;/pre&gt;&lt;strong&gt;$Bytes Zeichen gelesen!&lt;/strong&gt;\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel erzeugt HTML-Code für den aufrufenden Web-Browser. Dabei wird auch mit der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#open">open</a> eine Textdatei <code>/usr/texte/wichtig.txt</code> geöffnet. Die geöffnete Datei wird in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#while">while-Schleife</a> Zeichen für Zeichen eingelesen, bis das Dateiende, das mit der Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#eof">eof</a> abgefragt wird, erreicht ist. Die eingelesenen Zeichen werden ausgegeben. Außerdem wird der Skalar <code>$Bytes</code> bei jedem eingelesenen Zeichen um 1 erhöht. Auf diese Weise wird nebenbei die Anzahl der eingelesenen Zeichen ermittelt. Am Ende wird diese Anzahl mit ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="open">open - Datei öffnen</a></h2>

<p>Öffnet eine Datei zum Lesen und/oder Schreiben oder auch zum Ausführen. Auch Binärdateien werden mit dieser Funktion geöffnet.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> den Namen des Datei-Handles (frei wählbar), und<br>
<strong>2.</strong> den Pfadnamen der zu öffnenden Datei, entweder als absolute Pfadangabe oder als relative Pfadangabe aus Sicht des aktuellen Verzeichnisses (wenn das aktuelle Verzeichnis unbekannt ist, empfiehlt es sich, mit Hilfe der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm#chdir">chdir</a> in ein bestimmtes Verzeichnis zu wechseln). Als Trennzeichen für Verzeichnispfade können Sie den einfachen Schrägstrich verwenden, auch wenn das Script auf einem Windows-Rechner laufen soll. Perl setzt diese Syntax je nach Installationsumgebung intern um.<br>Für den Pfadnamen der zu öffnenden Datei können Sie auch Variablen einsetzen, URIs dürfen Sie jedoch nicht angeben!</p>

<p>Unmittelbar vor dem (Pfad)namen der zu öffnenden Datei notieren Sie mit Hilfe der Zeichen <code>&lt;</code>, <code>&gt;</code> oder <code>|</code> außerdem, wie die Datei geöffnet werden soll. Wenn Sie keine dieser Angaben machen, wird die Datei nur zum Lesen geöffnet. Folgende Angaben sind erlaubt:<br>
<code>&lt;datei.dat</code> bedeutet: Datei <code>datei.dat</code> nur zum Lesen öffnen. Die Datei muss existieren, ansonsten gibt es einen Fehler.<br>
<code>&gt;datei.dat</code> bedeutet: Datei <code>datei.dat</code> zum Schreiben von Daten öffnen. Wenn die Datei bereits existiert, wird ihr bisheriger Inhalt überschrieben. Wenn die Datei noch nicht existiert, wird sie automatisch angelegt.<br>
<code>&gt;&gt;datei.dat</code> bedeutet: Datei <code>datei.dat</code> zum Schreiben von Daten öffnen. Wenn die Datei bereits existiert, wird der neue Inhalt an den alten Inhalt angehängt, d.h. der alte Inhalt wird nicht gelöscht. Wenn die Datei noch nicht existiert, wird sie automatisch angelegt.<br>
<code>+&lt;datei.dat</code> bedeutet: Datei <code>datei.dat</code> zum Lesen und zum Schreiben von Daten öffnen. Die Datei muss existieren, ansonsten gibt es einen Fehler.<br>
<code>+&gt;datei.dat</code> bedeutet: Datei <code>datei.dat</code> zum Lesen und zum Schreiben von Daten öffnen. Wenn die Datei bereits existiert, wird ihr bisheriger Inhalt überschrieben. Wenn die Datei noch nicht existiert, wird sie automatisch angelegt.<br>
<code>+&gt;&gt;datei.dat</code> bedeutet: Datei <code>datei.dat</code> zum Lesen und zum Schreiben von Daten öffnen. Wenn die Datei bereits existiert, wird der neue Inhalt an den alten Inhalt angehängt, d.h. der alte Inhalt wird nicht gelöscht. Wenn die Datei noch nicht existiert, wird sie automatisch angelegt.<br>
<code>|datei</code> bedeutet: Datei <code>datei</code> ist eine ausführbare Programmdatei oder ein Shell-Befehl. Das Programm bzw. der Befehl werden ausgeführt. Aus Unix-Sicht wird dabei eine Pipe <strong>zu</strong> dem Programm bzw. Befehl geöffnet.<br>
<code>datei|</code> bedeutet: Datei <code>datei</code> ist eine ausführbare Programmdatei oder ein Shell-Befehl. Das Programm bzw. der Befehl werden ausgeführt. Aus Unix-Sicht wird dabei eine Pipe <strong>von</strong> dem Programm bzw. dem Befehl geöffnet.<br></p>

<p>Wenn die Datei geöffnet werden kann, gibt die Funktion <code>open</code> den Wert <code>true</code> zurück, andernfalls den Wert <code>undef</code>.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

use strict;

open(DATEI, "&lt;/tmp/server.cfg") || die "Datei nicht gefunden";
my @Zeilen = &lt;DATEI&gt;;
close(DATEI);

my @NeueZeilen;
foreach(@Zeilen) {
  $_ =~ s/#.*//;
  push(@NeueZeilen,$_) if $_ !~ /^\s*\n/;
}
open(DATEI, "&gt;/tmp/server.cfg") || die "Datei nicht gefunden";
print DATEI @NeueZeilen;
close(DATEI);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt, wie Sie eine Datei öffnen, einlesen und schließen, dann wieder öffnen und den inzwischen verarbeiteten Datenbestand in die Datei zurückschreiben. Es handelt sich um eine angenommene Konfigurationsdatei, in der viele Zeilen hinter dem eigentlichen Konfigurationsbefehl Kommentare enthalten, die mit <code>#</code> beginnen. Im Beispiel wird die Datei so verarbeitet, dass alle diese Kommentarzeilen gelöscht werden.</p>

<p>Zunächst wird die <code>open</code>-Funktion aufgerufen. Dabei wird die gewünschte Datei zum Lesen geöffnet. Die Datei wird dann in den Array <code>@Zeilen</code> eingelesen (in jedem Eintrag von <code>@Zeilen</code> steht anschließend je eine Zeile der Datei). Nach dem Einlesen wird die Datei mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#close">close</a> wieder geschlossen.<br>
Diese drei Befehle zum Öffnen, Einlesen und Schließen sind typisch.</p>

<p>Im obigen Beispiel werden die eingelesenen Zeilen anschließend der Reihe nach in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#foreach">foreach-Schleife</a> verarbeitet. Dabei wird in jeder Zeile der Kommentarteil entfernt. Dies geschieht mit Hilfe eines <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/regexpr.htm">regulären Ausdrucks</a> zum Suchen/Ersetzen (<code>s/#.*//g</code>). Dann wird die aktuell verarbeitete Zeile mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="listenhashes.htm#push">push</a> dem Array <code>@NeueZeilen</code> hinzugefügt - aber nur dann, wenn die Zeile aus etwas anderem besteht als nur aus Leerraumzeichen mit abschließendem Newline-Zeichen. Auch dazu wird wieder ein geeigneter regulärer Ausdruck angewendet.</p>

<p>Schließlich wird die Datei wieder geöffnet, diesmal jedoch zum Schreiben, genauer gesagt: zum Überschreiben des bisherigen Inhalts. Mit Hilfe der <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#print">print</a>-Funktion wird der Array <code>@NeueZeilen</code> in die Datei geschrieben. Anschließend wird die Datei geschlossen.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Wenn Fehler beim Öffnen von wichtigen Dateien passieren, ist es meistens sinnvoll, das Script sofort zu beenden. Dazu dient die Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="kontrolle.htm#die">die</a>, die auch im obigen Beispiel zum Einsatz kommt.</p>

<p>In den meisten Fällen ist es sinnvoll, eine geöffnete Datei sofort wieder zu schließen, sobald Sie sie nicht mehr zum Lesen oder Schreiben brauchen. Dadurch geben Sie Betriebssystem-Ressourcen frei, und andere Programme oder Prozesse können ebenfalls wieder auf die Datei zugreifen, wenn Sie die Datei zuvor gesperrt hatten.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="opendir">opendir - Verzeichnis öffnen</a></h2>

<p>Öffnet ein Verzeichnis, zum Beispiel, um es auszulesen. Dabei vergeben Sie ein Verzeichnishandle, über das Sie auf das Verzeichnis zugreifen können.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> den Namen des Verzeichnishandles (frei wählbar), und<br>
<strong>2.</strong> den Pfadnamen des zu öffnenden Verzeichnisses, entweder als absolute Pfadangabe oder als relative Pfadangabe aus Sicht des aktuellen Verzeichnisses (wenn das aktuelle Verzeichnis unbekannt ist, empfiehlt es sich, mit Hilfe der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm#chdir">chdir</a> in ein bestimmtes Verzeichnis zu wechseln).</p>

<p>Gibt <code>TRUE</code> zurück, wenn das Verzeichnis geöffnet werden konnte. Wenn ein Fehler aufgetreten ist, wird dieser in der Variablen <code>$!</code> gespeichert.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Verzeichnis = "/daten/web";
opendir(DIR, $Verzeichnis) || die "$Verzeichnis: $!";
my @Eintraege = readdir(DIR);
closedir(DIR);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
foreach(@Eintraege) {
 print "$_&lt;br&gt;\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird in dem Skalar <code>$Verzeichnis</code> der Pfad eines Verzeichnisses gespeichert (<code>"/daten/web"</code>). Beachten Sie, dass die Verzeichnisse des Pfades durch einfache Schrägstriche getrennt sind, nicht durch Backslashes wie unter DOS/Windows üblich. Verwenden Sie die Syntax mit den einfachen Schrägstrichen auch dann, wenn Perl bei Ihnen unter Windows läuft. Wenn Sie in einer Windows-Umgebung ein anderes als das aktuelle Laufwerk ansprechen möchten, setzen Sie einfach den Laufwerksbuchstaben mit Doppelpunkt davor, also beispielsweise <code>c:/temp</code>.</p>

<p>Mit der Funktion <code>opendir</code> wird das Verzeichnis geöffnet. <code>DIR</code> ist ein selbst vergebener Name für das Verzeichnishandle. Ferner bekommt die Funktion den Skalar übergeben, in dem das gewünschte Verzeichnis gespeichert ist. Falls das Verzeichnis nicht geöffnet werden kann, endet das Script durch Aufruf der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="kontrolle.htm#die">die</a>.</p>

<p>Das obige Beispiel nutzt das geöffnete Verzeichnis, um mit Hilfe der Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#readdir">readdir</a> den Verzeichnisinhalt in eine Liste <code>@Eintraege</code> einzulesen. Anschließend wird das Verzeichnis durch Aufruf der Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#closedir">closedir</a> geschlossen. Das Beispiel gibt dann HTML-Code mit der Liste der Verzeichniseinträge aus.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Es werden alle Verzeichniseinträge eingelesen, also Dateinamen, aber auch Namen von Unterverzeichnissen, sowie die auf den meisten Systemen vorhandenen "symbolischen" Verzeichnisnamen mit einem Punkt (<code>.</code> - steht für das aktuelle Verzeichnis) oder zwei Punkten (<code>..</code> - steht für das Elternverzeichnis).</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="print">print - Daten ausgeben</a></h2>

<p>Schreibt Daten auf die Standardausgabe oder in einen geöffneten Ausgabekanal, also etwa in eine Datei. Die Daten können eine einzelne Zeichenkette oder eine Liste von Zeichenketten sein. Innerhalb solcher Zeichenketten können auch Variablen vorkommen, also einzelne Skalare, aber auch ganze Listen oder Hashes. Perl erkennt die Variablen und schreibt ihren aktuellen Wert an die entsprechende Stelle.<br>
Diese Funktion wird in CGI-Scripts sehr oft verwendet, um HTML-Code auszugeben.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> <i>Datei-Handle</i> = Optionale Angabe zum Ausgabekanal. Wenn Sie diese Angabe weglassen, wird auf die Standardausgabe <code>STDOUT</code> geschrieben. Wenn Sie mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> eine Datei geöffnet haben und in diese schreiben wollen, müssen Sie das bei <code>open</code> vergebene Datei-Handle benutzen.<br>
<strong>2.</strong> <i>Daten[,Daten]</i> = Ein oder mehrere Elemente (Zeichenketten, Zahlen usw.), die geschrieben werden sollen.</p>

<p>Gibt <code>true</code> zurück, wenn Perl die Daten erfolgreich schreiben konnte.</p>

<h3 class="xmp">Beispiel 1 eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
print "&lt;table border=\"1\"&gt;\n","&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Umgebungsvariable&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;Aktueller Wert&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;\n";
my $i = 0;
my $Eintrag;
foreach $Eintrag (%ENV) {
  if($i == 0) {
    print "&lt;tr&gt;&lt;td&gt;$Eintrag&lt;/td&gt;\n";
  }
  else {
    print "&lt;td&gt;$Eintrag&lt;/td&gt;&lt;/tr&gt;\n";
  }
  if($i == 0) {
    $i = 1;
  }
  else {
    $i = 0;
  }
}
print "&lt;/table&gt;\n","&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel gibt alle <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../servercgi/cgi/umgebungsvariablen.htm">CGI-Umgebungsvariablen</a> des Webservers aus, und zwar sauber als HTML-Tabelle formatiert. Dazu werden die Einträge des vordefinierten Hashes <code>%ENV</code> in einer
<img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#foreach">foreach-Schleife</a> abgearbeitet und in die HTML-Tabelle geschrieben. Die entsprechenden HTML-Ausgaben werden mit Hilfe von print-Befehlen geschrieben.</p>

<p>Im letzten der <code>print</code>-Befehle können Sie sehen, wie man mehrere Zeichenketten, durch Kommata getrennt, hintereinander notieren kann.<br>
In den <code>print</code>-Befehlen innerhalb der Schleife können Sie sehen, wie eine Variable  (im Beispiel der Skalar <code>$Eintrag</code>) innerhalb einer auszugebenden Zeichenkette notiert ist. An der entsprechenden Stelle wird dann der jeweils aktuelle Wert von <code>$Eintrag</code> ausgegeben.</p>

<p>Wenn Sie viele <code>print</code>-Befehle hintereinander notieren müssen, können Sie auch zu einer für Sie <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/cginotwendig.htm#inhalte">besser lesbaren</a> Lösung greifen:</p>

<h3 class="xmp">Beispiel 2 eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print &lt;&lt;"ENDE";
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Titel&lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor="#FFFFCC"&gt;
&lt;h1&gt;Ganz normales HTML&lt;/h1&gt;
&lt;p&gt;Perl und HTML sind manchmal wie Adam und Eva&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
ENDE
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Sie können größere Textabschnitte, zum Beispiel kompletten HTML-Code, in einem Stück ausgeben. Dazu notieren Sie hinter dem <code>print</code>-Befehl zwei <code>&lt;&lt;</code> und direkt dahinter (ohne Leerzeichen dazwischen) den Namen eines Endbegrenzers, bis zu dem alles einfach als Text ausgegeben werden soll. Hinter dem (frei wählbaren) Namen des Endbegrenzers folgt in der Zeile des <code>print</code>-Befehls das übliche Semikolon. Am Ende des auszugebenden Textes notieren Sie in einer eigenen Zeile den Namen des Endbegrenzers, dort jedoch ohne Semikolon am Ende. Es hat sich eingebürgert, für solche Namen von Labels Großbuchstaben zu verwenden, weil die Label so im Quelltext leichter sichtbar sind.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Bei CGI-Scripts kann der Inhalt der ausgegebenen Daten auch als HTTP-Befehl interpretiert werden. Die Anweisung:<br>
<code>print "Content-type: text/html\n\n";</code><br>
ist ein typisches Beispiel dafür. Dabei wird ein einfacher HTTP-Header gesendet, der für die Kommunikation zwischen Server und Browser erforderlich ist. Eine andere für CGI-Scripts interessante Variante ist die folgende Anweisung (Beispiel):<br>
<code>print "Location: http://www.selfhtml.org/\n\n";</code><br>
Auch dabei wird ein HTTP-Header ausgegeben, der eine Weiterleitung zu dem angegebenen URI bewirkt. Ein CGI-Script, das eine solche <code>Location</code>-Anweisung enthält, braucht sonst keinen weiteren HTML-Code auszugeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="printf">printf - Daten formatiert ausgeben</a></h2>

<p>Schreibt Daten auf die Standardausgabe oder in einen geöffneten Ausgabekanal, also etwa in eine Datei. Diese Funktion dient dazu, einzelne Datenelemente formatiert auszugeben. So lassen sich Dezimalzahlen beispielsweise ohne viel Umrechnung hexadezimal ausgeben, oder die Ausgabe von Gleitkommazahlen mit vielen Nachkommastellen lässt sich auf eine bestimmte Anzahl Nachkommastellen trimmen.<br>
Die <code>printf</code>-Funktion in Perl entspricht im wesentlichen der <code>printf</code>-Funktion in C.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> <i>Datei-Handle</i> = Optionale Angabe zum Ausgabekanal. Wenn Sie diese Angabe weglassen, wird auf die Standardausgabe <code>STDOUT</code> geschrieben. Wenn Sie mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> eine Datei geöffnet haben und in diese schreiben wollen, müssen Sie das bei <code>open</code> vergebene Datei-Handle angeben.<br>
<strong>2.</strong> <i>Formatstring</i> = eine Zeichenkette, die für bestimmte auszugebende Elemente Formatbezeichner enthalten kann, und zwar entsprechend der speziellen Syntax der printf-Funktion (%-Zeichen-Syntax).<br>
<strong>3.</strong> <i>Ausgabeliste</i> = ein oder mehrere Elemente, auf die sich die speziellen Formatbezeichner im Formatstring beziehen.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $BruttoBetrag = 27.95;
my $NettoBetrag = $BruttoBetrag / 1.16;

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
printf "Das im Bruttobetrag %s enthaltene Netto beträgt ungerundet %.2f", $BruttoBetrag, $NettoBetrag;
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel gibt mit Hilfe der <code>printf</code>-Funktion die beiden Variablen <code>$BruttoBetrag</code> und <code>$NettoBetrag</code> aus. Der Wert von <code>$NettoBetrag</code> wird rechnerisch gewonnen und stellt eine Bruchzahl mit vielen Nachkommastellen dar. In der Ausgabe mit <code>printf</code> wird diese Zahl jedoch auf zwei Nachkommastellen reduziert ausgegeben.</p>

<p>Dazu notieren Sie in der auszugebenden Zeichenkette an der gewünschten Stelle einen Formatbezeichner. Solche Formatbezeichner beginnen mit einem Prozentzeichen <code>%</code>. Dahinter folgen die Angaben zur Formatierung. Die folgende Tabelle listet die möglichen Formatbezeichner und deren Formatiermöglichkeiten auf.</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Syntax</th>
<th>Bedeutung</th>
<th>Beispiel</th>
<th>Bewirkte Ausgabe</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%c</code></td>
<td class="tabxpl">gibt das ASCII-Zeichen eines numerischen Zeichenwertes aus. Die Zahl kann z.B. dezimal oder hexadezimal angegeben werden.</td>
<td class="code" nowrap="nowrap"><code>printf "%c wie Paula", 0x50;</code></td>
<td class="tabxpl">P wie Paula</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%d</code></td>
<td class="tabxpl">gibt den Ganzzahlanteil einer Zahl in Dezimaldarstellung aus. Optional kann hinter dem <code>%</code>-Zeichen und vor dem <code>d</code> noch eine gewünschte Anzeigebreite der Zahl angegeben werden, z.B. <code>%5d</code>. In Verbindung mit HTML-Ausgaben ist dies jedoch nur innerhalb von Tags wie <code>&lt;pre&gt;</code>...<code>&lt;/pre&gt;</code> realisierbar.</td>
<td class="code" nowrap="nowrap"><code>$PI = 3.141592653589793;<br>printf "Der Ganzzahlanteil von PI ist %d", $PI;</code></td>
<td class="tabxpl">Der Ganzzahlanteil von PI ist 3</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%e</code></td>
<td class="tabxpl">gibt eine Zahl in Exponentialschreibweise aus</td>
<td class="code" nowrap="nowrap"><code>$PI = 3.141592653589793;<br>printf "PI exponential: %e", $PI;</code></td>
<td class="tabxpl">PI exponential: 3.141593e+000</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%E</code></td>
<td class="tabxpl">wie <code>%e</code>, nur mit E als Exponentialzeichen statt e.</td>
<td class="code" nowrap="nowrap"><code>$PI = 3.141592653589793;<br>printf "PI exponential: %E", $PI;</code></td>
<td class="tabxpl">PI exponential: 3.141593E+000</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%f</code></td>
<td class="tabxpl">gibt eine Zahl mit Dezimalpunktdarstellung aus. Die Zahl nach dem Punkt ist die gewünschte Anzahl Nachkommastellen für die Ausgabe. Automatisch gerundet wird dabei nicht!</td>
<td class="code" nowrap="nowrap"><code>$Preis = 99;<br>printf "Der Preis beträgt %.2f", $Preis;</code></td>
<td class="tabxpl">Der Preis beträgt 99.00</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%g</code></td>
<td class="tabxpl">gibt eine Zahl automatisch in Exponentialschreibweise (wie bei <code>%e</code>) oder in Dezimalpunktdarstellung (wie bei <code>%f</code>) aus, abhängig von der Beschaffenheit der Zahl.</td>
<td class="code" nowrap="nowrap"><code>$Zahl1 = 100, $Zahl2 = 10000000000000000;<br>
printf "Die Zahlen: %g und %g", $Zahl1, $Zahl2;</code></td>
<td class="tabxpl">Die Zahlen: 100 und 1e+016</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%G</code></td>
<td class="tabxpl">wie <code>%g</code>, nur mit E als Exponentialzeichen statt e.</td>
<td class="code" nowrap="nowrap"><code>$Zahl = 10000000000000000;<br>printf "Die Zahl lautet %G", $Zahl;</code></td>
<td class="tabxpl">Die Zahl lautet 1E+016</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%o</code></td>
<td class="tabxpl">gibt eine Zahl in oktaler Schreibweise aus, ansonsten wie <code>%u</code>. Das Oktalsystem kennt nur Ziffern von 0 bis 7.</td>
<td class="code" nowrap="nowrap"><code>$Zahl = 100;<br>
printf "die Zahl lautet oktal %o", $Zahl;</code></td>
<td class="tabxpl">Die Zahl lautet oktal 144</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%u</code></td>
<td class="tabxpl">gibt eine Zahl als unsigned integer, also als positive Ganzzahl aus. Wenn die Zahl negativ ist, gibt Perl sie als die Differenz von der höchsten möglichen Integerzahl (4294967296) und der Zahl aus.</td>
<td class="code" nowrap="nowrap"><code>$Zahl1 = 100, $Zahl2 = -100;<br>
printf "Die Zahlen: %u und %u", $Zahl1, $Zahl2;</code></td>
<td class="tabxpl">Die Zahlen sind 100 und 4294967196</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%s</code></td>
<td class="tabxpl">gibt eine Zeichenkette (String) aus.</td>
<td class="code" nowrap="nowrap"><code>printf "PATH ist %s", $ENV{'PATH'};</code></td>
<td class="tabxpl">PATH ist D:\PERL\BIN;C:\WINDOWS (Beispielausgabe)</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%x</code></td>
<td class="tabxpl">gibt eine Zahl in hexadezimaler Schreibweise aus, ansonsten wie <code>%u</code>. Das Hexadezimalsystem kennt als Ziffern 0 bis 9 und a bis f.</td>
<td class="code" nowrap="nowrap"><code>$Zahl = 200;<br>
printf "die Zahl lautet oktal %x", $Zahl;</code></td>
<td class="tabxpl">Die Zahl lautet hexadezimal c8</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%X</code></td>
<td class="tabxpl">wie <code>%x</code>, nur mit A bis F als Ziffern statt a bis f.</td>
<td class="code" nowrap="nowrap"><code>$Zahl = 200;<br>
printf "die Zahl lautet oktal %X", $Zahl;</code></td>
<td class="tabxpl">Die Zahl lautet hexadezimal C8</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>%%</code></td>
<td class="tabxpl">notieren Sie, um das Formatbezeichnerzeichen, also das Prozentzeichen, selber auszugeben.</td>
<td class="code" nowrap="nowrap"><code>$Level = 100;<br>printf "wir haben %d%% erreicht", $Level;</code></td>
<td class="tabxpl">wir haben 100% erreicht</td>
</tr>
</table>

<p>Zusätzlich zu diesen Formatbezeichnern stehen so genannte Flags zur Verfügung, mit deren Hilfe sich die Ausgabe noch feiner justieren lässt. Flags müssen unmittelbar hinter dem Prozentzeichen für Formatbezeichner notiert werden. Die folgende Tabelle listet mögliche Flags auf:</p>

<table class="reftable" cellpadding="3" cellspacing="0" border="1">
<tr>
<th>Syntax</th>
<th>Bedeutung</th>
<th>Beispiel</th>
<th>Bewirkte Ausgabe</th>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>[blank]</code></td>
<td class="tabxpl">Leerzeichen vor positiven Zahlen erzwingen. Sinnvoll, wenn diese in Kolonne mit anderen Zahlen stehen, die auch negativ sein können.</td>
<td class="code" nowrap="nowrap"><code>$Zahl1 = 100, $Zahl2 = -100;<br>
printf "% d%\n% d", $Zahl1, $Zahl2;
</code></td>
<td class="tabxpl">&nbsp;100<br>-100</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>-</code></td>
<td class="tabxpl">Zahlen mit erzwungener Anzeigebreite linksbündig ausrichten (Voreinstellung ist rechtsbündig).</td>
<td class="code" nowrap="nowrap"><code>
printf "%-10d Zugriffe", 1234;
</code></td>
<td class="tabxpl">1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zugriffe</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>0</code></td>
<td class="tabxpl">Zahl mit erzwungener Anzeigebreite mit Nullen auffüllen, falls die Zahl kleiner ist.</td>
<td class="code" nowrap="nowrap"><code>
printf "%010d Zugriffe", 1234;
</code></td>
<td class="tabxpl">0000001234 Zugriffe</td>
</tr>
<tr>
<td class="code" nowrap="nowrap"><code>#</code></td>
<td class="tabxpl">Hexadezimal- oder Oktalzahl mit entsprechendem Bezeichner für die übliche Schreibweise versehen.</td>
<td class="code" nowrap="nowrap"><code>
printf "100 Hex = %#x, 100 Okt = %#o", 100, 100;
</code></td>
<td class="tabxpl">100 Hex = 0x64, 100 Okt = 0144</td>
</tr>
</table>

<h3 class="inf">Beachten Sie:</h3>

<p>Wenn Sie die Daten lediglich formatieren wollen ohne sie auszugeben, verwenden Sie bitte die <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="zeichenketten.htm#sprintf">sprintf</a>-Funktion.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="read">read - bestimmte Anzahl Zeichen lesen</a></h2>

<p>Liest eine anzugebende Anzahl Zeichen aus einer Datei ab der aktuellen Position des Dateizeigers in einen Skalar ein.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Datei-Handle<br>
<strong>2. </strong>einen Skalar, in dem die eingelesenen Zeichen gespeichert werden<br>
<strong>3. </strong>die Anzahl der zu lesenden Zeichen<br>
<strong>4. </strong>(optional) Offset - wenn die Zeichen in dem Zeichenkettenskalar (2.), in den sie eingelesen werden, nicht ab dem ersten Zeichen beginnen sollen, sondern ab einem Zeichen <code>n</code>, das als Offset angegeben wird (die Zählung beginnt bei 0).</p>

<p>Gibt die Anzahl eingelesener Zeichen zurück. Wenn das Dateiende erreicht wurde, wird <code>0</code> zurückgegeben. Wenn ein Fehler auftritt, wird <code>undef</code> zurückgegeben.</p>

<h3 class="xmp">Beispiel - Teil 1 (Auszug aus einer Datei error_log):</h3>
<pre>
[Sat Feb 07 17:24:44 2007] [error] [client 127.0.0.1] File does not exist: /usr/web/src/formate.css
</pre>
<h3 class="xmp">Beispiel - Teil 2 (als vollständiges CGI-Script in Perl):</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
my $Ausgabe;
open(ERRORDATEI, "&lt;/var/log/error_log") || die "Log-Datei nicht gefunden!";
my $geleseneZeichen = read(ERRORDATEI, $Ausgabe, 26);
close(ERRORDATEI);
print "gelesene Zeichen: $geleseneZeichen; gelesener Inhalt: $Ausgabe\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt im ersten Teil den Inhalt einer Datei namens <var>error_log</var>. Die Datei enthält eine Zeile, in der ein aufgetretener Fehler protokolliert ist. Im zweiten Teil des Beispiels liest ein CGI-Script diese Datei aus, aber nicht komplett, sondern nur 26 Zeichen. Da der Dateizeiger nach dem Öffnen der Datei mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> auf 0 steht, liest der im Beispiel notierte <code>read</code>-Befehl die ersten 26 Zeichen aus der Datei. Zur Kontrolle gibt das Script im Beispiel die Anzahl der eingelesenen Zeichen aus, die es durch den Rückgabewert von <code>read</code> in dem Skalar <code>$geleseneZeichen</code> ermittelt. Ferner gibt das Script die eingelesene Zeichenkette aus. Im Beispiel ist das genau der Teil, der den Zeitstempel in der Datei <var>error_log</var> markiert, also <code>[Sat Feb 07 17:24:44 2007]</code>. Dies sind die ersten 26 Zeichen.</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Um den Dateizeiger vor dem Lesen mit <code>read</code> an eine andere Stelle zu positionieren, können Sie die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#seek">seek</a> verwenden.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="readdir">readdir - Verzeichniseinträge ermitteln</a></h2>

<p>Liest Einträge eines Verzeichnisses, das zuvor mit der Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#opendir">opendir</a> geöffnet wurde.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Verzeichnishandle, das bei <code>opendir</code> vergeben wurde.</p>

<p>Gibt den jeweils nächsten Verzeichniseintrag zurück, wenn der Rückgabewert in einem Skalar gespeichert wird, zum Beispiel:<br>
<code>$Eintrag = readdir(DIR);</code><br>
Gibt alle Einträge des Verzeichnisses zurück, wenn der Rückgabewert in einer Liste gespeichert wird, zum Beispiel:<br>
<code>@Eintraege = readdir(DIR);</code><br>
Verzeichniseinträge sind sichtbare Dateien, Verzeichnisse sowie die Platzhalter für das aktuelle Verzeichnis (<code>.</code>) und für das nächsthöhere Verzeichnis (<code>..</code>).</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Verzeichnis = "/usr/web/ars_vivendi";
my $URIVerzeichnis = "/ars_vivendi";
opendir(DIR, $Verzeichnis) || die "$Verzeichnis: $!";
my @Dateien = readdir(DIR);
closedir(DIR);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
foreach(@Dateien) {
 if($_ =~ /.+\.htm*/) {
   print "&lt;a href=\"$URIVerzeichnis/$_\"&gt;$URIVerzeichnis/$_&lt;/a&gt;&lt;br&gt;\n";
   }
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird in dem Skalar <code>$Verzeichnis</code> der Pfad eines Verzeichnisses gespeichert (<code>/usr/web/ars_vivendi</code>). In einem zweiten Skalar <code>$URIVerzeichnis</code> wird ein zweiter Pfad (<code>/ars_vivendi</code>) gespeichert. Der Grund dafür ist, dass im Beispiel <code>/usr/web</code> als Wurzelverzeichnis (DocumentRoot) des installierten Webservers vorausgesetzt wird. Dann ist <code>/ars_vivendi</code> ein Verzeichnis unterhalb der DocumentRoot.</p>

<p>Mit der Funktion <code>opendir</code> wird das Verzeichnis geöffnet. Mit Hilfe von <code>readdir</code> wird der Verzeichnisinhalt in eine Liste <code>@Dateien</code> eingelesen. Anschließend wird das Verzeichnis durch Aufruf der Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#closedir">closedir</a> geschlossen.</p>

<p>Das Beispiel gibt dann HTML-Code aus. Dabei wird die Liste der Verzeichniseinträge analysiert. Einträge, in denen das Suchmuster <code>.+\.htm*</code> vorkommt, werden zeilenweise ausgegeben, und zwar umrahmt von HTML-Auszeichnungen, die den jeweiligen Eintrag als Verweis anklickbar machen. Zur korrekten Adressierung der anklickbaren HTML-Dateinamen wird der Skalar <code>$URIVerzeichnis</code> verwendet.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="rewinddir">rewinddir - auf ersten Verzeichniseintrag positionieren</a></h2>

<p>Positioniert den Lesezeiger in einem Verzeichnis, das zuvor mit der Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#opendir">opendir</a> geöffnet wurde, wieder auf den ersten Eintrag. Dies kann sinnvoll sein, wenn Sie das Verzeichnis mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#readdir">readdir</a> bereits eingelesen haben, das Verzeichnishandle aber zu einem erneuten Einlesen des Verzeichnisinhalts verwenden möchten.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Verzeichnishandle, das bei <code>opendir</code> vergeben wurde.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Verzeichnis = "/usr/work";
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
opendir(DIR, $Verzeichnis) || die "$Verzeichnis: $!";
my @Eintraege = readdir(DIR);
my $Eintrag;
foreach $Eintrag (@Eintraege) {
 if($Eintrag =~ /.+\.bak/) {
    unlink($Verzeichnis."/".$Eintrag);
   }
}
rewinddir(DIR);
@Eintraege = "";
@Eintraege = readdir(DIR);
foreach $Eintrag (@Eintraege) {
 print "$Eintrag&lt;br&gt;\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
closedir(DIR);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel liest zunächst alle Einträge des Verzeichnisses <code>$Verzeichnis</code> in die Liste <code>@Eintraege</code> ein. Diese Liste wird anschließend nach Dateien des Typs *.bak (typische Endung für Sicherungs-Dateien) durchsucht. Dateien mit dieser Endung werden im Beispiel gelöscht (mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm#unlink">unlink</a>). Nachdem diese Aktion beendet ist, wird der Verzeichniszeiger mit <code>rewinddir(DIR)</code> zurückgesetzt, denn das Verzeichnis soll nun mit demselben immer noch geöffneten Verzeichnishandle <code>DIR</code> nochmals eingelesen werden. Beim zweiten Einlesen werden alle vorhandenen Einträge ausgegeben. Dateien des Typs *.bak sollten eigentlich nicht mehr dabei sein. Oft geschieht das Neueinlesen jedoch noch, bevor die Dateien vom Betriebssystem gelöscht sind, und es werden deshalb doch noch die alten Einträge ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="seek">seek - Dateizeiger positionieren</a></h2>

<p>Positioniert den Dateizeiger eines Dateihandles, das zuvor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> erzeugt wurde, an eine beliebige Stelle innerhalb der Datei.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Handle der geöffneten Datei.<br>
<strong>2. </strong>Byteposition innerhalb der Datei, abhängig von der im dritten Parameter angegebenen Bezugsposition<br>
<strong>3. </strong>Bezugsposition für die Angabe im zweiten Parameter. Diese kann die Werte 0, 1 oder 2 haben:</p>

<ul>
<li>0 bedeutet <i>absolut vom Dateianfang (Position 0) aus gerechnet</i>,</li>
<li>1 bedeutet <i>relativ vom der aktuellen Position des Dateizeigers aus gerechnet</i>,</li>
<li>2 bedeutet <i>absolut vom Dateiende gerechnet</i> (im Normalfall sollte die Angabe beim zweiten Parameter in diesem Fall eine negative Zahl sein).</li>
</ul>

<h3 class="xmp">Beispiel - Teil 1 (Datei <var>isbn.txt</var>):</h3>
<pre>
ISBN 3-7723-7514-6
</pre>
<h3 class="xmp">Beispiel - Teil 2 (vollständiges CGI-Script in Perl):</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Datei = "isbn.txt";
my $ISBNummer;
open(DATEI, "&lt;$Datei");
seek(DATEI, 5, 0);
read(DATEI, $ISBNummer, 13);
close(DATEI);
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "ISBN-Nummer: $ISBNummer";
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt im ersten Teil den Inhalt einer Datei namens isbn.txt. Die Datei enthält eine Zeile, in der eine ISBN-Nummer notiert ist, wobei die eigentliche ISBN-Nummer jedoch erst an Position 5 beginnt. Im zweiten Teil des Beispiels liest ein CGI-Script diese Datei aus, aber nicht komplett, sondern nur ab Position 5, und von dort an 13 Zeichen.
Da der Dateizeiger nach dem Öffnen der Datei mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> auf 0 steht, wird er mit <code>seek(DATEI, 5, 0)</code> auf Position 5 vom Dateianfang her gerechnet gesetzt. Anschließend werden die 13 Zeichen der ISBN-Nummer mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#read">read</a> eingelesen. Zur Kontrolle gibt das Script im Beispiel die eingelesenen Daten aus.</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Die Funktion <code>seek</code> können Sie nur in Verbindung mit <code>read</code> oder <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#write">write</a> verwenden, aber nicht in Verbindung mit <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sysread">sysread</a> oder <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#syswrite">syswrite</a>. Benutzen Sie in diesem Fall die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#sysseek">sysseek</a>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="seekdir">seekdir - Verzeichniszeiger positionieren</a></h2>

<p>Positioniert den Verzeichniszeiger eines Verzeichnishandles, das zuvor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#opendir">opendir</a> erzeugt wurde, auf einen beliebigen Eintrag innerhalb des Verzeichnisses. Voraussetzung dazu ist, dass die Funktion <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#telldir">telldir</a> angewendet wird, um die internen Positionsnummern der Verzeichniseinträge zu ermitteln.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Verzeichnishandle, das bei <code>opendir</code> vergeben wurde.<br>
<strong>2.</strong> die interne Positionsnummer eines Verzeichniseintrags, auf den positioniert werden soll. Diese interne Positionsnummern können nur durch Aufruf der Funktion <code>seekdir</code> ermittelt werden. Es handelt sich um vom Dateisystem des Rechners gelieferte Adressen, also nicht um einfache fortlaufende Nummern!</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Verzeichnis = "/usr/texte";
opendir(DIR, $Verzeichnis) || die "$Verzeichnis: $!";
my @Positionen;
my @Eintraege;
for(my $i=0;$i&lt;10;$i++) {
  $Eintraege[$i] = readdir(DIR);
  $Positionen[$i] = telldir(DIR);
}
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
for(my $i=0;$i&lt;10;$i++) {
  print "&lt;p&gt;Eintraege[$i] = $Eintraege[$i]&lt;br&gt;\n";
  print "Positionen[$i] = $Positionen[$i]&lt;/p&gt;\n";
}
seekdir(DIR, $Positionen[5]);
my $Eintrag = readdir(DIR);
print "&lt;p&gt;Positioniert auf Positionen[5] und Eintrag gelesen: $Eintrag&lt;/p&gt;\n";
print "&lt;/body&gt;&lt;/html&gt;\n";
closedir(DIR);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel leistet nichts Produktives, es dient nur zur Verdeutlichung, und es dient dazu, das Prinzip der internen Positionsnummern zu verstehen. In dem Beispiel wird ein Verzeichnis mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#opendir">opendir</a> geöffnet. Die ersten zehn Einträge des Verzeichnisses werden danach in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#for">for-Schleife</a> mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#readdir">readdir</a> eingelesen. Dabei werden auch die Positionsnummern der eingelesenen Einträge gespeichert, und zwar in dem Array <code>@Positionen</code>. Das CGI-Script gibt zur Kontrolle die zehn eingelesenen Einträge und deren ermittelte Positionsnummern aus. Um die Funktion <code>seekdir</code> zu testen, wird auf eine der ermittelten Positionsnummern (<code>$Positionen[5]</code>) positioniert. Der nächste Verzeichniseintrag wird noch einmal eingelesen und zur Kontrolle ausgegeben.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Wenn Sie mit <code>seekdir</code> auf einen Verzeichniseintrag positionieren und dann <code>readdir</code> anwenden, wird nicht derjenige Verzeichniseintrag eingelesen, auf den Sie positioniert haben, sondern der nächste!</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="select">select - Ein-/Ausgabekanal auswählen</a></h2>

<p>Wählt den Default-Ein-/Ausgabekanal für nachfolgende Lese-/Schreiboperationen aus.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Handle des gewünschten Ein-/Ausgabekanals. Das kann ein Handle einer zuvor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> geöffneten Datei sein oder einer der Standardkanäle.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/plain\n\n";

open(DATEI, "&gt;&gt;/usr/webconfig/users.txt") || die "$!";
my $User = "Stefan";
select(DATEI);
print "\nuser=$User";
close(DATEI);

select(STDOUT);
print "$User in Datei geschrieben";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird zunächst ein HTTP-Header erzeugt. Die <code>print</code>-Funktion schreibt dabei zuerst auf den Standardausgabekanal. Anschließend wird eine Datei zum anhängenden Schreiben geöffnet. Dabei wird das Handle mit dem Namen <code>DATEI</code> erzeugt. Anschließend wird dieses Handle mit <code>select(DATEI)</code> als das aktive Handle ausgewählt. Die nachfolgende <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#print">print</a>-Funktion bezieht sich dadurch automatisch auf das ausgewählte Handle. Um in die Datei zu schreiben, ist also:<br>
<code>select(DATEI);<br>
print "\nuser=$User";</code><br>
gleichbedeutend mit:<br>
<code>print DATEI "\nuser=$User";</code>.</p>

<p>Nachdem die neue Zeile in die Datei geschrieben und diese geschlossen wurde, wird - wiederum mit <code>select</code> - der Standardausgabekanal <code>STDOUT</code> als neuer aktiver Kanal ausgewählt. Der nachfolgende <code>print</code>-Befehl, der eine Bestätigung ausgibt, funktioniert nur, weil zuvor <code>STDOUT</code> als aktiver Kanal ausgewählt wurde. Andernfalls wäre der aktive Kanal undefiniert, da der zuvor als aktiv ausgewählte Kanal <code>DATEI</code> mittlerweile geschlossen wurde.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="sysopen">sysopen - Datei systemnah öffnen</a></h2>

<p>Öffnet eine Datei ebenso wie <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a>. Während <code>open</code> jedoch die bequeme Art der Umleitung (mit <code>&gt;</code>, <code>&gt;&gt;</code>, <code>&lt;</code>, ...) an der Kommandozeile nachahmt, wird bei <code>sysopen</code> direkt der betriebssystemeigene Befehl zum Öffnen einer Datei benutzt. Der Vorteil besteht darin, dass Sie genauer angeben können, wie Sie die Datei öffnen wollen. Der Nachteil ist aber, dass es Probleme mit Betriebssystemen gibt, die nicht alle Features unterstützen. Das Perl-Script lässt sich dann möglicherweise nicht mehr in verschiedenen Umgebungen ausführen.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>den Namen des Datei-Handles (frei wählbar),<br>
<strong>2. </strong>den Namen der Datei, wenn erforderlich mit relativem oder absolutem Pfadnamen,<br>
<strong>3. </strong>den Modus, in dem die Datei geöffnet werden kann. Dazu ist es ratsam, das <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../module/standardmodule.htm">Standardmodul</a> <code>Fcntl</code> einzubinden, in dem Konstanten für erlaubte Werte definiert sind. Folgende Konstanten sind dann erlaubt:</p>
<ul><li><code>O_RDONLY</code> bedeutet: Datei nur zum Lesen öffnen,</li>
<li><code>O_WRONLY</code> bedeutet: Datei nur zum Schreiben öffnen,</li>
<li><code>O_RDWR</code> bedeutet: Datei zum Lesen und Schreiben öffnen.</li>
<li>Diese Konstanten können Sie durch bitweises Oder (einfacher Senkrechtstrich <code>|</code>) mit folgenden Zusatzkonstanten verknüpfen:</li>
<li><code>O_APPEND</code> bedeutet: Schreiben nur am Ende der Datei,</li>
<li><code>O_CREAT</code> bedeutet: Datei anlegen, falls sie nicht existiert,</li>
<li><code>O_EXCL</code> in Verbindung mit <code>O_CREAT</code> bedeutet: Abbrechen und <code>false</code> zurückgeben, wenn die Datei schon existiert,</li>
<li><code>O_NONBLOCK</code> bedeutet: beim Öffnen der Datei nicht blockieren (ältere Version: <code>O_NDELAY</code>),</li>
<li><code>O_SYNC</code> bedeutet: nach jedem Schreibvorgang wird die Synchronisationsfunktion <code>fsync()</code> aufgerufen,</li>
<li><code>O_TRUNC</code> bedeutet: die existierende Datei wird auf 0 Byte gekürzt, ohne gelöscht zu werden.</li></ul>
<p><strong>4. </strong>(optional) eine Angabe für die Zugriffsrechte, mit denen die Datei geöffnet werden soll. Die Angabe ist dabei die unter Unix übliche Bezeichnung der Zugriffsrechte für Welt, Gruppe und Eigner in Oktalschreibweise mit führender 0 (z.B. <code>0440</code>) und <strong>nicht</strong> in Anführungszeichen zu notieren.</p>

<p>Wenn die Datei geöffnet werden kann, gibt die Funktion den Wert <code>true</code> zurück, andernfalls den Wert <code>false</code>.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use Fcntl;
my $Datei = "/usr/geistesblitze/aktuell.txt";
sysopen(DATEI, $Datei, O_WRONLY | O_APPEND, 0440) || die "$Datei: $!";
print DATEI "Neugier killte die Katze\n";
close(DATEI);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Im Beispiel wird eine Textdatei mit <code>sysopen</code> geöffnet. Dabei wird bestimmt, dass die Datei nur zum Schreiben geöffnet wird, und zwar so, dass geschriebene Inhalte an die vorhandene Datei angehängt werden (erreicht durch bitweise Verknüpfung von <code>O_APPEND</code>). Mit <code>print</code> wird ein Satz in die Datei geschrieben. Anschließend wird die Datei geschlossen. Dazu können Sie die übliche Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#close">close</a> verwenden.</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Der Befehl <code>use Fcntl</code> zu Beginn ist erforderlich, um Zugriff auf Konstanten wie <code>O_WRONLY</code> und <code>O_APPEND</code> zu erhalten.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="sysread">sysread - bestimmte Anzahl Zeichen systemnah lesen</a></h2>

<p>Liest eine anzugebende Anzahl Zeichen aus einer Datei ab der aktuellen Position des Dateizeigers in einen Skalar ein. Die Datei sollte in den meisten Fällen sinnvollerweise mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#sysopen">sysopen</a> geöffnet worden sein. Ansonsten gelten für <code>sysread</code> die gleichen Regeln zum Aufruf und beim Rückgabewert wie bei <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#read">read</a>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="sysseek">sysseek - Dateizeiger systemnah positionieren</a></h2>

<p>Positioniert den Dateizeiger eines Dateihandles, das zuvor sinnvollerweise mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#sysopen">sysopen</a> erzeugt wurde, an eine beliebige Stelle innerhalb der Datei. Ansonsten gelten für <code>sysseek</code> die gleichen Regeln zum Aufruf und beim Rückgabewert wie bei <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#seek">seek</a>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="syswrite">syswrite - bestimmte Anzahl Zeichen systemnah schreiben</a></h2>

<p>Schreibt eine anzugebende Anzahl Zeichen aus einer ebenfalls anzugebenden Variablen ab der aktuellen Position innerhalb dieser Variablen in eine Datei. Die Datei sollte sinnvollerweise mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#sysopen">sysopen</a> geöffnet worden sein.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Datei-Handle.<br>
<strong>2. </strong>einen Skalar, der die Zeichen zum Schreiben in die Datei enthält.<br>
<strong>3. </strong>(optional) die Anzahl der in die Datei zu schreibenden Zeichen.<br>
<strong>4. </strong>(optional) Offset - wenn die zu schreibenden Zeichen in dem Zeichenkettenskalar (2.) nicht ab dem ersten Zeichen beginnen sondern ab einem Zeichen n, können Sie n als Offset angeben (die Zählung beginnt bei 0).</p>

<p>Wenn der Skalar mehr Daten enthält als geschrieben werden sollen, werden trotzdem nur so viele Zeichen geschrieben wie angegeben. Wenn der Skalar weniger Daten enthält als geschrieben werden sollen, werden nur so viele Zeichen geschrieben, wie der Skalar ab dem Offset noch enthält. Wenn Sie keine Anzahl zu schreibender Zeichen angeben, wird der komplette Inhalt des Skalars in die Datei geschrieben.</p>

<p><code>syswrite</code> gibt die Anzahl tatsächlich geschriebener Zeichen zurück. Im Fehlerfall wird <code>undef</code> zurückgegeben.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl

use strict;
use Fcntl;
my $Datei = "/usr/bin/mycodes/mysecret.sys";
my $Daten = "sdclknavaoertoerigjvimfvlkmdfghjdfbjdfihgjsobijsngohijsrotigueiufgulvbdkjbndfkhv";
my $Block = 8;
sysopen(DATEI, $Datei, O_WRONLY | O_EXCL) || die "$Datei: $!";
for(my $i=0;$i&lt;10;$i++) {
  my $Offset = $i * $Block;
  syswrite(DATEI,$Daten,$Block,$Offset);
}
close(DATEI);
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel schreibt eine Zeichenkette, die in <code>$Daten</code> gespeichert ist, blockweise in eine Datei. Dazu stehen die Aufrufe von <code>sysread</code> in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#for">for-Schleife</a>. Die Schleife hat 10 Durchläufe, da die Länge von <code>$Daten</code> 80 Zeichen beträgt und pro Schreibvorgang 8 Zeichen (in dem Skalar <code>$Block</code> definiert) geschrieben werden sollen. Dabei ist es wichtig, jedesmal den Offset neu zu berechnen, damit immer die jeweils nächsten 8 Zeichen geschrieben werden, und nicht immer wieder nur die ersten 8.</p>

<h3 class="xpl">Beachten Sie:</h3>

<p>Das Beispiel selbst ist in dieser Form nicht besonders praxisrelevant, denn bei der kleinen Datenmenge empfiehlt es sich, den gesamten Inhalt von <code>$Daten</code> in einem Rutsch in die Datei zu schreiben. Aber das Prinzip lässt sich anwenden, wenn die Datenmenge aus anderen Quellen dynamisch gewonnen wird, wobei sie ja sehr groß sein kann.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="tell">tell - Position des Dateizeigers ermitteln</a></h2>

<p>Ermittelt die aktuelle Byteposition des Dateizeigers eines Dateihandles, das zuvor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> erzeugt wurde.</p>

<p>Erwartet als Parameter:<br>
<strong>1. </strong>das Datei-Handle.</p>

<p>Gibt die aktuelle Byteposition zurück. Wenn ein Fehler aufgetreten ist, wird <code>-1</code> zurückgegeben.</p>

<h3 class="xmp">Beispiel eines vollständigen CGI-Scripts in Perl:</h3>
<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Datei = "/usr/info/readme.txt";
my @Zeilenanfaenge = "";
open(DATEI, "&lt;$Datei") || die "$Datei: $!";
$Zeilenanfaenge[0] = tell(DATEI);
my $i = 0;
while(&lt;DATEI&gt;) {
   $i++;
   $Zeilenanfaenge[$i] = tell(DATEI);
}
close(DATEI);
$i = 1;
print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n";
foreach (@Zeilenanfaenge) {
   print "Zeile $i beginnt in der Datei bei Offset $_&lt;br&gt;\n";
   $i++;
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel öffnet mit <code>open</code> eine Textdatei und liest sie in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#while">while-Schleife</a> zeilenweise ein. Dabei wird direkt nach dem Öffnen und bei jedem Schleifendurchgang die aktuelle Position des Dateizeigers mit <code>tell</code> ermittelt und im jeweils nächsten Element des Arrays <code>@Zeilenanfaenge</code> gespeichert. Anschließend wird HTML-Code erzeugt. Dabei werden die gespeicherten Offset-Positionen der Zeilenanfänge in einer <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/schleifen.htm#foreach">foreach-Schleife</a> ausgegeben.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="telldir">telldir - Position des Verzeichniszeigers ermitteln</a></h2>

<p>Ermittelt die interne Positionsnummer des Verzeichniseintrags, auf dem der Verzeichniszeiger eines Verzeichnishandles steht, das zuvor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#opendir">opendir</a> erzeugt wurde.</p>

<p>Erwartet als Parameter:<br>
<strong>1.</strong> das Verzeichnishandle, das bei <code>opendir</code> vergeben wurde.</p>

<h3 class="xmp">Beispiel mit Erläuterung:</h3>

<p>Ein vollständiges Beispiel mit Erläuterung der zusammenhängenden Funktionen <code>telldir</code> und <code>seekdir</code> wird bei der Funktion <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#seekdir">seekdir</a> behandelt.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="write">write - formatierte Daten schreiben</a></h2>

<p>Diese Funktion dient dazu, Daten, die mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#format">format</a> formatiert wurden, datensatzweise in eine Datei zu schreiben, die zuvor mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#open">open</a> geöffnet wurde. Beispiele werden im Zusammenhang mit der Funktion <code>format</code> beschrieben.</p>



<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" class="doc">
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a>
</td></tr>
<tr><td class="doc"><a href="dateiverwaltung.htm"><img src="../../src/next.gif" width="10" height="10" border="0" hspace="10" alt="weiter"></a></td>
<td width="100%"><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="dateiverwaltung.htm">Funktionen für Datei- und Verzeichnis-Management</a>
</td></tr>
<tr>
<td class="doc"><a href="datumzeit.htm"><img src="../../src/prev.gif" width="10" height="10" border="0" hspace="10" alt="zurück"></a></td>
<td><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="datumzeit.htm">Funktionen für Datum und Uhrzeit</a>
</td>
</tr>
<tr><td colspan="2" class="doc">&nbsp;</td>
</tr>
<tr>
<td colspan="2" class="nav"><a class="an" name="bottom"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Funktionen</a></td>
</tr>
</table>

<p>&copy; 2007 <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../editorial/impressum.htm">Impressum</a></p>

</body>
</html>
