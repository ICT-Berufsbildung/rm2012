<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>SELFHTML: Perl / Perl-Sprachelemente / Schleifen</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Wie Sie in Perl das Ausführen von Anweisungen mit Hilfe von Bedingungen wiederholen können.">
<meta name="keywords"       content="SELFHTML, Perl, Schleifen, for, foreach, while, do until, do while, Traversion, Rekursion">
<meta name="author"         content="Redaktion SELFHTML, selfhtml81@selfhtml.org">
<meta name="robots"         content="noindex, nofollow">
<meta name="DC.Publisher"   content="SELFHTML e. V.">
<meta name="DC.Date"        content="2005-11-09T00:29:27+01:00">
<meta name="DC.Identifier"  content="http://de.selfhtml.org/perl/sprache/schleifen.htm">
<meta name="DC.Language"    content="de">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.created" content="2001-10-27T08:00+01:00">
<meta name="SELF.Pagetype"  content="page">
<link rel="alternate" type="application/atom+xml" title="SELFHTML-Weblog (Atom, gesamt)" href="http://aktuell.de.selfhtml.org/weblog/atom-feed">
<link rel="alternate" type="application/rss+xml" title="SELFHTML-Weblog (RSS, Auszüge)" href="http://aktuell.de.selfhtml.org/weblog/rss-feed">
<link rel="shortcut icon" type="image/x-icon" href="../../src/favicon.ico">
<link rel="author" title="Impressum" href="../../editorial/impressum.htm">
<link rel="contents" title="Inhaltsverzeichnis" href="../../navigation/inhalt.htm">
<link rel="index" title="Stichwortverzeichnis" href="../../navigation/stichwort.htm">
<link rel="search" title="Suche" href="../../navigation/suche/index.htm">
<link rel="help" title="Hilfe" href="../../editorial/index.htm">
<link rel="copyright" title="Urheberrecht" href="../../editorial/copyright.htm">
<link rel="top" title="SELFHTML" href="../../index.htm">
<link rel="up" title="Perl-Sprachelemente" href="index.htm">
<link rel="next" title="Sprungbefehle" href="sprungbefehle.htm">
<link rel="prev" title="Bedingte Anweisungen" href="bedingt.htm">
<link rel="first" title="CGI-notwendige Anweisungen in Perl" href="cginotwendig.htm">
<link rel="last" title="CGI-typische Aufgaben in Perl" href="cgitypisch.htm">
</head>
<body>

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td colspan="2" class="nav"><a class="an" name="top"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Sprachelemente</a></td>
</tr>
<tr>
<td class="doc" width="110"><a href="../../index.htm"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></a></td>
<td class="docbot" width="100%"><h1 class="ph1">Schleifen</h1></td>
</tr>
<tr>
<td class="doctop">
<img src="../../src/dokx.gif" width="30" height="20" vspace="6" alt="Informationsseite">
</td>
<td valign="top" nowrap="nowrap">
<p>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#for">for-Schleifen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#foreach">foreach-Schleifen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#while">while-Schleifen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#do">do-Schleifen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#schleifen_hashes">Schleifen bei Hashes</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#rekursion">Rekursion</a><br>
</p>
</td>
</tr><tr><td colspan="2" class="doc">&nbsp;<a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>&nbsp;</td></tr>
</table>



<h2><a class="an" name="for">for-Schleifen</a></h2>

<p>Solche Schleifen eignen sich vor allem für Fälle, in denen es einen Anfangswert, einen Endwert und einen Iterationswert gibt, also beispielsweise "Jede Zahl zwischen 1 und 100".</p>

<h3 class="xmp"><a class="an" name="beispiel1">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/schleifen1.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

for(my $i = 1; $i &lt;= 100; $i++) {
 print "&lt;span style=\"font-size:$i\".\"pt\"&gt;$i pt&lt;/span&gt;&lt;br&gt;\n";
}

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Script gibt einen Text insgesamt 100 mal aus. Dazu werden hinter dem Schlüsselwort <code>for</code>, das eine <code>for</code>-Schleife einleitet, in Klammern insgesamt drei kleine Anweisungen notiert. Die erste Anweisung deklariert eine Zählervariable <code>$i</code> und initiiert sie mit dem Wert 1. Die zweite Anweisung ist eine Bedingung. Sie lautet: "<code>$i</code> kleiner gleich 100". Die dritte Anweisung zählt zum aktuellen Wert von <code>$i</code> 1 dazu. Die Schleife wird nun so oft durchlaufen, wie die Bedingung in der Mitte wahr ist. Da <code>$i</code> im Beispiel zunächst den Wert 1 hat und dann bei jedem Schleifendurchlauf wegen <code>$i++</code> um 1 erhöht wird, wird die Schleife insgesamt 100 mal durchlaufen. Beim 101. mal ist <code>$i</code> höher als 100, die Bedingung ist nicht mehr wahr, und die Schleife wird beendet.</p>

<p>Im Anschluss an das <code>for</code>-Konstrukt folgt ein <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../intro.htm#anweisungsbloecke">Anweisungsblock</a>, markiert wie üblich durch <strong>geschweifte</strong> Klammern <code>{</code> und <code>}</code>. Dazwischen können beliebig viele Anweisungen stehen. Diese Anweisungen werden so oft ausgeführt, wie die Schleife durchlaufen wird, im Beispiel also 100 mal. Im Beispiel wird mit <code>print</code> HTML-Code erzeugt. Dieser enthält in einem <code>span</code>-Element eine CSS-Formatdefinition zur Schriftgröße (<code>font-size</code>). Bei der Zuweisung an diese CSS-Eigenschaft wird der Skalar <code>$i</code> verwendet. Das bewirkt im Beispiel, dass der Text 100 mal ausgegeben wird, und zwar jedesmal mit einer etwas größeren Schrift. Die erste ausgegebene Zeile ist nur 1pt, also ein Punkt groß, was wohl kaum jemand wird lesen können. Jede ausgegebene Zeile wird aber um einen Punkt größer, und die letzte Zeile ist mit 100pt Größe schon recht fensterfüllend.</p>

<p>Um Bedingungen wie die in der zweiten Anweisung im Konstrukt der <code>for</code>-Schleife zu formulieren, brauchen Sie entweder zwei Werte, die Sie vergleichen möchten, oder Sie fragen direkt, ob ein in den Klammern stehender Ausdruck wahr oder falsch ist. Im Beispiel werden in der Bedingung zwei Werte verglichen, nämlich der Wert von <code>$i</code> mit der Zahl 100. Dazu brauchen Sie <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="operatoren.htm#vergleich">Vergleichsoperatoren</a> wie im Beispiel den Kleiner-Als-Operator <code>&lt;</code>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="foreach">foreach-Schleifen</a></h2>

<p>Diese Sorte Schleifen ist in Perl speziell für das Durchlaufen von <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="listen.htm">Listen und Arrays</a> gedacht. Eine Liste wird dabei Element für Element abgeklappert. Abhängig davon können Sie Anweisungen ausführen.</p>

<h3 class="xmp"><a class="an" name="beispiel2">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/schleifen2.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";


my @Sachen = ("mein Haus","mein Auto","mein Boot");
foreach (@Sachen) {
 print "$_&lt;br&gt;\n";
}

my @Schwaechen = ("Nikotin","Alkohol","das andere Geschlecht");
my $Schwaeche;
foreach $Schwaeche (@Schwaechen) {
 print "$Schwaeche&lt;br&gt;\n";
}

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt zwei leicht abweichende Varianten, mit einer <code>foreach</code>-Schleife umzugehen. In beiden Fällen wird jeweils ein Array deklariert und mit Anfangswerten versehen, einmal <code>@Sachen</code> und einmal <code>@Schwaechen</code>. Hinter dem Schlüsselwort <code>foreach</code> wird in Klammern einfach der Array angegeben. In dem Anweisungsblock, der dahinter in geschweiften Klammern folgt, können beliebig viele Anweisungen stehen.</p>

<p>Im ersten der obigen Beispiele wird von der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="vordefiniert.htm">vordefinierten Variablen</a> <code>$_</code> Gebrauch gemacht. In ihr ist im Anweisungsblock einer <code>foreach</code>-Schleife stets der aktuelle Wert des Schleifendurchlaufs gespeichert, was in diesem Fall das jeweils aktuelle Element des Arrays <code>@Sachen</code> ist.</p>

<p>Im zweiten Beispiel wird anstelle von <code>$_</code> ein eigener Skalar namens <code>$Schwaeche</code> benutzt. Wenn ein solcher Skalar zwischen dem Schlüsselwort <code>foreach</code> und der Klammer mit dem Array notiert wird, ist im Anweisungsblock in diesem Skalar jeweils der aktuelle Wert des Schleifendurchlaufs enthalten, im zweiten Beispiel also der jeweils aktuelle Wert aus <code>@Schwaechen</code>.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Die Schlüsselwörter <code>for</code> und <code>foreach</code> besitzen zwar jeweils einen semantisch anderen Hintergrund, sind aber syntaktisch beliebig gegeneinander austauschbar. Perl erkennt selbständig, was für einen Typ Schleife Sie verwenden wollen. So können Sie beispielsweise auch folgendes schreiben:<br>
<code>for(1..1000) {<br>
&nbsp;print "tausendmal berührt\n";<br>
}</code><br>
Der Code gibt einfach tausendmal den Text aus, ist aber im Grunde eine <code>foreach</code>-Schleife, welche die Liste der Zahlen von 1 bis 1000 abarbeitet.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="while">while-Schleifen</a></h2>

<p>Diese Art von Schleifen eignet sich, wenn Sie vorher nicht wissen, wie oft die Schleife durchlaufen wird. Sie formulieren einfach eine Bedingung, und die Schleife wird so oft durchlaufen, wie die Bedingung wahr ist. Dass die Bedingung irgendwann falsch und die Schleife beendet wird, dafür müssen Sie im Anweisungsblock, der von der Schleife abhängig ist, selber sorgen.</p>

<h3 class="xmp"><a class="an" name="beispiel3">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/schleifen3.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

my $Startzeit = time();
my $Endzeit = $Startzeit + 1;
my $Jetztzeit = 0;
my $i = 0;

while ($Jetztzeit &lt;= $Endzeit) {
 $Jetztzeit = time();
 $i++;
}
print "$i mal durchlaufen&lt;br&gt;";

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Script ermittelt zunächst mit der Perl-Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/datumzeit.htm#time">time</a> den aktuellen Zeitpunkt und speichert das Ergebnis im Skalar <code>$Startzeit</code>. Gespeichert wird dabei eine Zahl, nämlich die Anzahl Sekunden vom 1.1.1970, 0.00 Uhr bis zum aktuellen Zeitpunkt. Dann wird ein Skalar <code>$Endzeit</code> deklariert, der einen Wert zugewiesen bekommt, der um <code>1</code> höher ist als der von <code>$Startzeit</code>. Zwei weitere Skalare <code>$Jetztzeit</code> und <code>$i</code> werden deklariert und mit <code>0</code> initialisiert.</p>

<p>Die Schleife wird durch das Schlüsselwort <code>while</code> eingeleitet. In Klammern wird eine Bedingung formuliert. Im Beispiel wird die Bedingung "<code>$Jetztzeit</code> kleiner oder gleich <code>$Endzeit</code>" formuliert. Hinter der Bedingung folgt in geschweiften Klammern ein Anweisungsblock mit beliebig vielen Anweisungen. Ausgeführt werden diese Anweisungen so oft, wie die Schleife durchlaufen wird und die Bedingung noch wahr ist.</p>

<p>Die Schleifenbedingung ist im Beispiel ja zunächst auf jeden Fall wahr, da <code>$Jetztzeit</code> mit <code>0</code> initialisiert wurde und daher auf jeden Fall kleiner ist als <code>$Endzeit</code>. Innerhalb der Schleife bekommt <code>$Jetztzeit</code> jedoch durch Aufrufen der Funktion <code>time</code> einen neuen Wert zugewiesen, der logischerweise mindestens so hoch ist wie der von <code>$Startzeit</code>. Die Schleife wird dadurch so lange durchlaufen, bis <code>$Jetztzeit</code> durch den <code>time</code>-Aufruf einen Wert zugewiesen bekommt, der größer ist als <code>$Endzeit</code>. Dann wird die Schleife beendet. Wie oft das der Fall ist, wissen Sie natürlich vorher nicht, insofern ist die <code>while</code>-Schleife hier ideal.</p>

<p>Innerhalb der Schleife wird außerdem noch <code>$i</code> als Zählervariable mit <code>$i++</code> jeweils um 1 erhöht. Der aktuelle Wert von <code>$i</code> wird nach Ablauf der Schleife ausgegeben. Im Fenster des aufrufenden Browsers wird man also am Ende sehen können, wie oft die Schleife durchlaufen wurde.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="do">do-Schleifen</a></h2>

<p>Bei <code>while</code>-Schleifen kann es passieren, dass die abhängigen Anweisungen nie ausgeführt werden, nämlich dann, wenn die Schleifenbedingung schon beim ersten Schleifendurchlauf unwahr ist. Eine <code>do</code>-Schleife sorgt dafür, dass die Anweisungen auf jeden Fall einmal ausgeführt werden, da die Bedingung der Schleife erst am Ende abgeprüft wird.</p>

<h3 class="xmp"><a class="an" name="beispiel4">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/schleifen4.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

my $Bedingung = "Abbruch";
my $Irgendwas;
do {
 $Irgendwas = $Bedingung;
 print "Hier steht $Irgendwas";
} until ($Irgendwas eq $Bedingung);

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel demonstriert die typische Funktionsweise einer solchen Schleife. Zunächst wird ein Skalar <code>$Bedingung</code> mit dem Anfangswert <code>Abbruch</code> versehen. Ein weiterer Skalar namens <code>$Irgendwas</code> wird deklariert, erhält aber keinen Wert. Die Schleife wird mit <code>do</code> eingeleitet. Dahinter folgt in geschweiften Klammern ein Anweisungsblock, der beliebig viele Anweisungen enthalten kann. Im Beispiel wird dem Skalar <code>$Irgendwas</code> gleich zu Beginn der Wert von <code>$Bedingung</code> zugewiesen, also <code>Abbruch</code>. Anschließend wird dieser Inhalt zur Kontrolle ausgegeben. Nach der schließenden geschweiften Klammer, die den Anweisungsblock beendet, ist das Wort <code>until</code> notiert und dahinter in Klammern die eigentliche Schleifenbedingung. Im Beispiel wird abgeprüft, ob <code>$Irgendwas</code> und <code>$Bedingung</code> gleich sind, also den gleichen Inhalt haben. Da dies ja innerhalb der Schleife zugewiesen wurde, ist die Schleifenbedingung also erfüllt. Damit wird die Schleife abgebrochen. Denn <code>until</code> ist wie "solange bis" zu lesen. Im Gegensatz zur <code>while</code>-Schleife, deren Anweisungsblock ausgeführt wird, <strong>solange</strong> die Bedingung wahr ist, wird hier der Anweisungsblock ausgeführt, <strong>bis</strong> die Schleifenbedingung wahr ist.</p>

<p>Im Beispiel wird die Schleife einmal durchlaufen, obwohl die Schleifenbedingung gleich im ersten Durchlauf wahr ist. Der Grund ist eben, dass zuerst der abhängige Code ausgeführt und erst dann die Bedingung überprüft wird.</p>

<h3 class="inf">Beachten Sie:</h3>

<p><code>do</code>-Schleifen sind eigentlich keine echten Schleifen, weshalb dort Sprungbefehle wie <code>last</code>, <code>next</code> und <code>redo</code> nicht funktionieren.</p>

<p>Es gibt in Perl auch <code>do</code>-Schleifen, deren Bedingung kein <code>until</code>, sondern ein <code>while</code> vorangestellt ist. Dann müssen Sie die Schleifenbedingung negativ formulieren.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="schleifen_hashes">Schleifen bei Hashes</a></h2>

<p>So wie sich Arrays prima mit <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#foreach">foreach-Schleifen</a> "traversieren", also Element für Element durchlaufen lassen, besteht dieser Wunsch natürlich auch bei <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="hashes.htm">Hashes</a>. Da ein Hash-Element jedoch immer aus zwei Werten besteht, von denen der erste der Schlüssel ist und der zweite der eigentliche Datenwert, ist ein einfaches Traversieren wie mit <code>foreach</code> nicht möglich. Deshalb gibt es für Hashes eine eigene Schleifen-Syntax.</p>

<h3 class="xmp"><a class="an" name="beispiel5">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/schleifen5.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";

my %Familie = (Frau =&gt; "Eva", Tochter =&gt; "Anja", Sohn =&gt; "Florian");
my $Schluessel;
my $Wert;

while (($Schluessel, $Wert) = each(%Familie)) {
  print "$Schluessel hei&amp;szlig;t $Wert&lt;br&gt;\n";
}

while ($Schluessel = each(%Familie)) {
  print "$Schluessel hei&amp;szlig;t $Familie{$Schluessel}&lt;br&gt;\n";
}

print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel deklariert einen Hash namens <code>%Familie</code> und weist ihm drei Schlüssel-Wert-Paare zu. Anschließend werden zwei Skalare <code>$Schluessel</code> und <code>$Wert</code> deklariert, die innerhalb der Schleife benötigt werden. Die Schleife wird als <code>while</code>-Schleife formuliert. Innerhalb der Schleifenbedingung wird jedoch die Perl-Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/listenhashes.htm#each">each</a> aufgerufen. Diese liefert wahlweise eine Liste mit zwei Elementen, nämlich dem jeweils nächsten Schlüssel und dem zugehörigen Wert, oder - im skalaren Kontext - nur den jeweils nächsten Schlüssel des übergebenen Hashes.</p>

<p>Das Beispiel-Script zeigt beide Varianten. In der ersten Variante wird die Liste mit den beiden Elementen in dem Ausdruck <code>($Schluessel, $Wert)</code> gespeichert. <code>$Schluessel</code> enthält dann den jeweils aktuellen Schlüssel des Hashs, und <code>$Wert</code> den zugehörigen Datenwert. Im Beispiel wird die Schleife dreimal durchlaufen und gibt solche Sätze aus wie <code>Frau heißt Eva</code>.</p>

<p>In der zweiten Variante wird die <code>each</code>-Funktion im skalaren Kontext aufgerufen, da der Rückgabewert nur in <code>$Schluessel</code> gespeichert wird. Die innerhalb der Schleife formulierte <code>print</code>-Anweisung gibt daher das Gleiche aus wie in der ersten Variante. Diesmal ist jedoch keine Variable <code>$Wert</code> verfügbar. Über ein Konstrukt wie <code>$Familie{$Schluessel}</code> kann aber auf den jeweils aktuellen Wert zugegriffen werden.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="rekursion">Rekursion</a></h2>

<p>Rekursion ist dann ein Mittel, wenn man mit Schleifen nicht mehr weiter kommt. Ein typischer Anwendungsfall für Rekursion ist das Traversieren von baumartigen Strukturen. Auf gut Deutsch: wenn Sie beispielsweise einen ganzen Verzeichnisbaum einlesen wollen, ohne die Datei- und Verzeichnisstruktur vorher zu kennen, dann ist das ein typischer Fall für eine rekursive Anwendung. Bei der Rekursion wird eine <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="subroutinen.htm">Subroutine</a> definiert, innerhalb derer es eine Anweisung gibt, die die Subroutine von neuem aufruft. Dadurch entsteht ein Verschachtelungseffekt. Rekursion ist allerdings aus Computersicht nicht ganz unkritisch. Deshalb muss sie sauber programmiert sein.</p>

<p>Das folgende Beispiel zeigt, wie Sie eine Datei- und Verzeichnisstruktur ab einem gegebenen Startverzeichnis einlesen und an den aufrufenden Browser HTML-formatiert übermitteln lassen können. Das Beispiel ist allerdings nicht ganz trivial.</p>

<h3 class="xmp"><a class="an" name="beispiel6">Beispiel eines vollständigen CGI-Scripts in Perl:</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/schleifen6.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

use strict;
use CGI::Carp qw(fatalsToBrowser);

my $Startverzeichnis = "/var/www/selfhtml.org/de/dokumente/perl";
my @Alle;
my $Totalbytes = 0;

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Testausgabe&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
print "&lt;h1&gt;Dateibaum&lt;/h1&gt;\n";
print "&lt;pre&gt;Startverzeichnis: &lt;b&gt;$Startverzeichnis&lt;/b&gt;&lt;/pre&gt;\n";
print "&lt;hr noshade size=\"1\"&gt;&lt;pre&gt;\n";

Ermitteln($Startverzeichnis);
@Alle = sort(@Alle);
foreach (@Alle) {
  print "$_\n";
}
print "&lt;/pre&gt;&lt;hr noshade size=\"1\"&gt;\n";
print "&lt;pre&gt;Insgesamt: [$Totalbytes Bytes]&lt;/pre&gt;\n";
print "&lt;/body&gt;&lt;/html&gt;\n";


sub Ermitteln {
  my $Verzeichnis = shift;
  my $Eintrag;
  my $Pfadname;
  my $HTML_Eintrag;
  my $Bytes;
  local *DH;

  unless (opendir(DH, $Verzeichnis)) {
   return;
  }
  while (defined ($Eintrag = readdir(DH))) {
   next if($Eintrag eq "." or $Eintrag eq "..");
   $Pfadname = $Verzeichnis."/".$Eintrag;
   if( -d $Pfadname) {
    $HTML_Eintrag = $Verzeichnis."/".$Eintrag." [VERZEICHNIS]";
   }
   else {
    $Bytes = -s $Pfadname;
    $Totalbytes += $Bytes;
    $HTML_Eintrag = $Verzeichnis."/".$Eintrag." [$Bytes Bytes]";
   }
   push(@Alle, $HTML_Eintrag);
   Ermitteln($Pfadname) if(-d $Pfadname);
  }
 closedir(DH);
}
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Zunächst werden drei wichtige Variablen deklariert: <code>$Startverzeichnis</code> speichert das Verzeichnis, ab dem die Suche starten soll, <code>@Alle</code> ist die Liste, in der später die eingelesenen Einträge gespeichert werden, und <code>$Totalbytes</code> ermittelt die Bytezahlen aller  Dateien.</p>

<p>Danach wird mit der HTML-Ausgabe begonnen. Unterhalb davon steht die Anweisung <code>Ermitteln($Startverzeichnis);</code>. Dies ist ein Aufruf der Subroutine <code>Ermitteln</code>, die etwas weiter unten mit <code>sub Ermitteln</code> eingeleitet wird. Diese Subroutine ist zugleich diejenige, die sich in dem Anweisungsblock, den sie einschließt, in ihrer vorletzten Anweisung selbst wieder aufruft und so die Rekursion bewirkt.</p>

<p>Mit der Anweisung <code>Ermitteln($Startverzeichnis);</code> passiert damit das gesamte Einlesen der Datei- und Verzeichnisstruktur. Anschließend wird die Liste mit der Funktion <code>sort</code> alphabetisch sortiert und dann Eintrag für Eintrag aus einer <code>foreach</code>-Schleife heraus ausgegeben.</p>

<p>Das Herzstück des Scripts ist die Subroutine <code>Ermitteln</code>. Darin wird zunächst eine Reihe von Arbeitsvariablen deklariert. Da die Subroutine sich ja selber wieder aufruft, stellt sich die Frage, ob es dabei nicht zu einem Kuddelmuddel mit den Namen der Variablen kommt. Die Antwort ist nein. Denn jedes Ausführen der Subroutine erzeugt eine eigene Instanz der Routine im Arbeitsspeicher, und da die Variablen lokal mit <code>my</code> deklariert sind, bleibt ihre Gültigkeit auf eine Instanz beschränkt.<br>
Eine offensichtliche Ausnahme bildet die Anweisung <code>local *DH</code>, die das Verzeichnishandle <code>DH</code> lokal deklariert. Da <code>my</code> nicht auf Datei-/Verzeichnishandles (bzw. Typeglobs) angewendet werden kann, wird hier zu dieser Lösung gegriffen, die intern zwar etwas anders arbeitet, aber den gewünschten Effekt hat. Eine andere Variante wäre, das <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../module/standardmodule.htm">Standardmodul</a> <code>Symbol</code> zu verwenden und sich in jeder Instanz der Subroutine ein neues Verzeichnishandle zu schaffen. Das Verfahren mag "sauberer" erscheinen, ist es aber im Endeffekt nicht. Außerdem ist die Variante mit <code>local</code> bedeutend schneller.<br>
Die vielen Instanzen der Subroutine bei vielen Verzeichnissen führen aber auch dazu, dass immer mehr Arbeitsspeicher benötigt wird. Das ist ein wichtiger Nachteil der Rekursion. Konstrukte mit vielen rekursiven Selbstaufrufen sollten Sie daher in CGI-Scripts, die auf öffentlichen Webservern sehr häufig und in mehreren Prozessen gleichzeitig aufgerufen werden können, vermeiden.</p>

<p>Die Subroutine <code>Ermitteln</code> erwartet einen Verzeichnispfadnamen, der ihr übergeben wird. Mit <code>$Verzeichnis&nbsp;=&nbsp;shift;</code> wird der übergebene Pfadname im Skalar <code>$Verzeichnis</code> gespeichert (siehe dazu auch die Perl-Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/listenhashes.htm#shift">shift</a>). Anschließend wird mit der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/einausgabe.htm#opendir">opendir</a> das übergebene Verzeichnis geöffnet. Seine Einträge werden in einer <code>while</code>-Schleife mit der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/einausgabe.htm#readdir">readdir</a> eingelesen. Die beiden Einträge mit den Werten <code>.</code> und <code>..</code>, die in jedem Verzeichnis vorkommen und das aktuelle bzw. das übergeordnete Verzeichnis symbolisieren, werden mit dem Sprungbefehl <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="sprungbefehle.htm#next">next</a> übersprungen. Andernfalls würde sich die Rekursion in einer Endlosschleife verheddern.</p>

<p>Mit dem <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/dateiverwaltung.htm#dateitest">Dateitestoperator</a> <code>-d</code> in <code>if(&nbsp;-d&nbsp;$Pfadname)</code> wird abgefragt, ob der jeweils aktuelle Verzeichniseintrag wieder ein Verzeichnis, also ein Unterverzeichnis, ist. Abhängig davon wird ein HTML-Eintrag für die auszugebende Liste vorbereitet. Weiter unten wird dann mit <code>-d</code> noch einmal abgefragt, ob der Eintrag ein Unterverzeichnis ist, und davon abhängig die Subroutine <code>Ermitteln</code> mit dem Unterverzeichnis erneut aufgerufen.</p>

<p>Nachdem die Verzeichnisstruktur abgearbeitet ist und alle Instanzen der Subroutine <code>Ermitteln</code> beendet sind, geht es im oberen Teil des Scripts weiter mit <code>@Alle = sort(@Alle);</code>.</p>



<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" class="doc">
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a>
</td></tr>
<tr><td class="doc"><a href="sprungbefehle.htm"><img src="../../src/next.gif" width="10" height="10" border="0" hspace="10" alt="weiter"></a></td>
<td width="100%"><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="sprungbefehle.htm">Sprungbefehle</a>
</td></tr>
<tr>
<td class="doc"><a href="bedingt.htm"><img src="../../src/prev.gif" width="10" height="10" border="0" hspace="10" alt="zurück"></a></td>
<td><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="bedingt.htm">Bedingte Anweisungen</a>
</td>
</tr>
<tr><td colspan="2" class="doc">&nbsp;</td>
</tr>
<tr>
<td colspan="2" class="nav"><a class="an" name="bottom"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Sprachelemente</a></td>
</tr>
</table>

<p>&copy; 2007 <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../editorial/impressum.htm">Impressum</a></p>

</body>
</html>
