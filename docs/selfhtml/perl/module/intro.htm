<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>SELFHTML: Perl / Perl-Module / Hinweise zum Arbeiten mit Modulen</title>
<link rel="stylesheet" type="text/css" href="../../src/selfhtml.css">
<meta name="description"    content="Welche Möglichkeiten es gibt, Module einzubinden, und wann die Verwendung von Modulen sinnvoll ist.">
<meta name="keywords"       content="SELFHTML, Perl, Module, Perlmodule, @INC, @EXPORT, @EXPORT_OK, use, require">
<meta name="author"         content="Redaktion SELFHTML, selfhtml81@selfhtml.org">
<meta name="robots"         content="noindex, nofollow">
<meta name="DC.Publisher"   content="SELFHTML e. V.">
<meta name="DC.Date"        content="2005-11-09T00:29:27+01:00">
<meta name="DC.Identifier"  content="http://de.selfhtml.org/perl/module/intro.htm">
<meta name="DC.Language"    content="de">
<meta name="DC.Rights"      content="../../editorial/copyright.htm">
<meta name="DC.Date.created" content="2001-10-27T08:00+01:00">
<meta name="SELF.Pagetype"  content="page">
<link rel="alternate" type="application/atom+xml" title="SELFHTML-Weblog (Atom, gesamt)" href="http://aktuell.de.selfhtml.org/weblog/atom-feed">
<link rel="alternate" type="application/rss+xml" title="SELFHTML-Weblog (RSS, Auszüge)" href="http://aktuell.de.selfhtml.org/weblog/rss-feed">
<link rel="shortcut icon" type="image/x-icon" href="../../src/favicon.ico">
<link rel="author" title="Impressum" href="../../editorial/impressum.htm">
<link rel="contents" title="Inhaltsverzeichnis" href="../../navigation/inhalt.htm">
<link rel="index" title="Stichwortverzeichnis" href="../../navigation/stichwort.htm">
<link rel="search" title="Suche" href="../../navigation/suche/index.htm">
<link rel="help" title="Hilfe" href="../../editorial/index.htm">
<link rel="copyright" title="Urheberrecht" href="../../editorial/copyright.htm">
<link rel="top" title="SELFHTML" href="../../index.htm">
<link rel="up" title="Perl-Module" href="index.htm">
<link rel="next" title="Standardmodule von Perl" href="standardmodule.htm">
<link rel="prev" title="Funktionen für Module und Packages" href="../funktionen/module.htm">
<link rel="last" title="Modul CGI: Funktionen für die CGI-Programmierung" href="cgi.htm">
</head>
<body>

<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr>
<td colspan="2" class="nav"><a class="an" name="top"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Module</a></td>
</tr>
<tr>
<td class="doc" width="110"><a href="../../index.htm"><img src="../../src/logo.gif" width="106" height="109" border="0" alt="SELFHTML"></a></td>
<td class="docbot" width="100%"><h1 class="ph1">Einführung in das Arbeiten mit Modulen</h1></td>
</tr>
<tr>
<td class="doctop">
<img src="../../src/dokx.gif" width="30" height="20" vspace="6" alt="Informationsseite">
</td>
<td valign="top" nowrap="nowrap">
<p>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#allgemeines">Allgemeines zu Modulen in Perl</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#require_use">Module einbinden mit require und use</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#speicherorte_inc">Speicherorte für Module und die Liste @INC</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#adressierungssyntax">Adressierungs-Syntax beim Einbinden von Modulen</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#packages_module">Packages und Module</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#use_erweitert">Erweiterte Verwendung von use (@EXPORT, @EXPORT_OK und qw)</a><br>
<img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#perldoc">Moduldokumentationen lesen mit perldoc</a><br>
</p>
</td>
</tr><tr><td colspan="2" class="doc">&nbsp;<a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a>&nbsp;</td></tr>
</table>



<h2><a class="an" name="allgemeines">Allgemeines zu Modulen in Perl</a></h2>

<p>Beim Programmieren werden Sie schnell feststellen, dass Sie bestimmte Routine-Aufgaben immer wieder benötigen. Immer wieder müssen Dateien eingelesen werden, in einer CGI-Umgebung müssen immer wieder Formulare verarbeitet werden, zur Kommunikation mit fernen Rechnern im Internet muss immer wieder eine Internet-Socket-Verbindung aufgebaut werden usw. Nun bietet der Perl-Interpreter ja bereits eine Menge <img src="../../src/kap.gif" width="15" height="13" alt="Kapitel">&nbsp;<a href="../funktionen/index.htm">Funktionen</a> an, die solche Routine-Aufgaben bewältigen. Doch je mehr solcher Funktionen im Perl-Interpreter fest eingebaut sind, desto größer, langsamer und ressourcen-unfreundlicher wird der Interpreter. Daher gibt es einen zweiten Typ Funktionen, nämlich solche, die nicht direkt in den Perl-Interpreter eingebaut sind, sondern in Form von Perl-Scripts zur Verfügung stehen. Diese speziellen Perl-Scripts werden <strong>Module</strong> genannt. Module stellen Funktionen (aber auch Variablen) für bestimmte Routine-Aufgaben zur Verfügung. Um in Ihren eigenen Perl-Scripts solche Funktionen verwenden zu können, binden Sie einfach die Module ein, in denen die gewünschten Funktionen stehen. Anschließend können Sie auf die Funktionen und Variablen der Module zugreifen.</p>

<p>Mittlerweile gibt es tausende von Perl-Modulen, die frei verfügbar sind. Es gibt praktisch kaum mehr ein Programmiergebiet, für das es nicht schon Module mit fertigen leistungsstarken Funktionen gibt. Die Module werden der Allgemeinheit von eifrigen und fähigen Perl-Programmierern im Internet zur Verfügung gestellt. Einige dieser Module konkurrieren miteinander, und im Laufe der Zeit stellt sich heraus, dass eines der Module in der Praxis am tauglichsten ist. Natürlich gibt es auch Module, die häufiger zum Einsatz kommen als andere. Letzteres hat dazu geführt, dass mittlerweile zwischen zwei wichtigen Klassen von öffentlich verfügbaren Modulen unterschieden wird: es gibt <strong>Standardmodule</strong> und <strong>CPAN-Module</strong>. Standardmodule sind solche, die zusammen mit dem Perl-Interpreter ausgeliefert werden, und CPAN-Module stehen im Internet zum Download zur Verfügung. Standardmodule erhalten dadurch natürlich einen wesentlich höheren Verbreitungsgrad. Da sie bei jeder typischen Installation des Perl-Interpreters mit installiert werden, können sie auch fast so bedenkenlos verwendet werden wie die fest eingebauten Funktionen von Perl. Denn auch wenn ein Perl-Script auf einen anderen Rechner portiert wird und dort seine Arbeit verrichten soll, stehen die gleichen Module zur Verfügung - vorausgesetzt, eine entsprechend aktuelle Version des Perl-Interpreters ist installiert. Wenn Sie dagegen CPAN-Module downloaden und in Ihre eigenen Scripts einbinden, ist die Portierung eines Scripts auf einen anderen Rechner nicht ganz so unproblematisch. Denn das Script funktioniert dort erst, nachdem die gleichen CPAN-Module installiert sind.<br>
Innerhalb dieses Kapitels finden Sie einen Abschnitt über die <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="standardmodule.htm">Standardmodule von Perl</a> und einen Abschnitt über <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="cpanmodule.htm">CPAN-Module</a>. Dort erhalten Sie eine Übersicht, welche Module zur Verfügung stehen.</p>

<p>Daneben ist es selbstverständlich auch möglich, eigene Module zu schreiben. Für größere Perl-Scripts ist es auch besser, den Code so zu verteilen, dass es nur noch ein schlankes Hauptscript mit eingebundenen Modulen für spezielle Aufgaben gibt. Angenommen, Sie programmieren ein Perl-Script, das eine Datei mit einer bestimmten Datenstruktur verarbeitet. Bei dieser Aufgabe könnten Sie ein Modul schreiben, das alle Funktionen zum Einlesen der Datei in geeignete Variablen und zum Zurückschreiben verarbeiteter Daten in die Datei enthält. Im Hauptscript können Sie dann einfach dieses Modul einbinden und auf dessen Funktionen und Variablen zugreifen. Sollte sich dann beispielsweise das Dateiformat der Datendatei ändern, muss nur das Modul umgeschrieben werden, während das Hauptscript und mögliche andere Module davon unberührt bleiben. Typische Beispiele zum Erstellen projekteigener Module finden Sie im Abschnitt über <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/objekte.htm">objektorientierte Programmierung</a>. Das ist kein Zufall. Denn modul-orientiertes Arbeiten im modernen Stil und objektorientiertes Programmieren gehören bei Perl eng zusammen.</p>

<p>Perl-Module sind also (meistens) selber Perl-Scripts. Es handelt sich jedoch um Scripts, bei denen ein paar Regeln und Besonderheiten zu beachten sind, auf die im folgenden noch näher eingegangen wird.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="require_use">Module einbinden mit require oder use</a></h2>

<p>Zum Einbinden von Modulen stehen in Perl die Funktionen <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/module.htm#use">use</a> und <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/module.htm#require">require</a> zur Verfügung. Im allgemeinen wird heute empfohlen, die Funktion <code>use</code> zu verwenden, weil sie konsequenter den Modul-Gedanken verfolgt. Bei Verwendung von <code>use</code> wird das Modul ganz zu Beginn des Hauptscripts eingebunden. Es steht also zur Verfügung, bevor überhaupt die erste Code-Zeile Ihres Scripts ausgeführt wird. Bei Verwendung von <code>require</code> wird die andere Datei dagegen erst an der Stelle eingebunden, an der die <code>require</code>-Anweisung steht. Vor dem entsprechenden Aufruf stehen also Funktionen oder Variablen des Moduls noch nicht zur Verfügung, und falls der <code>require</code>-Aufruf beispielsweise in einem Zweig einer bedingten Anweisung steht, wird er nur dann ausgeführt, wenn das Script in den entsprechenden Zweig gelangt. Ein Beispiel soll dies verdeutlichen.</p>

<h3 class="xmp">Beispiel - Teil 1: Moduldatei <var>Testmodul.pm</var></h3>
<pre>
#!/usr/bin/perl -w

print "Hier meldet sich das Modul \"Testmodul.pm\"\n";

1;
</pre>

<h3 class="xmp">Beispiel - Teil 2a: Hauptscript <var>test_require.pl</var></h3>
<pre>
#!/usr/bin/perl -w

print "Hier meldet sich das Hauptscript\n";
require Testmodul;
</pre>

<h3 class="xmp">Beispiel - Teil 2b: Hauptscript <var>test_use.pl</var></h3>
<pre>
#!/usr/bin/perl -w

print "Hier meldet sich das Hauptscript\n";
use Testmodul;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Der erste Teil des Beispiels zeigt den Code der Datei <var>Testmodul.pm</var>. Die Beispielteile 2a und 2b zeigen jeweils ein Perl-Script, in dem diese Moduldatei eingebunden wird. Im Script <var>test_require.pl</var> (2a) wird das Modul mit <code>require</code> eingebunden, im Script <var>test_use.pl</var> (2b) dagegen mit <code>use</code>. Beide Scripts (2a und 2b) sind identisch bis auf den unterschiedlichen Funktionsaufruf. Das Ergebnis der Ausgabe ist jedoch verschieden. In 2a (also beim Einbinden des Moduls mit <code>require</code> lautet es:<br>
<code>Hier meldet sich das Hauptscript<br>
Hier meldet sich das Modul "Testmodul.pm"</code><br>
In 2b dagegen (Einbinden des Moduls mit <code>use</code>) lautet die Ausgabe dagegen:<br>
<code>Hier meldet sich das Modul "Testmodul.pm"<br>
Hier meldet sich das Hauptscript</code><br>
Der Grund ist, dass ein mit <code>use</code> eingebundenes Modul ausgeführt wird, bevor der Code des einbindenden Scripts ausgeführt wird. Bei <code>require</code> wird das eingebundene Script dagegen an der Stelle ausgeführt, an der es eingebunden wird.</p>

<p>Auf den ersten Blick spricht dieser Unterschied eher für die Verwendung von <code>require</code> und weniger für den von <code>use</code>. In der Praxis ist es jedoch so, dass Moduldateien meist keinen direkt auszuführenden Code enthalten, sondern aus Funktionen (Subroutinen) bestehen, die dann im einbindenden Script aufgerufen werden können.</p>

<h3 class="xmp">Beispiel - Teil 1: Moduldatei <var>Testmodul.pm</var></h3>
<pre>
#!/usr/bin/perl -w

sub Modulprint {
  print "Hier meldet sich das Modul \"Modul.pm\"\n";
}

1;
</pre>

<h3 class="xmp">Beispiel - Teil 2a: Hauptscript <var>test_require.pl</var></h3>
<pre>
#!/usr/bin/perl -w

print "Hier meldet sich das Hauptscript\n";
require Testmodul;
Modulprint();
</pre>

<h3 class="xmp">Beispiel - Teil 2b: Hauptscript <var>test_use.pl</var></h3>
<pre>
#!/usr/bin/perl -w

print "Hier meldet sich das Hauptscript\n";
use Testmodul;
Modulprint();
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>In diesem Beispiel-Ensemble erzeugen die Scripts aus 2a und 2b die gleiche Ausgabe, nämlich:<br>
<code>Hier meldet sich das Hauptscript<br>
Hier meldet sich das Modul "Testmodul.pm"</code><br>
Der Grund ist, dass der Code des Moduls nun in einer Subroutine namens <code>Modulprint</code> steht. In den einbindenden Scripts <var>test_require.pl</var> und <var>test_use.pl</var> wird mit der Anweisung <code>Modulprint();</code> die entsprechende Funktion im eingebundenen Modul aufgerufen.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Ein weiterer wichtiger Unterschied zwischen <code>use</code> und <code>require</code> ist, dass Sie bei <code>use</code> genau angeben können, welche Funktions- und Variablennamen Sie aus einem Modul importieren wollen, während <code>require</code> diese Möglichkeit nicht anbietet. Mehr dazu weiter unten im Abschnitt <img src="../../src/down.gif" width="14" height="10" alt="nach unten">&nbsp;<a href="#use_erweitert">Erweiterte Verwendung von use</a>.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="speicherorte_inc">Speicherorte für Module und die Liste @INC</a></h2>

<p>Moduldateien können in einem der Verzeichnisse abgelegt werden, die in der <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/vordefiniert.htm">vordefinierten Variablen</a> <code>@INC</code> definiert sind, oder in einem Unterverzeichnis davon. Bei einer typischen Perl-Installation enthält die Liste <code>@INC</code> eine Reihe von Unterverzeichnissen des Perl-Installationsverzeichnisses sowie das jeweils aktuelle Verzeichnis, also meistens das Verzeichnis, in dem das die Moduldatei einbindende Hauptscript liegt.</p>

<p>Das Ablegen von Moduldateien im Verzeichnis bzw. einem Unterverzeichnis des Hauptscripts ist dann sinnvoll, wenn die Moduldateien von keinem anderen Script verwendet werden. Wenn die Moduldateien dagegen so allgemein geschriebenen Code enthalten, dass Sie sie für verschiedene Scripts verwenden können, dann ist es besser, Sie legen die Moduldateien in einem der anderen Verzeichnisse ab, die in <code>@INC</code> genannt werden.</p>

<p>Um zu entscheiden, wo Sie Moduldateien ablegen können, müssen Sie also erst einmal die Liste der erlaubten Verzeichnisse kennen. Das folgende einfache Perl-Script hilft dabei.</p>

<h3 class="xmp"><a class="an" name="beispiel">Beispiel-Script zur Ausgabe von @INC (als CGI-Script):</a></h3>

<p><img src="../../src/dokf.gif" width="15" height="10" alt="Beispiel-Seite">&nbsp;<a href="http://de.selfhtml.org/cgi-bin/812/modulintro.pl">Anzeigebeispiel: So sieht's aus</a> (Zum Aufruf des Scripts ist eine Internet-Verbindung erforderlich)</p>

<pre>
#!/usr/bin/perl -w

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Erlaubte Modulverzeichnisse&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
print "&lt;h1&gt;Verzeichnisse zum Ablegen von Moduldateien:&lt;/h1&gt;\n";
foreach (@INC) {
 print "&lt;tt&gt;$_&lt;/tt&gt;&lt;br&gt;\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Script gibt einfach den Inhalt der Liste <code>@INC</code> zeilenweise als HTML-Code aus. Wenn Sie den Code als pl-Datei im CGI-Verzeichnis abspeichern und die pl-Datei von einem Browser anfordern lassen, werden die verfügbaren Verzeichnispfade angezeigt. In der üblichen Konfiguration ist der letzte Eintrag der Liste ein einzelner Punkt (<code>.</code>). Dies steht für "aktuelles Verzeichnis" und bewirkt, dass der Perl-Interpreter, nachdem er eine eingebundene Datei in den allgemeinen Verzeichnispfaden nicht gefunden hat, im aktuellen Verzeichnis sucht.</p>

<p>Falls Sie Ihre Moduldatei in keinem der Verzeichnisse ablegen wollen, die von <code>@INC</code> angeboten werden, können Sie sie auch woanders ablegen. Dann müssen Sie allerdings vor dem Einbinden einer solchen Moduldatei die Liste <code>@INC</code> um den Verzeichnispfad erweitern, in dem die Moduldatei liegt.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

use lib "/httpd/docs/cgi-shared/speziell";
use lib "/httpd/docs/cgi-shared/module";

print "Content-type: text/html\n\n";
print '&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;', "\n";
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Erlaubte Modulverzeichnisse&lt;/title&gt;\n";
print "&lt;/head&gt;&lt;body&gt;\n";
print "&lt;h1&gt;Verzeichnisse zum Ablegen von Moduldateien:&lt;/h1&gt;\n";
foreach (@INC) {
 print "&lt;tt&gt;$_&lt;/tt&gt;&lt;br&gt;\n";
}
print "&lt;/body&gt;&lt;/html&gt;\n";
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Durch eine Anweisung vom Typ <code>use lib</code> mit anschließender Angabe eines Verzeichnispfades wird dieser Pfad an den Anfang der Liste <code>@INC</code> übernommen. Das Beispiel-Script ist das gleiche CGI-Script zur Ausgabe der Pfade von <code>@INC</code> wie zuvor. In diesem Fall zeigt es, dass die so definierten eigenen Pfade mit in die Liste aufgenommen wurden.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="adressierungssyntax">Adressierungs-Syntax beim Einbinden von Modulen</a></h2>

<p>Module können in einem der Verzeichnisse von <code>@INC</code> oder einem Unterverzeichnis davon abgelegt werden. Daraus ergeben sich dann die möglichen Formen der Adressierung eines Moduls beim Einbinden mit <code>use</code> oder <code>require</code>.</p>

<h3 class="xmp">Beispiele für Module in einem @INC-Verzeichnis:</h3>
<pre>
require "Statistik.pm";
require Statistik;
use "Statistik.pm";
use Statistik;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Alle vier Beispiele zeigen das Einbinden eines Moduls, das in einer Datei namens <code>Statistik.pm</code> abgelegt ist. Die Datei befindet sich direkt in einem der Verzeichnisse, die in der Liste <code>@INC</code> als mögliche <img src="../../src/up.gif" width="14" height="10" alt="nach oben">&nbsp;<a href="#speicherorte_inc">Speicherorte für Module</a> zur Verfügung stehen. Für <code>require</code> und <code>use</code> gelten die gleichen Regeln. Entweder notieren Sie den vollständigen Dateinamen der Moduldatei in Anführungszeichen (Moduldateien sollten die Endung <code>.pm</code> haben), oder Sie notieren den Dateinamen ohne die Endung <code>.pm</code> ohne Anführungszeichen.</p>

<p>Wenn sich die Datei in einem Unterverzeichnis eines der Verzeichnisse von <code>@INC</code> befindet, ist die relative Pfadangabe erforderlich.</p>

<h3 class="xmp">Beispiele für Module in Unterverzeichnissen eines @INC-Verzeichnisses:</h3>
<pre>
require "Berechnungsmodule/Statistik.pm";
require Berechnungsmodule::Statistik;
use "Berechnungsmodule/Statistik.pm";
use Berechnungsmodule::Statistik;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Wieder zeigen alle vier Beispiele das Einbinden eines Moduls <code>Statistik.pm</code>. Die Datei befindet sich unterhalb eines der <code>@INC</code>-Verzeichnisse in einem Unterverzeichnis namens <code>Berechnungsmodule</code>. In diesem Fall ist allerdings die Syntax ohne Anführungszeichen vorzuziehen. Denn wenn Sie mit Anführungszeichen arbeiten, müssen Sie die einzubindende Datei mit "vollem" Namen ansprechen. Die Syntax ohne Anführungszeichen kommt dagegen ohne die Dateiendung <var>.pm</var> aus. Es wird erwartet, dass die eingebundene Moduldatei diese Endung hat. Die Zeichenfolge, die die Verzeichnistrenner symbolisiert, also Hierarchien darstellt, besteht aus einem doppelten Doppelpunkt (<code>::</code>).</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="packages_module">Packages und Module</a></h2>

<p>So einfach das Konzept der Module in Perl erst einmal klingt - es bringt doch ein paar Probleme mit sich. Angenommen, in Ihrem eigenen Perl-Script definieren Sie eine Subroutine namens <code>get_data()</code>. In dem gleichen Script binden Sie ein Modul ein, in dessen Code ebenfalls eine Subroutine namens <code>get_data()</code> definiert ist. Damit der Perl-Interpreter beim Aufruf von <code>get_data()</code> weiß, welche der beiden Funktionen gemeint ist, muss es eine Möglichkeit geben, ihm mitzuteilen, welche der Funktionen gemeint ist.</p>

<p>Zu diesem Zweck gibt es in Perl das Konzept der <strong>Namensräume</strong>. Jeder Namensraum stellt ein so genanntes <strong>Package</strong> (<i>engl. für Paket</i>) dar. Jedes Perl-Script, in dem Sie keine besondere Angabe machen, welchen Namensraum (welches Package) Sie meinen, benutzt ein <strong>Default-Package</strong>. Es hat den Namen <code>main</code>.</p>

<h3 class="xmp">Beispiel:</h3>
<pre>
#!/usr/bin/perl -w

$Ausgabetext = "Hallo alte Welt. ";
print $Ausgabetext;

package NeueWelt;
$Ausgabetext = "Hallo neue Welt. ";
print $Ausgabetext;

package main;
print $Ausgabetext;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel verdeutlicht den Default-Namensraum mit dem Namen <code>main</code>. Zunächst wird ein <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../sprache/skalare.htm">Skalar</a> namens <code>$Ausgabetext</code> definiert und mit einem Wert belegt. Dieser Wert wird gleich anschließend ausgegeben. Da bis zum Ausführungszeitpunkt noch keine weitere Angabe zum Namensraum gemacht wurde, befindet sich das Script im Defaultnamensraum <code>main</code>. Im zweiten Schritt wird mit Hilfe der Funktion <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/module.htm#package">package</a> ein neuer eigener Namensraum mit Namen <code>NeueWelt</code> definiert. Unterhalb davon wird wiederum ein Skalar namens <code>$Ausgabetext</code> definiert, diesmal mit anderem Wert. Dieser neue Wert wird wieder ausgegeben.</p>

<p>Zu diesem Ausführungszeitpunkt existieren nun zwei Skalare namens <code>$Ausgabetext</code> - nämlich der aus dem Package <code>NeueWelt</code> und der aus dem Default-Package <code>main</code>. Zur Kontrolle wird im Beispiel wieder auf das Package <code>main</code> "umgeschaltet". Dazu wird wieder die Funktion <code>package</code> aufgerufen, diesmal aber mit dem Defaultnamen <code>main</code>. Von den beiden existierenden Skalaren dieses Namens wird nun der im Script zuerst definierte ausgegeben, also derjenige, der zum Default-Namensraum <code>main</code> gehört. Der unterste <code>print</code>-Aufruf gibt also wieder <code>Hallo alte Welt.</code> aus.</p>

<p>Wie das Beispiel zeigt, lässt sich der Namensraum innerhalb einer Scriptdatei also beliebig wechseln. Dadurch lässt sich ein hohes Maß an Flexibilität erreichen. Von dieser Flexibilität profitieren die Module in Perl. Ein Modul kann nämlich durch Anwendung der Package-Technik beispielsweise mehrere (Objekt-)Klassen in einer Moduldatei unterbringen oder andere Module (die ja auch aus Packages bestehen) erweitern, auch wenn die Technik zugegebenermaßen etwas unsauber ist. Ein einfaches Beispiel soll diesen Zusammenhang verdeutlichen.</p>

<h3 class="xmp">Beispiel - Teil 1: Moduldatei <var>Testmodul.pm</var></h3>
<pre>
$Modultext = "Dies ist der Inhalt des Skalars \$Modultext\n";

package Testmodul;
$Text = "Dies ist der Inhalt des Skalars \$Text\n";

1;
</pre>

<h3 class="xmp">Beispiel - Teil 2: Hauptscript, z.B. <var>test.pl</var></h3>
<pre>
#!/usr/bin/perl -w

use Testmodul;

print $Modultext;
print $Testmodul::Text;
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Der erste Teil des Beispiels ist das Modulscript, der zweite Teil das Hauptscript. Das Modulscript erhält im Beispiel den Namen <var>Testmodul.pm</var> und wird im Hauptscript mit der Anweisung <code>use&nbsp;Testmodul;</code> eingebunden.</p>

<p>Die Moduldatei beginnt mit der Definition eines Skalars namens <code>$Modultext</code>. Da zuvor kein anderes <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/module.htm#package">package</a> aufgerufen wird, ist das Package aktiv, in das das Modul eingebunden wird. Alles, was innerhalb dieses Namensraums definiert wird, befindet sich somit im Namensraum <code>main</code> des einbindenden Scripts. Im Beispiel gibt das einbindende Script, also das Hauptscript, mit <code>print&nbsp;$Modultext;</code> in seinem Default-Namensraum <code>main</code> einfach die Variable aus, die im Namensraum <code>main</code> der Moduldatei definiert wurde. <code>$Modultext</code> wurde also direkt im Default-Namensraum des einbindenden Scripts definiert. Damit wurde das Package <code>main</code> durch das Modul erweitert.</p>

<p>Im Modulscript, also in der <var>Modul.pm</var>, wird im weiteren Verlauf jedoch mit <code>package</code> ein neuer Namensraum definiert. Er hat den gleichen Namen wie der Vorname der Moduldatei, nämlich <code>Testmodul</code>. Im einbindenden Hauptscript kann auf Variablen und Funktionen, die im Modul unterhalb des Packages <code>Testmodul</code> definiert werden, nur durch Angabe des entsprechenden Namensraums zugegriffen werden. Die Anweisung <code>print&nbsp;$Testmodul::Text;</code> zeigt, wie auf das andere Package zugegriffen wird. Dem Namen einer Variablen oder einer Funktion wird der Name des Packages und ein doppelter Doppelpunkt (<code>::</code>) vorangestellt. Skalare, Listen und Hashes beginnen weiterhin mit ihren typischen Kennzeichen <code>$</code>, <code>@</code> und <code>%</code>. Zwischen dem Kennzeichen und dem Variablennamen steht jedoch der Package-Name und der doppelte Doppelpunkt.</p>

<h3 class="inf">Beachten Sie:</h3>

<p>Das Ansprechen von Variablen oder Funktionen in anderen Packages oder Modulen mit <code>Package-Name::Variablen/Funktionsname</code> ist nicht möglich, wenn die Variablen oder Funktionen mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/kontrolle.htm#my">my</a> deklariert sind. Die Anwendung von <code>my</code> wird deshalb auch in der Praxis empfohlen, um eine saubere Kapselung von Variablen und Funktionen, die nur innerhalb eines Packages oder Moduls von Bedeutung sind, zu erreichen.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="use_erweitert">Erweiterte Verwendung von use (@EXPORT, @EXPORT_OK und qw)</a></h2>

<p>Da Module selbst wieder andere Module einbinden können und einzelne Module aber eigentlich Dateninseln darstellen sollen, stößt die Technik des Erweiterns von Packages irgendwann an ihre Grenzen. Um "öffentliche" Schnittstellen von Modulen festlegen zu können, haben Sie die Möglichkeit, einzelne Symbole (also Variablennamen oder Funktionsnamen beispielsweise) in beiden Packages (also dem einbindenden und dem eingebundenen) sichtbar zu machen. Sie können die Symbole aus dem Modul exportieren bzw. in das einbindende Script oder Modul importieren.</p>

<p>Ein Modul kann deshalb erzwingen, dass Sie beim Einbinden genau angeben müssen, welche Variablen oder Funktionen Sie in den Namensraum des einbindenden Scripts importieren möchten. Dazu gibt es das so genannte <strong>Exporter-Modul</strong>, ein Standardmodul von Perl. Dieses Modul erwartet im eingebundenen Package zwei Listen namens <code>@EXPORT</code> und <code>@EXPORT_OK</code>. Ein Modul kann das Exporter-Modul einbinden und diese beiden Listen mit denjenigen Variablen- und Funktionsnamen füllen, die in ein einbindendes Modul überhaupt exportiert werden können. Im einbindenden Script wiederum können Sie angeben, welche der exportierbaren Namen des Moduls Sie in den Namensraum Ihres Scripts importieren möchten.</p>

<h3 class="xmp">Beispiel - Teil 1: Moduldatei <var>Testmodul.pm</var></h3>
<pre>
package Testmodul;
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(%FORMULARFELDER);
@EXPORT_OK = qw($Zeitstempel @Logdaten Besteller_ermitteln);

# hier folgt der Code des Moduls ...
# in dem Code kommen unter anderem vor:
# ein Hash namens %FORMULARFELDER
# ein Skalar namens $Zeitstempel
# eine Liste namens @Logdaten
# eine Funktion namens Besteller_ermitteln

1;
</pre>

<h3 class="xmp">Beispiel - Teil 2: Hauptscript, z.B. <var>test.pl</var></h3>
<pre>
#!/usr/bin/perl -w

use Testmodul qw($Zeitstempel);

# hier folgt der Code des Scripts ...
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Die Moduldatei bindet im Beispiel mit <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/module.htm#require">require</a> selbst ein Modul ein, nämlich das Standardmodul <code>Exporter</code>. Die Anweisung <code>@ISA = qw(Exporter)</code> definiert die Klasse <code>Exporter</code> als Basisklasse der aktuellen Klasse, die durch das aktuelle Package (im Beispiel also <code>Testmodul</code>) repräsentiert wird. Damit wird die Methode <code>import</code>, die im Modul bzw. der Klasse <code>Exporter</code> definiert ist, an die Klasse <code>Testmodul</code> vererbt. Diese etwas kompliziert klingenden Erläuterungen sind durch den Sprachgebrauch der objektorientierten Programmierung bedingt.</p>

<p>Die Liste <code>@EXPORT</code> kann Namen der Module aufnehmen, die in den Namensraum eines einbindenden Scripts standardmäßig exportiert werden, wenn bei der Einbindung keine spezielle Importliste angegeben ist. Die Liste <code>@EXPORT_OK</code> nimmt dagegen die Namen auf, die ein einbindendes Script maximal in den eigenen Namensraum übernehmen kann, aber nicht übernehmen muss.</p>

<p>Im obigen Beispiel ist in der Moduldatei bei der <code>@EXPORT</code>-Liste nur ein Name notiert, nämlich ein Hash namens <code>%FORMULARFELDER</code>. Diese Variable wird in den Namensraum eines einbindenden Scripts exportiert, wenn bei der <code>use</code>-Anweisung keine Importliste angegeben wird. Bei der Liste <code>@EXPORT_OK</code> sind im Beispiel drei Namen notiert: ein Skalar namens <code>$Zeitstempel</code>, eine Liste namens <code>@Logdaten</code> und eine Subroutine namens <code>Besteller_ermitteln</code>.<br>
Zur Notation der Listen bietet sich besonders der Operator <code>qw</code> an, da er es ermöglicht, die Variablennamen ohne ständige Anführungszeichen notieren zu können. <code>qw($Zeitstempel @Logdaten Besteller_ermitteln)</code> entspricht eigentlich der Notation <code>('$Zeitstempel', '@Logdaten', 'Besteller_ermitteln')</code>, ist aber übersichtlicher.<br>
Innerhalb der Klammern von <code>qw</code> werden die gewünschten Namen notiert und durch Leerraumzeichen getrennt. Variablennamen erhalten dabei die üblichen Kennzeichen für Skalare, Listen und Hashes.</p>

<p>Das einbindende Script bindet das Modul im Beispiel mit <code>use Testmodul</code> ein und muss in der nachfolgenden Liste angeben, welche der bei <code>@EXPORT</code> oder <code>EXPORT_OK</code> genannten Namen es in den eigenen Namensraum importieren möchte. Im Beispiel wird nur der Skalar <code>$Zeitstempel</code> angegeben und als einziger Name importiert. Wenn Sie die Listenangabe weglassen (im Beispiel also nur <code>use Testmodul;</code> notieren würden), werden die in <code>@EXPORT</code> aufgeführten Namen importiert.</p>



<p class="doc"><a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a><a href="#bottom"><img src="../../src/down.gif" width="14" height="10" border="0" alt="nach unten"></a></p>



<h2><a class="an" name="perldoc">Moduldokumentationen lesen mit perldoc</a></h2>

<p>Module, die Sie nicht selbst geschrieben haben, aber in Ihre Scripts einbinden möchten, müssen Sie natürlich so weit verstehen, dass Sie in der Lage sind, die darin enthaltenen Funktionen richtig aufzurufen, darin definierte Variablen zu kennen und zu benutzen usw. Deshalb sind zumindest alle wichtigen <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="standardmodule.htm">Standardmodule</a> und <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="cpanmodule.htm">Module aus dem CPAN-Verzeichnis</a> dokumentiert. Da separate readme-Dateien aber leicht verloren gehen, stellt Perl die Möglichkeit bereit, die Dokumentation innerhalb der Datei mit dem Quellcode zu notieren. Zum Lieferumfang von Perl gehört das Programm <var>perldoc</var>, mit dem Sie den Dokumentationsteil am Bildschirm ausgeben können.</p>

<p>Das folgende Beispiel zeigt den vollständigen Code eines kleinen Standardmoduls von Perl. Die Aufgabe des Moduls soll hier nicht weiter interessieren. Gezeigt werden soll, wie die Dokumentation in den Quellcode integriert ist.</p>

<h3 class="xmp">Beispiel - die Moduldatei "Nox.pm"</h3>

<pre>
package CPAN::Nox;
use strict;
use vars qw($VERSION @EXPORT);

BEGIN{
  $CPAN::Suppress_readline=1 unless defined $CPAN::term;
}

use base 'Exporter';
use CPAN;

$VERSION = "1.03";
$CPAN::META-&gt;has_inst('Digest::MD5','no');
$CPAN::META-&gt;has_inst('LWP','no');
$CPAN::META-&gt;has_inst('Compress::Zlib','no');
@EXPORT = @CPAN::EXPORT;

*AUTOLOAD = \&amp;CPAN::AUTOLOAD;

1;

__END__

=head1 NAME

CPAN::Nox - Wrapper around CPAN.pm without using any XS module

=head1 SYNOPSIS

Interactive mode:

  perl -MCPAN::Nox -e shell;

=head1 DESCRIPTION

This package has the same functionality as CPAN.pm, but tries to
prevent the usage of compiled extensions during its own
execution. Its primary purpose is a rescue in case you upgraded perl
and broke binary compatibility somehow.

=head1  SEE ALSO

CPAN(3)

=cut
</pre>

<h3 class="xpl">Erläuterung:</h3>

<p>Das Beispiel zeigt den Code des CPAN-Moduls <var>Nox.pm</var>. Der obere Teil der Moduldatei enthält den eigentlich ausführbaren Code des Moduls, und der untere Teil enthält die Dokumentation zum Modul. Die Dokumentation beginnt mit Anweisungen, die in einer neuen Zeile beginnen und als erstes Zeichen ein Gleichheitszeichen (<code>=</code>) haben. Mit <code>=head1&nbsp;NAME</code> wird beispielsweise eine Überschrift mit dem Titel <code>NAME</code> erzeugt. Alles, was danach kommt, wird bis zur beendenden Anweisung <code>=cut</code> als Dokumentation interpretiert.</p>

<p>Um die Dokumentation separat lesen zu können, müssen Sie auf der Kommandozeile Ihres Betriebssystems eingeben:<br>
<code>perldoc [Pfad]Modulname</code><br>
Unter Windows können Sie die DOS-Eingabeaufforderung benutzen oder ein Programm, das in der Lage ist, Standard-Out-Ergebnisse eines Programms aufzufangen (manche besseren Texteditoren können das beispielsweise). Auf Unix-Systemen benutzen Sie einfach eine geeignete Shell. Wenn Sie den Pfad zu einer Moduldatei mit angeben, können Sie die Verzeichnisse mit einem Schrägstrich (<code>/</code>) trennen. Oder Sie wechseln in das Verzeichnis der Moduldatei. Dann können Sie die Pfadangabe weglassen.<br>
Im obigen Beispiel der Moduldatei <i>Nox.pm</i> sind Aufrufe möglich wie:<br>
<code>perldoc CPAN::Nox</code><br>
<code>perldoc Nox.pm</code><br>
<code>perldoc Nox</code><br>
<code>perldoc -m Nox</code> (listet den Quellcode mit auf)</p>



<table cellpadding="4" cellspacing="0" border="0" width="100%">
<tr><td colspan="2" class="doc">
&nbsp;<a href="#top"><img src="../../src/up.gif" width="14" height="10" border="0" alt="nach oben"></a>
</td></tr>
<tr><td class="doc"><a href="standardmodule.htm"><img src="../../src/next.gif" width="10" height="10" border="0" hspace="10" alt="weiter"></a></td>
<td width="100%"><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="standardmodule.htm">Standardmodule von Perl</a>
</td></tr>
<tr>
<td class="doc"><a href="../funktionen/module.htm"><img src="../../src/prev.gif" width="10" height="10" border="0" hspace="10" alt="zurück"></a></td>
<td><img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../funktionen/module.htm">Funktionen für Module und Packages</a>
</td>
</tr>
<tr><td colspan="2" class="doc">&nbsp;</td>
</tr>
<tr>
<td colspan="2" class="nav"><a class="an" name="bottom"><img src="../../src/refkap.gif" width="16" height="13" alt="Teil von"></a> <a href="../../index.htm">SELFHTML</a>/<a href="../../navigation/index.htm" target="_parent" class="navh">Navigationshilfen</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="../index.htm">Perl</a> <img src="../../src/refkap.gif" width="16" height="13" alt="Teil von">&nbsp;<a href="index.htm">Perl-Module</a></td>
</tr>
</table>

<p>&copy; 2007 <img src="../../src/dok.gif" width="15" height="10" alt="Seite">&nbsp;<a href="../../editorial/impressum.htm">Impressum</a></p>

</body>
</html>
